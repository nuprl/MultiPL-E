{
  "name": "HumanEval_3_below_zero",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n",
  "tests": "unittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else if (operations[i] < 0)\n            balance -= operations[i];\n        else\n            return true;\n    }\n    return balance < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk9_6fe8o.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpk9_6fe8o.__unittest_L30_C1() [0x427ee9]\n??:? void tmpk9_6fe8o.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4263weeg.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmp4263weeg.__unittest_L29_C1() [0x427e5d]\n??:? void tmp4263weeg.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length && operations[i] >= 0)\n        i++;\n    if (i == operations.length)\n        return false;\n    return true;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpen5padq0.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpen5padq0.__unittest_L22_C1() [0x427de2]\n??:? void tmpen5padq0.__modtest() [0x427fd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaeo0zbbl.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpaeo0zbbl.__unittest_L31_C1() [0x427ebd]\n??:? void tmpaeo0zbbl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length)\n    {\n        if (operations[i] < 0)\n        {\n            if (i == 0)\n                return true;\n            else\n                return false;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp22qbx0ag.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmp22qbx0ag.__unittest_L29_C1() [0x427e4d]\n??:? void tmp22qbx0ag.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate()) [0x42869f]\n??:? _d_run_ma",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int n = operations.length;\n    long sum = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "/tmp/tmpibbz47ay.d(15): Error: cannot implicitly convert expression `operations.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpibbz47ay.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi3n0ux76.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpi3n0ux76.__unittest_L24_C1() [0x427e55]\n??:? void tmpi3n0ux76.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length)\n    {\n        if (operations[i] < 0)\n        {\n            if (operations[i] < -operations[i + 1])\n            {\n                return true;\n            }\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl1igsddj.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpl1igsddj.__unittest_L29_C1() [0x427e36]\n??:? void tmpl1igsddj.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if (sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw8_rjoop.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpw8_rjoop.__unittest_L26_C1() [0x427e55]\n??:? void tmpw8_rjoop.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp55ru4yv7.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp55ru4yv7.__unittest_L23_C1() [0x427e55]\n??:? void tmp55ru4yv7.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else if (operations[i] < 0)\n            balance -= operations[i];\n        else\n            return false;\n    }\n    return balance < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzdsy3krp.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpzdsy3krp.__unittest_L30_C1() [0x427ee9]\n??:? void tmpzdsy3krp.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqboauovv.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpqboauovv.__unittest_L31_C1() [0x427ebd]\n??:? void tmpqboauovv.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else if(operations[i] < 0)\n            balance -= operations[i];\n        else\n            return false;\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmsy_so7h.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpmsy_so7h.__unittest_L34_C1() [0x427ef5]\n??:? void tmpmsy_so7h.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ee]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430381]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430830]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43030d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c5]\n??:? runModuleUnitTests [0x42c131]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        balance += operations[i];\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqboauovv.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpqboauovv.__unittest_L31_C1() [0x427ebd]\n??:? void tmpqboauovv.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpej_enu48.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpej_enu48.__unittest_L23_C1() [0x427e55]\n??:? void tmpej_enu48.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3vwje995.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp3vwje995.__unittest_L24_C1() [0x427e55]\n??:? void tmp3vwje995.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpey0x50xa.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpey0x50xa.__unittest_L22_C1() [0x427e55]\n??:? void tmpey0x50xa.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpypamdizb.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpypamdizb.__unittest_L23_C1() [0x427e55]\n??:? void tmpypamdizb.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqboauovv.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpqboauovv.__unittest_L31_C1() [0x427ebd]\n??:? void tmpqboauovv.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            if (balance < 0) return true;\n            balance = 0;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpusa8uejx.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpusa8uejx.__unittest_L31_C1() [0x427e99]\n??:? void tmpusa8uejx.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfjjzmf7g.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpfjjzmf7g.__unittest_L24_C1() [0x427e55]\n??:? void tmpfjjzmf7g.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            if (balance < 0)\n                return true;\n            balance = 0;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv4n2xr5x.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpv4n2xr5x.__unittest_L34_C1() [0x427e99]\n??:? void tmpv4n2xr5x.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while(i < operations.length)\n    {\n        if(operations[i] < 0)\n        {\n            if(i == 0)\n            {\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        i++;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd17fupe8.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmpd17fupe8.__unittest_L34_C1() [0x427e4d]\n??:? void tmpd17fupe8.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3vwje995.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp3vwje995.__unittest_L24_C1() [0x427e55]\n??:? void tmp3vwje995.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    if(sum < 0)\n        return true;\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmprqozlm6u.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmprqozlm6u.__unittest_L26_C1() [0x427e5d]\n??:? void tmprqozlm6u.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while(i < operations.length)\n    {\n        if(operations[i] < 0)\n        {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpm9b9ky88.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpm9b9ky88.__unittest_L27_C1() [0x427dde]\n??:? void tmpm9b9ky88.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2k1gb5ys.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp2k1gb5ys.__unittest_L32_C1() [0x427ebd]\n??:? void tmp2k1gb5ys.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        if(balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0i18mpk5.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp0i18mpk5.__unittest_L34_C1() [0x427e5a]\n??:? void tmp0i18mpk5.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl25kk14q.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpl25kk14q.__unittest_L24_C1() [0x427dde]\n??:? void tmpl25kk14q.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp83rhuyxl.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp83rhuyxl.__unittest_L36_C1() [0x427e5a]\n??:? void tmp83rhuyxl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while(i < operations.length)\n    {\n        if(operations[i] < 0)\n        {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7bdor_1b.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmp7bdor_1b.__unittest_L26_C1() [0x427dde]\n??:? void tmp7bdor_1b.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9w9e8d0d.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp9w9e8d0d.__unittest_L26_C1() [0x427e55]\n??:? void tmp9w9e8d0d.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpej_enu48.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpej_enu48.__unittest_L23_C1() [0x427e55]\n??:? void tmpej_enu48.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0) return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4loi6l2j.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmp4loi6l2j.__unittest_L27_C1() [0x427e5d]\n??:? void tmp4loi6l2j.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu73q64ii.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpu73q64ii.__unittest_L27_C1() [0x427e5d]\n??:? void tmpu73q64ii.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if (sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3vwje995.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp3vwje995.__unittest_L24_C1() [0x427e55]\n??:? void tmp3vwje995.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2k1gb5ys.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp2k1gb5ys.__unittest_L32_C1() [0x427ebd]\n??:? void tmp2k1gb5ys.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else if(operations[i] < 0)\n            balance -= operations[i];\n        else\n            return true;\n    }\n    return balance < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk1vkomt0.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpk1vkomt0.__unittest_L30_C1() [0x427ee9]\n??:? void tmpk1vkomt0.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl25kk14q.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpl25kk14q.__unittest_L24_C1() [0x427dde]\n??:? void tmpl25kk14q.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaeo0zbbl.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpaeo0zbbl.__unittest_L31_C1() [0x427ebd]\n??:? void tmpaeo0zbbl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaeo0zbbl.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpaeo0zbbl.__unittest_L31_C1() [0x427ebd]\n??:? void tmpaeo0zbbl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpym2ad8q8.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpym2ad8q8.__unittest_L25_C1() [0x427dde]\n??:? void tmpym2ad8q8.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else if (operations[i] < 0)\n            balance -= operations[i];\n        else if (operations[i] == 0)\n            continue;\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyrmubsh1.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428325]\n??:? void tmpyrmubsh1.__unittest_L33_C1() [0x427f19]\n??:? void tmpyrmubsh1.__modtest() [0x4280a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c383]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b216]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430858]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430335]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1ed]\n??:? runModuleUnitTests [0x42c159]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpey0x50xa.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpey0x50xa.__unittest_L22_C1() [0x427e55]\n??:? void tmpey0x50xa.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n        {\n            balance += operations[i];\n        }\n        else if (operations[i] < 0)\n        {\n            balance -= operations[i];\n            if (balance < 0)\n                return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfn5rjex0.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpfn5rjex0.__unittest_L34_C1() [0x427ee9]\n??:? void tmpfn5rjex0.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpef777dh1.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpef777dh1.__unittest_L34_C1() [0x427e5a]\n??:? void tmpef777dh1.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqboauovv.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpqboauovv.__unittest_L31_C1() [0x427ebd]\n??:? void tmpqboauovv.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4263weeg.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmp4263weeg.__unittest_L29_C1() [0x427e5d]\n??:? void tmp4263weeg.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4263weeg.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmp4263weeg.__unittest_L29_C1() [0x427e5d]\n??:? void tmp4263weeg.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj2n8_w22.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpj2n8_w22.__unittest_L35_C1() [0x427e5a]\n??:? void tmpj2n8_w22.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaeo0zbbl.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpaeo0zbbl.__unittest_L31_C1() [0x427ebd]\n??:? void tmpaeo0zbbl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaeo0zbbl.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpaeo0zbbl.__unittest_L31_C1() [0x427ebd]\n??:? void tmpaeo0zbbl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int n = operations.length;\n    long sum = 0L;\n    for (int i = 0; i < n; i++) {\n        sum += operations[i];\n    }\n    return sum < 0L;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "/tmp/tmprovbmugi.d(15): Error: cannot implicitly convert expression `operations.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprovbmugi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9w9e8d0d.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp9w9e8d0d.__unittest_L26_C1() [0x427e55]\n??:? void tmp9w9e8d0d.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp55ru4yv7.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp55ru4yv7.__unittest_L23_C1() [0x427e55]\n??:? void tmp55ru4yv7.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        balance += operations[i];\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi3n0ux76.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpi3n0ux76.__unittest_L24_C1() [0x427e55]\n??:? void tmpi3n0ux76.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpey0x50xa.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpey0x50xa.__unittest_L22_C1() [0x427e55]\n??:? void tmpey0x50xa.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaeo0zbbl.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpaeo0zbbl.__unittest_L31_C1() [0x427ebd]\n??:? void tmpaeo0zbbl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz8_vbwk2.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpz8_vbwk2.__unittest_L25_C1() [0x427e55]\n??:? void tmpz8_vbwk2.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaeo0zbbl.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpaeo0zbbl.__unittest_L31_C1() [0x427ebd]\n??:? void tmpaeo0zbbl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl25kk14q.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpl25kk14q.__unittest_L24_C1() [0x427dde]\n??:? void tmpl25kk14q.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int len = operations.length;\n    if(len == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < len; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "/tmp/tmpd00w0bn8.d(15): Error: cannot implicitly convert expression `operations.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd00w0bn8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp83rhuyxl.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp83rhuyxl.__unittest_L36_C1() [0x427e5a]\n??:? void tmp83rhuyxl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4263weeg.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmp4263weeg.__unittest_L29_C1() [0x427e5d]\n??:? void tmp4263weeg.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3vwje995.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp3vwje995.__unittest_L24_C1() [0x427e55]\n??:? void tmp3vwje995.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++) {\n        if (operations[i] < 0) {\n            balance += operations[i];\n        } else {\n            balance -= operations[i];\n        }\n        if (balance < 0) return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptt4uljqv.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmptt4uljqv.__unittest_L28_C1() [0x427e5a]\n??:? void tmptt4uljqv.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj2n8_w22.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpj2n8_w22.__unittest_L35_C1() [0x427e5a]\n??:? void tmpj2n8_w22.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else if (operations[i] < 0)\n            balance -= operations[i];\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp82p6m1eq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmp82p6m1eq.__unittest_L29_C1() [0x427ee9]\n??:? void tmp82p6m1eq.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc9v2ooqb.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpc9v2ooqb.__unittest_L24_C1() [0x427e55]\n??:? void tmpc9v2ooqb.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpej_enu48.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpej_enu48.__unittest_L23_C1() [0x427e55]\n??:? void tmpej_enu48.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp83rhuyxl.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp83rhuyxl.__unittest_L36_C1() [0x427e5a]\n??:? void tmp83rhuyxl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxmwvngo6.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpxmwvngo6.__unittest_L27_C1() [0x427e5d]\n??:? void tmpxmwvngo6.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9w9e8d0d.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp9w9e8d0d.__unittest_L26_C1() [0x427e55]\n??:? void tmp9w9e8d0d.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else if (operations[i] < 0)\n            balance -= operations[i];\n        else\n            return true;\n    }\n    return balance < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk9_6fe8o.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpk9_6fe8o.__unittest_L30_C1() [0x427ee9]\n??:? void tmpk9_6fe8o.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    if(sum < 0)\n        return true;\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsmn89485.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpsmn89485.__unittest_L24_C1() [0x427e5d]\n??:? void tmpsmn89485.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++) {\n        if (operations[i] > 0) {\n            balance += operations[i];\n        } else {\n            if (balance < 0) return true;\n            balance = 0;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_j7scke6.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmp_j7scke6.__unittest_L28_C1() [0x427e99]\n??:? void tmp_j7scke6.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while(i < operations.length && operations[i] >= 0)\n        i++;\n    if(i == operations.length)\n        return false;\n    return true;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpg3at5f1c.d(27): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpg3at5f1c.__unittest_L22_C1() [0x427de2]\n??:? void tmpg3at5f1c.__modtest() [0x427fd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbep6wwt0.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpbep6wwt0.__unittest_L36_C1() [0x427e5a]\n??:? void tmpbep6wwt0.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n        {\n            balance += operations[i];\n        }\n        else if (operations[i] < 0)\n        {\n            balance -= operations[i];\n            if (balance < 0) return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf9i7lhf2.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpf9i7lhf2.__unittest_L32_C1() [0x427ee9]\n??:? void tmpf9i7lhf2.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4263weeg.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmp4263weeg.__unittest_L29_C1() [0x427e5d]\n??:? void tmp4263weeg.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu73q64ii.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpu73q64ii.__unittest_L27_C1() [0x427e5d]\n??:? void tmpu73q64ii.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        balance += operations[i];\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpey0x50xa.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpey0x50xa.__unittest_L22_C1() [0x427e55]\n??:? void tmpey0x50xa.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++) {\n        if (operations[i] > 0) {\n            balance += operations[i];\n        } else {\n            balance -= operations[i];\n        }\n        if (balance < 0) return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw_cie615.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpw_cie615.__unittest_L28_C1() [0x427ebd]\n??:? void tmpw_cie615.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int len = operations.length;\n    if (len == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < len; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "/tmp/tmpfi0cjjfm.d(15): Error: cannot implicitly convert expression `operations.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfi0cjjfm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpi3n0ux76.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpi3n0ux76.__unittest_L24_C1() [0x427e55]\n??:? void tmpi3n0ux76.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2k1gb5ys.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp2k1gb5ys.__unittest_L32_C1() [0x427ebd]\n??:? void tmp2k1gb5ys.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int n = operations.length;\n    long sum = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "/tmp/tmplw2qeh94.d(15): Error: cannot implicitly convert expression `operations.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplw2qeh94.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpef777dh1.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpef777dh1.__unittest_L34_C1() [0x427e5a]\n??:? void tmpef777dh1.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int n = operations.length;\n    if (n == 0) return false;\n    int i = 0;\n    int j = n - 1;\n    while (i < j) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        if (operations[j] < 0) {\n            return true;\n        }\n        if (operations[i] < operations[j]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "/tmp/tmpwg96qqcy.d(15): Error: cannot implicitly convert expression `operations.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwg96qqcy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else if (operations[i] < 0)\n            balance -= operations[i];\n        else\n            return true;\n    }\n    return balance < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk9_6fe8o.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmpk9_6fe8o.__unittest_L30_C1() [0x427ee9]\n??:? void tmpk9_6fe8o.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long balance = 0;\n    for (int i = 0; i < operations.length; i++) {\n        if (operations[i] > 0) {\n            balance += operations[i];\n        } else {\n            if (balance < 0) return true;\n            balance += operations[i];\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3zr_n4p0.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp3zr_n4p0.__unittest_L27_C1() [0x427ebd]\n??:? void tmp3zr_n4p0.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if (sum < 0)\n            return true;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu73q64ii.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpu73q64ii.__unittest_L27_C1() [0x427e5d]\n??:? void tmpu73q64ii.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx7miw2fx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpx7miw2fx.__unittest_L29_C1() [0x427e5d]\n??:? void tmpx7miw2fx.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            if (balance < 0)\n                return true;\n            balance = 0;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv4n2xr5x.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4282a5]\n??:? void tmpv4n2xr5x.__unittest_L34_C1() [0x427e99]\n??:? void tmpv4n2xr5x.__modtest() [0x428024]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c303]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b196]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430329]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b16d]\n??:? runModuleUnitTests [0x42c0d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428768]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9w9e8d0d.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp9w9e8d0d.__unittest_L26_C1() [0x427e55]\n??:? void tmp9w9e8d0d.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu73q64ii.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpu73q64ii.__unittest_L27_C1() [0x427e5d]\n??:? void tmpu73q64ii.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else if (operations[i] < 0)\n            balance -= operations[i];\n    }\n    return balance < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpakn56plq.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x4282ed]\n??:? void tmpakn56plq.__unittest_L28_C1() [0x427ee1]\n??:? void tmpakn56plq.__modtest() [0x42806c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c34b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1de]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430371]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430820]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302fd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1b5]\n??:? runModuleUnitTests [0x42c121]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl25kk14q.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpl25kk14q.__unittest_L24_C1() [0x427dde]\n??:? void tmpl25kk14q.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9w9e8d0d.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp9w9e8d0d.__unittest_L26_C1() [0x427e55]\n??:? void tmp9w9e8d0d.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0L;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_npx2yzu.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp_npx2yzu.__unittest_L32_C1() [0x427ebd]\n??:? void tmp_npx2yzu.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int len = operations.length;\n    long sum = 0;\n    for (int i = 0; i < len; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "/tmp/tmpf2cjoy19.d(15): Error: cannot implicitly convert expression `operations.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf2cjoy19.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0) return false;\n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        if(balance < 0) return true;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgmmnka2n.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpgmmnka2n.__unittest_L32_C1() [0x427e5a]\n??:? void tmpgmmnka2n.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu73q64ii.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpu73q64ii.__unittest_L27_C1() [0x427e5d]\n??:? void tmpu73q64ii.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu73q64ii.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpu73q64ii.__unittest_L27_C1() [0x427e5d]\n??:? void tmpu73q64ii.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if (sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu73q64ii.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpu73q64ii.__unittest_L27_C1() [0x427e5d]\n??:? void tmpu73q64ii.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxmwvngo6.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmpxmwvngo6.__unittest_L27_C1() [0x427e5d]\n??:? void tmpxmwvngo6.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaeo0zbbl.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpaeo0zbbl.__unittest_L31_C1() [0x427ebd]\n??:? void tmpaeo0zbbl.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqboauovv.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpqboauovv.__unittest_L31_C1() [0x427ebd]\n??:? void tmpqboauovv.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length)\n    {\n        if (operations[i] < 0)\n        {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyhdaitp1.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpyhdaitp1.__unittest_L26_C1() [0x427dde]\n??:? void tmpyhdaitp1.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj2n8_w22.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpj2n8_w22.__unittest_L35_C1() [0x427e5a]\n??:? void tmpj2n8_w22.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpef777dh1.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpef777dh1.__unittest_L34_C1() [0x427e5a]\n??:? void tmpef777dh1.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4263weeg.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmp4263weeg.__unittest_L29_C1() [0x427e5d]\n??:? void tmp4263weeg.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n        if(sum < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp55ru4yv7.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp55ru4yv7.__unittest_L23_C1() [0x427e55]\n??:? void tmp55ru4yv7.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpey0x50xa.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpey0x50xa.__unittest_L22_C1() [0x427e55]\n??:? void tmpey0x50xa.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else if (operations[i] < 0)\n            balance -= operations[i];\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp82p6m1eq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282f5]\n??:? void tmp82p6m1eq.__unittest_L29_C1() [0x427ee9]\n??:? void tmp82p6m1eq.__modtest() [0x428074]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c353]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1e6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430379]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430828]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430305]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1bd]\n??:? runModuleUnitTests [0x42c129]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbep6wwt0.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpbep6wwt0.__unittest_L36_C1() [0x427e5a]\n??:? void tmpbep6wwt0.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl25kk14q.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpl25kk14q.__unittest_L24_C1() [0x427dde]\n??:? void tmpl25kk14q.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    if (sum < 0)\n        return true;\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplarsats6.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmplarsats6.__unittest_L24_C1() [0x427e5d]\n??:? void tmplarsats6.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    long balance = 0L;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n        {\n            balance += operations[i];\n        }\n        else if(operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else if(operations[i] == 0)\n        {\n            continue;\n        }\n        else\n        {\n            return true;\n        }\n    }\n    return balance < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgbhdazsa.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x428315]\n??:? void tmpgbhdazsa.__unittest_L37_C1() [0x427f09]\n??:? void tmpgbhdazsa.__modtest() [0x428094]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c373]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b206]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430399]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430848]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430325]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1dd]\n??:? runModuleUnitTests [0x42c149]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpey0x50xa.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpey0x50xa.__unittest_L22_C1() [0x427e55]\n??:? void tmpey0x50xa.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while(i < operations.length)\n    {\n        if(operations[i] < 0)\n        {\n            if(i == 0)\n            {\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        i++;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd17fupe8.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmpd17fupe8.__unittest_L34_C1() [0x427e4d]\n??:? void tmpd17fupe8.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpym2ad8q8.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpym2ad8q8.__unittest_L25_C1() [0x427dde]\n??:? void tmpym2ad8q8.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9w9e8d0d.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmp9w9e8d0d.__unittest_L26_C1() [0x427e55]\n??:? void tmp9w9e8d0d.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk43v7wst.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpk43v7wst.__unittest_L22_C1() [0x427e55]\n??:? void tmpk43v7wst.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqpkq1v0z.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpqpkq1v0z.__unittest_L24_C1() [0x427e55]\n??:? void tmpqpkq1v0z.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n        if (sum < 0) return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while (i < operations.length) {\n        if (operations[i] < 0) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpym2ad8q8.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42824d]\n??:? void tmpym2ad8q8.__unittest_L25_C1() [0x427dde]\n??:? void tmpym2ad8q8.__modtest() [0x427fcc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b13e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430780]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43025d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b115]\n??:? runModuleUnitTests [0x42c081]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428710]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if (balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1wliya8i.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp1wliya8i.__unittest_L32_C1() [0x427ebd]\n??:? void tmp1wliya8i.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2k1gb5ys.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmp2k1gb5ys.__unittest_L32_C1() [0x427ebd]\n??:? void tmp2k1gb5ys.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0)\n        return false;\n    long balance = 0;\n    for (int i = 0; i < operations.length; i++)\n    {\n        if (operations[i] > 0)\n            balance += operations[i];\n        else\n            balance -= operations[i];\n        if (balance < 0)\n            return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvdugevo9.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpvdugevo9.__unittest_L29_C1() [0x427ebd]\n??:? void tmpvdugevo9.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        sum += operations[i];\n    }\n    \n    if(sum < 0)\n        return true;\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4263weeg.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428265]\n??:? void tmp4263weeg.__unittest_L29_C1() [0x427e5d]\n??:? void tmp4263weeg.__modtest() [0x427fe8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b156]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430798]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430275]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b12d]\n??:? runModuleUnitTests [0x42c099]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428728]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    long sum = 0;\n    for(int i = 0; i < operations.length; i++)\n        sum += operations[i];\n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvmtu58qs.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpvmtu58qs.__unittest_L22_C1() [0x427e55]\n??:? void tmpvmtu58qs.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if(operations.length == 0)\n        return false;\n    \n    long balance = 0;\n    for(int i = 0; i < operations.length; i++)\n    {\n        if(operations[i] < 0)\n        {\n            balance += operations[i];\n        }\n        else\n        {\n            balance -= operations[i];\n        }\n        \n        if(balance < 0)\n            return true;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbep6wwt0.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x4282c5]\n??:? void tmpbep6wwt0.__unittest_L36_C1() [0x427e5a]\n??:? void tmpbep6wwt0.__modtest() [0x428048]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c323]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1b6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430349]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4307f8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4302d5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b18d]\n??:? runModuleUnitTests [0x42c0f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428788]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    int i = 0;\n    while(i < operations.length)\n    {\n        if(operations[i] < 0)\n        {\n            if(i == 0)\n            {\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        i++;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjxzo3i7h.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x428255]\n??:? void tmpjxzo3i7h.__unittest_L33_C1() [0x427e4d]\n??:? void tmpjxzo3i7h.__modtest() [0x427fd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b146]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302d9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430788]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430265]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b11d]\n??:? runModuleUnitTests [0x42c089]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428718]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n You're given an array of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return true. Otherwise it should return false.\n    >>> below_zero([1L, 2L, 3L])\n    false\n    >>> below_zero([1L, 2L, -4L, 5L])\n    true\n    \n*/\nbool below_zero(long[] operations) \n{\n    if (operations.length == 0) return false;\n    \n    long sum = 0;\n    for (int i = 0; i < operations.length; i++) {\n        sum += operations[i];\n    }\n    \n    return sum < 0;\n}\nunittest\n{\n    alias candidate = below_zero;\n\n    assert(candidate([]) == false);\n    assert(candidate([1L, 2L, -3L, 1L, 2L, -3L]) == false);\n    assert(candidate([1L, 2L, -4L, 5L, 6L]) == true);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -4L]) == false);\n    assert(candidate([1L, -1L, 2L, -2L, 5L, -5L, 4L, -5L]) == true);\n    assert(candidate([1L, -2L, 2L, -2L, 5L, -5L, 4L, -4L]) == true);\n}\nvoid main(){}",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwpi46203.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42825d]\n??:? void tmpwpi46203.__unittest_L24_C1() [0x427e55]\n??:? void tmpwpi46203.__modtest() [0x427fe0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c2bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b14e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4302e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430790]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43026d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b125]\n??:? runModuleUnitTests [0x42c091]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428720]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}