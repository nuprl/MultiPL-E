{
  "name": "HumanEval_108_count_nums",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n",
  "tests": "unittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp5rmv6ac6.d(20): Error: semicolon expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: expression expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmv6ac6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0L;\n    for(long i = 0; i < arr.length; i++)\n    {\n        sum += arr[i];\n    }\n    \n    if(sum < 0)\n    {\n        sum = 0L;\n        for(long i = 0; i < arr.length; i++)\n        {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9zqqjguj.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x42831d]\n??:? void tmp9zqqjguj.__unittest_L36_C1() [0x427e3e]\n??:? void tmp9zqqjguj.__modtest() [0x4280a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c39f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b232]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430874]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430351]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b209]\n??:? runModuleUnitTests [0x42c175]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr, i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpolyid1g0.d(20): Error: semicolon expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: expression expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolyid1g0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8lrilmpc.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp8lrilmpc.__unittest_L27_C1() [0x427ea1]\n??:? void tmp8lrilmpc.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp45f29v12.d(20): Error: semicolon expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: expression expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45f29v12.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx17kjjt.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpwx17kjjt.__unittest_L27_C1() [0x427ea1]\n??:? void tmpwx17kjjt.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx17kjjt.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpwx17kjjt.__unittest_L27_C1() [0x427ea1]\n??:? void tmpwx17kjjt.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr, i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpolyid1g0.d(20): Error: semicolon expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: expression expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolyid1g0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    return sum > 0 ? arr.length : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp8wnqi3qm.d(20): Error: semicolon expected, not `:`\n/tmp/tmp8wnqi3qm.d(20): Error: expression expected, not `:`\n/tmp/tmp8wnqi3qm.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8wnqi3qm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n        sum += arr[i];\n    }\n    \n    return sum > 0 ? arr.length : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpn83d3zvd.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpn83d3zvd.__unittest_L27_C1() [0x427e85]\n??:? void tmpn83d3zvd.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c367]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43038d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43083c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430319]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d1]\n??:? runModuleUnitTests [0x42c13d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpn7b3q7h1.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmpn7b3q7h1.__unittest_L27_C1() [0x427ea5]\n??:? void tmpn7b3q7h1.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c387]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43085c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430339]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]\n??:? runModuleUnitTests [0x42c15d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp4eqstc4q.d(20): Error: semicolon expected, not `:`\n/tmp/tmp4eqstc4q.d(20): Error: expression expected, not `:`\n/tmp/tmp4eqstc4q.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4eqstc4q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8lrilmpc.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp8lrilmpc.__unittest_L27_C1() [0x427ea1]\n??:? void tmp8lrilmpc.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp2iq1nrt1.d(20): Error: semicolon expected, not `:`\n/tmp/tmp2iq1nrt1.d(20): Error: expression expected, not `:`\n/tmp/tmp2iq1nrt1.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2iq1nrt1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp_1pn906y.d(20): Error: semicolon expected, not `:`\n/tmp/tmp_1pn906y.d(20): Error: expression expected, not `:`\n/tmp/tmp_1pn906y.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_1pn906y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplt5qafm0.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmplt5qafm0.__unittest_L27_C1() [0x427ea5]\n??:? void tmplt5qafm0.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c387]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43085c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430339]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]\n??:? runModuleUnitTests [0x42c15d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n    \n    return sum > 0 ? 1 : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7f87l7xw.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmp7f87l7xw.__unittest_L26_C1() [0x427e81]\n??:? void tmp7f87l7xw.__modtest() [0x428060]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430385]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430834]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430311]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]\n??:? runModuleUnitTests [0x42c135]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i: arr)\n    {\n        if(i < 0)\n        {\n            count += Math.abs(i);\n        }\n        else\n        {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpeq6pzi25.d(20): Error: semicolon expected, not `:`\n/tmp/tmpeq6pzi25.d(20): Error: expression expected, not `:`\n/tmp/tmpeq6pzi25.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeq6pzi25.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr, i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpolyid1g0.d(20): Error: semicolon expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: expression expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolyid1g0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp5rmv6ac6.d(20): Error: semicolon expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: expression expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmv6ac6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for(long i : arr)\n        sum += i;\n    return sum > 0 ? arr.length : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp7a48rf9y.d(20): Error: semicolon expected, not `:`\n/tmp/tmp7a48rf9y.d(20): Error: expression expected, not `:`\n/tmp/tmp7a48rf9y.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7a48rf9y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr, i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpolyid1g0.d(20): Error: semicolon expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: expression expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolyid1g0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else if (i > 0) {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpci9qs4gq.d(20): Error: semicolon expected, not `:`\n/tmp/tmpci9qs4gq.d(20): Error: expression expected, not `:`\n/tmp/tmpci9qs4gq.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpci9qs4gq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr, i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpolyid1g0.d(20): Error: semicolon expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: expression expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolyid1g0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    return sum > 0 ? arr.length : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp8wnqi3qm.d(20): Error: semicolon expected, not `:`\n/tmp/tmp8wnqi3qm.d(20): Error: expression expected, not `:`\n/tmp/tmp8wnqi3qm.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8wnqi3qm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += Math.abs(i);\n        } else {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpeiexvvos.d(20): Error: semicolon expected, not `:`\n/tmp/tmpeiexvvos.d(20): Error: expression expected, not `:`\n/tmp/tmpeiexvvos.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeiexvvos.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp45f29v12.d(20): Error: semicolon expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: expression expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45f29v12.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n            continue;\n        }\n        count += count_nums(arr, i);\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpllvvz6hb.d(20): Error: semicolon expected, not `:`\n/tmp/tmpllvvz6hb.d(20): Error: expression expected, not `:`\n/tmp/tmpllvvz6hb.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpllvvz6hb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp45f29v12.d(20): Error: semicolon expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: expression expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45f29v12.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplt5qafm0.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmplt5qafm0.__unittest_L27_C1() [0x427ea5]\n??:? void tmplt5qafm0.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c387]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43085c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430339]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]\n??:? runModuleUnitTests [0x42c15d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n        if(arr[i] >= 0)\n        {\n            sum += arr[i];\n        }\n        else\n        {\n            sum += arr[i] % 10;\n            sum += arr[i] / 10;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmph3c0vxel.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42836d]\n??:? void tmph3c0vxel.__unittest_L34_C1() [0x427e8e]\n??:? void tmph3c0vxel.__modtest() [0x4280f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b282]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430415]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308c4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4303a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b259]\n??:? runModuleUnitTests [0x42c1c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428830]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long num : arr) {\n        if (num > 0) {\n            count += count_nums(num);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpiu7skz7j.d(20): Error: semicolon expected, not `:`\n/tmp/tmpiu7skz7j.d(20): Error: expression expected, not `:`\n/tmp/tmpiu7skz7j.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiu7skz7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp5rmv6ac6.d(20): Error: semicolon expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: expression expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmv6ac6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr, i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpolyid1g0.d(20): Error: semicolon expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: expression expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolyid1g0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (int i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n    return sum > 0 ? 1 : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd76rrmgb.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmpd76rrmgb.__unittest_L25_C1() [0x427e85]\n??:? void tmpd76rrmgb.__modtest() [0x428064]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c367]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43038d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43083c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430319]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d1]\n??:? runModuleUnitTests [0x42c13d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    return sum > 0 ? 1 : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpkf13ywmg.d(20): Error: semicolon expected, not `:`\n/tmp/tmpkf13ywmg.d(20): Error: expression expected, not `:`\n/tmp/tmpkf13ywmg.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkf13ywmg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp2iq1nrt1.d(20): Error: semicolon expected, not `:`\n/tmp/tmp2iq1nrt1.d(20): Error: expression expected, not `:`\n/tmp/tmp2iq1nrt1.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2iq1nrt1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0cjplqf1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmp0cjplqf1.__unittest_L27_C1() [0x427fc1]\n??:? void tmp0cjplqf1.__modtest() [0x42805c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430385]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430834]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430311]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]\n??:? runModuleUnitTests [0x42c135]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i] % 10;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmtcqpl_y.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmpmtcqpl_y.__unittest_L27_C1() [0x427eb1]\n??:? void tmpmtcqpl_y.__modtest() [0x428090]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += Math.abs(i);\n        } else {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpeiexvvos.d(20): Error: semicolon expected, not `:`\n/tmp/tmpeiexvvos.d(20): Error: expression expected, not `:`\n/tmp/tmpeiexvvos.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeiexvvos.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp_1pn906y.d(20): Error: semicolon expected, not `:`\n/tmp/tmp_1pn906y.d(20): Error: expression expected, not `:`\n/tmp/tmp_1pn906y.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_1pn906y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp4eqstc4q.d(20): Error: semicolon expected, not `:`\n/tmp/tmp4eqstc4q.d(20): Error: expression expected, not `:`\n/tmp/tmp4eqstc4q.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4eqstc4q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0cjplqf1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmp0cjplqf1.__unittest_L27_C1() [0x427fc1]\n??:? void tmp0cjplqf1.__modtest() [0x42805c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430385]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430834]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430311]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]\n??:? runModuleUnitTests [0x42c135]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp5rmv6ac6.d(20): Error: semicolon expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: expression expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmv6ac6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp4eqstc4q.d(20): Error: semicolon expected, not `:`\n/tmp/tmp4eqstc4q.d(20): Error: expression expected, not `:`\n/tmp/tmp4eqstc4q.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4eqstc4q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n        sum += arr[i];\n    }\n    if(sum < 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return arr.length;\n    }\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptnoy855c.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4282e5]\n??:? void tmptnoy855c.__unittest_L33_C1() [0x427e89]\n??:? void tmptnoy855c.__modtest() [0x428068]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c367]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43038d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43083c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430319]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d1]\n??:? runModuleUnitTests [0x42c13d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else if (i > 0) {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpci9qs4gq.d(20): Error: semicolon expected, not `:`\n/tmp/tmpci9qs4gq.d(20): Error: expression expected, not `:`\n/tmp/tmpci9qs4gq.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpci9qs4gq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i : arr) {\n        if(i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpiq0j3097.d(20): Error: semicolon expected, not `:`\n/tmp/tmpiq0j3097.d(20): Error: expression expected, not `:`\n/tmp/tmpiq0j3097.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiq0j3097.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp5rmv6ac6.d(20): Error: semicolon expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: expression expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmv6ac6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp45f29v12.d(20): Error: semicolon expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: expression expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45f29v12.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp5rmv6ac6.d(20): Error: semicolon expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: expression expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmv6ac6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp45f29v12.d(20): Error: semicolon expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: expression expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45f29v12.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i : arr)\n    {\n        if(i > 0)\n            count += math.count_digits(i);\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpvzvm2qjg.d(20): Error: semicolon expected, not `:`\n/tmp/tmpvzvm2qjg.d(20): Error: expression expected, not `:`\n/tmp/tmpvzvm2qjg.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvzvm2qjg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0L;\n    for (long i : arr) {\n        if (i < 0L) {\n            sum += i;\n        } else {\n            sum += i % 10L;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp7523hzpc.d(20): Error: semicolon expected, not `:`\n/tmp/tmp7523hzpc.d(20): Error: expression expected, not `:`\n/tmp/tmp7523hzpc.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7523hzpc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long num : arr) {\n        if (num > 0) {\n            count += num;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp6em6829s.d(20): Error: semicolon expected, not `:`\n/tmp/tmp6em6829s.d(20): Error: expression expected, not `:`\n/tmp/tmp6em6829s.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6em6829s.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        }\n        else {\n            sum += i % 10;\n        }\n    }\n    return sum > 0 ? 1 : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpes1wmvho.d(20): Error: semicolon expected, not `:`\n/tmp/tmpes1wmvho.d(20): Error: expression expected, not `:`\n/tmp/tmpes1wmvho.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpes1wmvho.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += Math.log10(i) + 1;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpysfry37h.d(20): Error: semicolon expected, not `:`\n/tmp/tmpysfry37h.d(20): Error: expression expected, not `:`\n/tmp/tmpysfry37h.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpysfry37h.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else if (i > 0) {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpci9qs4gq.d(20): Error: semicolon expected, not `:`\n/tmp/tmpci9qs4gq.d(20): Error: expression expected, not `:`\n/tmp/tmpci9qs4gq.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpci9qs4gq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i] % 10;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj4j_8unl.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmpj4j_8unl.__unittest_L27_C1() [0x427ead]\n??:? void tmpj4j_8unl.__modtest() [0x42808c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            result += arr[i] % 10;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqmbjeba8.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x42830d]\n??:? void tmpqmbjeba8.__unittest_L27_C1() [0x427eb1]\n??:? void tmpqmbjeba8.__modtest() [0x428090]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c38f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b222]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430864]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430341]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]\n??:? runModuleUnitTests [0x42c165]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287d0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += Math.pow(10, Math.floor(Math.log10(i)));\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpwc1xarlw.d(20): Error: semicolon expected, not `:`\n/tmp/tmpwc1xarlw.d(20): Error: expression expected, not `:`\n/tmp/tmpwc1xarlw.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwc1xarlw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += Math.abs(i);\n        } else {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpeiexvvos.d(20): Error: semicolon expected, not `:`\n/tmp/tmpeiexvvos.d(20): Error: expression expected, not `:`\n/tmp/tmpeiexvvos.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeiexvvos.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplt5qafm0.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmplt5qafm0.__unittest_L27_C1() [0x427ea5]\n??:? void tmplt5qafm0.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c387]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43085c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430339]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]\n??:? runModuleUnitTests [0x42c15d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i : arr)\n    {\n        if(i > 0)\n        {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpmfhq2jed.d(20): Error: semicolon expected, not `:`\n/tmp/tmpmfhq2jed.d(20): Error: expression expected, not `:`\n/tmp/tmpmfhq2jed.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmfhq2jed.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpufhp6nr1.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmpufhp6nr1.__unittest_L29_C1() [0x427ea5]\n??:? void tmpufhp6nr1.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c387]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43085c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430339]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]\n??:? runModuleUnitTests [0x42c15d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr, i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpolyid1g0.d(20): Error: semicolon expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: expression expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolyid1g0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp45f29v12.d(20): Error: semicolon expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: expression expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45f29v12.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0cjplqf1.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282dd]\n??:? void tmp0cjplqf1.__unittest_L27_C1() [0x427fc1]\n??:? void tmp0cjplqf1.__modtest() [0x42805c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c35f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430385]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430834]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430311]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]\n??:? runModuleUnitTests [0x42c135]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx17kjjt.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpwx17kjjt.__unittest_L27_C1() [0x427ea1]\n??:? void tmpwx17kjjt.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (int i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n    if (sum < 0) {\n        return 0;\n    }\n    \n    long result = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            result += arr[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpk1n0a55q.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x42835d]\n??:? void tmpk1n0a55q.__unittest_L35_C1() [0x427efd]\n??:? void tmpk1n0a55q.__modtest() [0x4280dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b272]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430405]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430391]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b249]\n??:? runModuleUnitTests [0x42c1b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428820]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i : arr)\n    {\n        if(i > 0)\n        {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpmfhq2jed.d(20): Error: semicolon expected, not `:`\n/tmp/tmpmfhq2jed.d(20): Error: expression expected, not `:`\n/tmp/tmpmfhq2jed.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmfhq2jed.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp45f29v12.d(20): Error: semicolon expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: expression expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45f29v12.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for(long i : arr) {\n        sum += i;\n    }\n    return sum > 0 ? 1 : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp8dc9jjru.d(20): Error: semicolon expected, not `:`\n/tmp/tmp8dc9jjru.d(20): Error: expression expected, not `:`\n/tmp/tmp8dc9jjru.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8dc9jjru.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpwx17kjjt.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpwx17kjjt.__unittest_L27_C1() [0x427ea1]\n??:? void tmpwx17kjjt.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long result = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            result += arr[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9dspv2cm.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp9dspv2cm.__unittest_L27_C1() [0x427ea1]\n??:? void tmp9dspv2cm.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for(long i : arr)\n    {\n        if(i < 0)\n        {\n            sum += i;\n        }\n        else\n        {\n            sum += i % 10;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpk519hj7c.d(20): Error: semicolon expected, not `:`\n/tmp/tmpk519hj7c.d(20): Error: expression expected, not `:`\n/tmp/tmpk519hj7c.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk519hj7c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    return sum > 0 ? arr.length : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp8wnqi3qm.d(20): Error: semicolon expected, not `:`\n/tmp/tmp8wnqi3qm.d(20): Error: expression expected, not `:`\n/tmp/tmp8wnqi3qm.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8wnqi3qm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp5rmv6ac6.d(20): Error: semicolon expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: expression expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmv6ac6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr, i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpolyid1g0.d(20): Error: semicolon expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: expression expected, not `:`\n/tmp/tmpolyid1g0.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpolyid1g0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += Math.abs(i) % 10;\n        } else {\n            count += i % 10;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpxc1ayxet.d(20): Error: semicolon expected, not `:`\n/tmp/tmpxc1ayxet.d(20): Error: expression expected, not `:`\n/tmp/tmpxc1ayxet.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxc1ayxet.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i : arr)\n    {\n        if(i > 0)\n        {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpmfhq2jed.d(20): Error: semicolon expected, not `:`\n/tmp/tmpmfhq2jed.d(20): Error: expression expected, not `:`\n/tmp/tmpmfhq2jed.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmfhq2jed.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8lrilmpc.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp8lrilmpc.__unittest_L27_C1() [0x427ea1]\n??:? void tmp8lrilmpc.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp45f29v12.d(20): Error: semicolon expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: expression expected, not `:`\n/tmp/tmp45f29v12.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45f29v12.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8lrilmpc.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp8lrilmpc.__unittest_L27_C1() [0x427ea1]\n??:? void tmp8lrilmpc.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long num : arr) {\n        if (num > 0) {\n            count += count_nums(num);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpiu7skz7j.d(20): Error: semicolon expected, not `:`\n/tmp/tmpiu7skz7j.d(20): Error: expression expected, not `:`\n/tmp/tmpiu7skz7j.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiu7skz7j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8lrilmpc.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp8lrilmpc.__unittest_L27_C1() [0x427ea1]\n??:? void tmp8lrilmpc.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (int i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n    if (sum < 0) {\n        return 0;\n    }\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvn8eza4b.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x42835d]\n??:? void tmpvn8eza4b.__unittest_L34_C1() [0x427efd]\n??:? void tmpvn8eza4b.__modtest() [0x4280dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c3df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b272]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430405]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4308b4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430391]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b249]\n??:? runModuleUnitTests [0x42c1b5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428820]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp_1pn906y.d(20): Error: semicolon expected, not `:`\n/tmp/tmp_1pn906y.d(20): Error: expression expected, not `:`\n/tmp/tmp_1pn906y.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_1pn906y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    return sum;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp2iq1nrt1.d(20): Error: semicolon expected, not `:`\n/tmp/tmp2iq1nrt1.d(20): Error: expression expected, not `:`\n/tmp/tmp2iq1nrt1.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2iq1nrt1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i : arr)\n    {\n        if(i < 0)\n        {\n            count += count_nums(arr);\n            continue;\n        }\n        count += count_nums(arr);\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpnmii_uu8.d(20): Error: semicolon expected, not `:`\n/tmp/tmpnmii_uu8.d(20): Error: expression expected, not `:`\n/tmp/tmpnmii_uu8.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnmii_uu8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++) {\n        if(arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8lrilmpc.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmp8lrilmpc.__unittest_L27_C1() [0x427ea1]\n??:? void tmp8lrilmpc.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq29m_uwo.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmpq29m_uwo.__unittest_L29_C1() [0x427fbd]\n??:? void tmpq29m_uwo.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplt5qafm0.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428305]\n??:? void tmplt5qafm0.__unittest_L27_C1() [0x427ea5]\n??:? void tmplt5qafm0.__modtest() [0x428084]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c387]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b21a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43085c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430339]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]\n??:? runModuleUnitTests [0x42c15d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long sum = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    return sum > 0 ? arr.length : 0;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp8wnqi3qm.d(20): Error: semicolon expected, not `:`\n/tmp/tmp8wnqi3qm.d(20): Error: expression expected, not `:`\n/tmp/tmp8wnqi3qm.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8wnqi3qm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptsd2upcq.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmptsd2upcq.__unittest_L29_C1() [0x427ea1]\n??:? void tmptsd2upcq.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i : arr) {\n        if(i < 0) {\n            count += count_nums(arr);\n        } else {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpzngjrimf.d(20): Error: semicolon expected, not `:`\n/tmp/tmpzngjrimf.d(20): Error: expression expected, not `:`\n/tmp/tmpzngjrimf.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzngjrimf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i > 0) {\n            count += count_nums(i);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmp5rmv6ac6.d(20): Error: semicolon expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: expression expected, not `:`\n/tmp/tmp5rmv6ac6.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5rmv6ac6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i : arr)\n    {\n        if(i < 0)\n        {\n            count += Math.abs(i);\n        }\n        else\n        {\n            count += i;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmpri_5j2sx.d(20): Error: semicolon expected, not `:`\n/tmp/tmpri_5j2sx.d(20): Error: expression expected, not `:`\n/tmp/tmpri_5j2sx.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpri_5j2sx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long num : arr) {\n        if (num > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "/tmp/tmp13o_qqpx.d(20): Error: semicolon expected, not `:`\n/tmp/tmp13o_qqpx.d(20): Error: expression expected, not `:`\n/tmp/tmp13o_qqpx.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp13o_qqpx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count += arr[i];\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpldmd429p.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x4282fd]\n??:? void tmpldmd429p.__unittest_L27_C1() [0x427ea1]\n??:? void tmpldmd429p.__modtest() [0x428080]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c37f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b212]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4303a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430854]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430331]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]\n??:? runModuleUnitTests [0x42c155]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4287c0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq29m_uwo.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmpq29m_uwo.__unittest_L29_C1() [0x427fbd]\n??:? void tmpq29m_uwo.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i : arr) {\n        if (i < 0) {\n            count += count_nums(arr);\n        } else if (i > 0) {\n            count += count_nums(arr);\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292754,
      "stdout": "",
      "stderr": "/tmp/tmpci9qs4gq.d(20): Error: semicolon expected, not `:`\n/tmp/tmpci9qs4gq.d(20): Error: expression expected, not `:`\n/tmp/tmpci9qs4gq.d(20): Error: found `arr` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpci9qs4gq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for(long i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpq29m_uwo.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmpq29m_uwo.__unittest_L29_C1() [0x427fbd]\n??:? void tmpq29m_uwo.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0L\n    >>> count_nums([-1L, 11L, -11L])\n    1L\n    >>> count_nums([1L, 1L, 2L])\n    3L\n    \n*/\nlong count_nums(long[] arr) \n{\n    long count = 0;\n    for (long i = 0; i < arr.length; i++) {\n        if (arr[i] > 0) {\n            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = count_nums;\n\n    assert(candidate([]) == 0L);\n    assert(candidate([-1L, -2L, 0L]) == 0L);\n    assert(candidate([1L, 1L, 2L, -2L, 3L, 4L, 5L]) == 6L);\n    assert(candidate([1L, 6L, 9L, -6L, 0L, 1L, 5L]) == 5L);\n    assert(candidate([1L, 100L, 98L, -7L, 1L, -1L]) == 4L);\n    assert(candidate([12L, 23L, 34L, -45L, -56L, 0L]) == 5L);\n    assert(candidate([0L, 1L]) == 1L);\n    assert(candidate([1L]) == 1L);\n}\nvoid main(){}",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_7i2s8ns.d(36): unittest failure\n----------------\n??:? _d_unittestp [0x4282d5]\n??:? void tmp_7i2s8ns.__unittest_L27_C1() [0x427fbd]\n??:? void tmp_7i2s8ns.__modtest() [0x428058]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c357]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b1ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43037d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43082c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430309]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]\n??:? runModuleUnitTests [0x42c12d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428798]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}