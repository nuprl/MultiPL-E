language: go_test.go
name: HumanEval_99_closest_integer
results:
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\
    \ \", err)\n        return 0\n    }\n    if float_value < 0 {\n        result\
    \ = int(float_value - 0.5)\n    } else {\n        result = int(float_value + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmporthz74h_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\
    \ \", err)\n        return 0\n    }\n    if floatValue < 0 {\n        result =\
    \ int(floatValue - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx0qn6iwh_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        panic(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95q3v_1f_test.go:24:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ number float64\n    fmt.Sscanf(value, \"%f\", &number)\n    if number < 0 {\n\
    \        number -= 0.5\n    } else {\n        number += 0.5\n    }\n    return\
    \ int(number)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_next float64\n    var remainder_abs_prev float64\n    var remainder_abs_diff\
    \ float64\n    var remainder_abs_diff_next float64\n    var remainder_abs_diff_prev\
    \ float64\n    var remainder_abs_diff_min float64\n    var remainder_abs_diff_min_next\
    \ float64\n    var remainder_abs_diff_min_prev float64\n    var remainder_abs_diff_min_prev_next\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev float64\n    var remainder_abs_diff_min_prev_next_prev_next\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev float64\n \
    \   var remainder_abs_diff_min_prev_next_prev_next_prev_next float64\n    var\
    \ remainder_abs_diff_min_prev_next_prev_next_prev_next_prev float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev_next_prev_next\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev_next_prev_next_prev\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev_next_prev_next_prev_next\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev_next_prev_next_prev_next_prev\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next\
    \ float64\n    var remainder_abs_diff_min_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuc8ne830_test.go:46:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075114
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number - 0.5)\n    } else {\n     \
    \   result = int(number + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var number float64\n    if number, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(err)\n    \
    \    return 0\n    }\n    if number < 0 {\n        result = int(number - 0.5)\n\
    \    } else {\n        result = int(number + 0.5)\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq1wyy6_a_test.go:25:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    var i int\n    for i = 0; i < len(value);\
    \ i++ {\n        if value[i] == '.' {\n            break\n        }\n    }\n \
    \   if i == len(value) {\n        fmt.Sscanf(value, \"%d\", &result)\n       \
    \ return result\n    }\n    var integer, decimal int\n    fmt.Sscanf(value[:i],\
    \ \"%d\", &integer)\n    fmt.Sscanf(value[i+1:], \"%d\", &decimal)\n    if decimal\
    \ >= 5 {\n        result = integer + 1\n    } else {\n        result = integer\n\
    \    }\n    return result * sign\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp8gcnblpm_test.go:67: expected '%!s(int=-16)', got '%!s(int=14)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        panic(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95q3v_1f_test.go:24:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        floatValue -= 0.5\n    } else {\n        floatValue\
    \ += 0.5\n    }\n    result = int(floatValue)\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3n1_g3rr_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number) - 1\n    } else {\n       \
    \ result = int(number)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1\
    \ (0.00s)\n        tmp_h8dubz2_test.go:50: expected '%!s(int=15)', got '%!s(int=14)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if floatValue < 0 {\n        result = int(floatValue\
    \ - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfbcdapay_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        float_value = float_value * -1\n    }\n   \
    \ if float_value - float64(int(float_value)) < 0.5 {\n        result = int(float_value)\n\
    \    } else {\n        result = int(float_value) + 1\n    }\n    if value[0] ==\
    \ '-' {\n        result = result * -1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpest7nf2p_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    var err error\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        return 0\n    }\n    result = int(f)\n    if f -\
    \ float64(result) >= 0.5 {\n        result += 1\n    }\n    return result\n}\n\
    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn464yzj__test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    result = int(f)\n    if f - float64(result) >= 0.5 {\n        result\
    \ += 1\n    }\n    if value[0] == '-' {\n        result = -result\n    }\n   \
    \ return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate :=\
    \ closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpftw8hi7w_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyoswl2ch_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ number float64\n    fmt.Sscanf(value, \"%f\", &number)\n    return int(number\
    \ + 0.5)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp3lkdxjsu_test.go:44: expected '%!s(int=-16)', got '%!s(int=-15)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ num float64\n    fmt.Sscanf(value, \"%f\", &num)\n    if num < 0 {\n       \
    \ num -= 0.5\n    } else {\n        num += 0.5\n    }\n    return int(num)\n}\n\
    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue > 0 {\n        result = int(floatValue + 0.5)\n    } else {\n\
    \        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number) - 1\n    } else {\n       \
    \ result = int(number)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1\
    \ (0.00s)\n        tmp_h8dubz2_test.go:50: expected '%!s(int=15)', got '%!s(int=14)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\
    \ \", err)\n        return 0\n    }\n    if floatValue < 0 {\n        result =\
    \ int(floatValue - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx0qn6iwh_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    result = int(floatValue)\n    if floatValue - float64(result) >= 0.5 {\n\
    \        result += 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp911h3qem_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var number float64\n    if number, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n    if\
    \ number < 0 {\n        result = int(number) - 1\n    } else {\n        result\
    \ = int(number) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6jf_3ras_test.go:25:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5gc_21im_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075117
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        return 0\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f - float64(int(f)) >= 0.5 {\n        result = int(f) + 1\n   \
    \ } else {\n        result = int(f)\n    }\n    if value[0] == '-' {\n       \
    \ result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo6m6qol8_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplb1g2i1w_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result float64\n    fmt.Sscanf(value, \"%f\", &result)\n    return int(result\
    \ + 0.5)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpmtt2ixwk_test.go:44: expected '%!s(int=-16)', got '%!s(int=-15)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number > 0 {\n        result = int(number + 0.5)\n    } else {\n     \
    \   result = int(number - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: implement me\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpx8r_vsq3_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpx8r_vsq3_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpx8r_vsq3_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpx8r_vsq3_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ num float64\n    var err error\n    if num, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    return int(math.Round(num))\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprz7p_87z_test.go:24:19: undefined: strconv

    /tmp/tmprz7p_87z_test.go:27:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_2 float64\n    var remainder_abs_2_int int\n    var remainder_abs_int\
    \ int\n    var remainder_int int\n    var value_float float64\n    var value_float_int\
    \ int\n\n    fmt.Sscanf(value, \"%f\", &value_float)\n    value_float_int = int(value_float)\n\
    \    remainder = value_float - float64(value_float_int)\n    remainder_abs = remainder\n\
    \    if remainder_abs < 0 {\n        remainder_abs = -remainder_abs\n    }\n \
    \   remainder_abs_int = int(remainder_abs)\n    remainder_abs_2 = remainder_abs\
    \ - float64(remainder_abs_int)\n    remainder_abs_2_int = int(remainder_abs_2)\n\
    \    if remainder_abs_2_int == 0 {\n        remainder_int = remainder_abs_int\n\
    \    } else {\n        remainder_int = remainder_abs_int + 1\n    }\n    if remainder\
    \ < 0 {\n        remainder_int = -remainder_int\n    }\n    result = value_float_int\
    \ + remainder_int\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1\
    \ (0.00s)\n        tmpysn49mnd_test.go:71: expected '%!s(int=15)', got '%!s(int=14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__2 (0.00s)\n        tmpysn49mnd_test.go:71:\
    \ expected '%!s(int=-16)', got '%!s(int=-15)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075118
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    fmt.Sscanf(value, \"%f\", &float_value)\n\
    \    if float_value > 0 {\n        result = int(float_value + 0.5)\n    } else\
    \ {\n        result = int(float_value - 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var sign int\n    var i int\n\n \
    \   if value[0] == '-' {\n        sign = -1\n        i = 1\n    } else {\n   \
    \     sign = 1\n        i = 0\n    }\n\n    for ; i < len(value); i++ {\n    \
    \    if value[i] == '.' {\n            break\n        }\n        result = result\
    \ * 10 + int(value[i] - '0')\n    }\n\n    for ; i < len(value); i++ {\n     \
    \   remainder = remainder * 10 + float64(value[i] - '0')\n    }\n\n    if remainder\
    \ >= 5 {\n        result += 1\n    }\n\n    return result * sign\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__3\
    \ (0.00s)\n        tmpzoexesws_test.go:70: expected '%!s(int=15)', got '%!s(int=16)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        fmt.Println(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpap9ojo_a_test.go:24:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if floatValue < 0 {\n        result = int(floatValue\
    \ - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfbcdapay_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number - 0.5)\n    } else {\n     \
    \   result = int(number + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f - float64(int(f)) < 0.5 {\n        result = int(f)\n    } else\
    \ {\n        result = int(f) + 1\n    }\n    if value[0] == '-' {\n        result\
    \ = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptr22yvlu_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var is_negative bool\n    if value[0] == '-' {\n        is_negative\
    \ = true\n        value = value[1:]\n    }\n    if value[len(value)-1] == '.'\
    \ {\n        value = value[:len(value)-1]\n    }\n    if value[len(value)-1] <\
    \ '5' {\n        result, _ = strconv.Atoi(value)\n    } else {\n        result,\
    \ _ = strconv.Atoi(value)\n        result += 1\n    }\n    if is_negative {\n\
    \        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4e_3uvju_test.go:32:21: undefined: strconv

    /tmp/tmp4e_3uvju_test.go:34:21: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number - 0.5)\n    } else {\n     \
    \   result = int(number + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: Implement me\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075119
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: Implement me\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075119
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var num float64\n    fmt.Sscanf(value, \"%f\", &num)\n    if\
    \ num < 0 {\n        result = int(num - 0.5)\n    } else {\n        result = int(num\
    \ + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075119
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i float64\n    var err error\n    if i, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        return 0\n    }\n    if i < 0 {\n        i = -i\n\
    \    }\n    if i - float64(int(i)) >= 0.5 {\n        result = int(i) + 1\n   \
    \ } else {\n        result = int(i)\n    }\n    if value[0] == '-' {\n       \
    \ result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjbp64lhh_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var decimal float64\n    fmt.Sscanf(value, \"%d.%f\", &result,\
    \ &decimal)\n    if decimal >= 0.5 {\n        result++\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpan134mpc_test.go:48: expected '%!s(int=-16)', got '%!s(int=-14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpan134mpc_test.go:48:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075119
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    f, err = strconv.ParseFloat(value,\
    \ 64)\n    if err != nil {\n        fmt.Println(err)\n    }\n    if f > 0 {\n\
    \        result = int(f + 0.5)\n    } else {\n        result = int(f - 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqb31d_d__test.go:25:14: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        floatValue = -floatValue\n    }\n    if floatValue\
    \ - float64(int(floatValue)) >= 0.5 {\n        result = int(floatValue) + 1\n\
    \    } else {\n        result = int(floatValue)\n    }\n    if value[0] == '-'\
    \ {\n        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm_yajolx_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        floatValue = -floatValue\n    }\n    if floatValue\
    \ - float64(int(floatValue)) >= 0.5 {\n        result = int(floatValue) + 1\n\
    \    } else {\n        result = int(floatValue)\n    }\n    if value[0] == '-'\
    \ {\n        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuc542av7_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    var err error\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        result\
    \ = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9qqhj568_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        return 0\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f - float64(int(f)) >= 0.5 {\n        result = int(f) + 1\n   \
    \ } else {\n        result = int(f)\n    }\n    if value[0] == '-' {\n       \
    \ result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo6m6qol8_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    result = int(floatValue)\n    if floatValue - float64(result) >= 0.5 {\n\
    \        result++\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaji_w5ih_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5gc_21im_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075117
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    var err error\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f - float64(int(f)) >= 0.5 {\n        result = int(f) + 1\n   \
    \ } else {\n        result = int(f)\n    }\n    if value[0] == '-' {\n       \
    \ result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpir0181gx_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075119
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var decimal int\n    var decimal_value float64\n\
    \    var decimal_sign int\n    var decimal_length int\n    var decimal_value_length\
    \ int\n    var decimal_value_length_mod int\n    var decimal_value_length_div\
    \ int\n    var decimal_value_length_div_mod int\n    var decimal_value_length_div_div\
    \ int\n    var decimal_value_length_div_div_mod int\n    var decimal_value_length_div_div_div\
    \ int\n    var decimal_value_length_div_div_div_mod int\n    var decimal_value_length_div_div_div_div\
    \ int\n    var decimal_value_length_div_div_div_div_mod int\n    var decimal_value_length_div_div_div_div_div\
    \ int\n    var decimal_value_length_div_div_div_div_div_mod int\n    var decimal_value_length_div_div_div_div_div_div\
    \ int\n    var decimal_value_length_div_div_div_div_div_div_mod int\n    var decimal_value_length_div_div_div_div_div_div_div\
    \ int\n    var decimal_value_length_div_div_div_div_div_div_div_mod int\n    var\
    \ decimal_value_length_div_div_div_div_div_div_div_div int\n    var decimal_value_length_div_div_div_div_div_div_div_div_mod\
    \ int\n    var decimal_value_length_div_div_div_div_div_div_div_div_div int\n\
    \    var decimal_value_length_div_div_div_div_div_div_div_div_div_mod int\n  \
    \  var decimal_value_length_div_div_div_div_div_div_div_div_div_div int\n    var\
    \ decimal_value_length_div_div_div_div_div_div_div_div_div_div_mod int\n    var\
    \ decimal_value_length_div_div_div_div_div_div_div_div_div_div_div int\n    var\
    \ decimal\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpun7mg6lb_test.go:51:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ number float64\n    fmt.Sscanf(value, \"%f\", &number)\n    if number < 0 {\n\
    \        number -= 0.5\n    } else {\n        number += 0.5\n    }\n    return\
    \ int(number)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue > 0 {\n        result = int(floatValue + 0.5)\n    } else {\n\
    \        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgzp_2no5_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        result\
    \ = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcgi_gzd5_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f - float64(int(f)) >= 0.5 {\n        result = int(f) + 1\n   \
    \ } else {\n        result = int(f)\n    }\n    if value[0] == '-' {\n       \
    \ result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjbz2gavo_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if floatValue < 0 {\n        result = int(floatValue\
    \ - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfbcdapay_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var num float64\n    fmt.Sscanf(value, \"%f\", &num)\n    if\
    \ num < 0 {\n        result = int(num - 0.5)\n    } else {\n        result = int(num\
    \ + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075119
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    fmt.Sscanf(value, \"%f\", &float_value)\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075121
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_next float64\n    var remainder_abs_prev float64\n    var remainder_abs_next_int\
    \ int\n    var remainder_abs_prev_int int\n    var remainder_abs_next_int_float\
    \ float64\n    var remainder_abs_prev_int_float float64\n    var remainder_abs_next_int_float_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs float64\n    var remainder_abs_next_int_float_abs_diff\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff float64\n    var remainder_abs_next_int_float_abs_diff_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs float64\n    var\
    \ remainder_abs_next_int_float_abs_diff_abs_min float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min\
    \ float64\n    var remainder_abs_next_int_float_abs_diff_abs_min_int int\n   \
    \ var remainder_abs_prev_int_float_abs_diff_abs_min_int int\n    var remainder_abs_next_int_float_abs_diff_abs_min_int_float\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs float64\n\
    \    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_abs float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs_diff float64\n\
    \    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_abs_diff float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs_diff_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbcbl0bke_test.go:48:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        return 0\n    }\n    if f < 0 {\n        result =\
    \ int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk8kalou0_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075121
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var number float64\n    if number, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n    result\
    \ = int(number)\n    if number - float64(result) >= 0.5 {\n        result++\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj3scfiqf_test.go:25:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075121
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpxharc5da_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpxharc5da_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpxharc5da_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpxharc5da_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075121
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var decimal int\n    var decimal_value float64\n\
    \    var decimal_sign int\n    var decimal_result int\n    var decimal_result_sign\
    \ int\n    var decimal_result_value float64\n    var decimal_result_value_sign\
    \ int\n    var decimal_result_value_sign_result int\n    var decimal_result_value_sign_result_sign\
    \ int\n    var decimal_result_value_sign_result_sign_result int\n    var decimal_result_value_sign_result_sign_result_sign\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result int\n\
    \    var decimal_result_value_sign_result_sign_result_sign_result_sign int\n \
    \   var decimal_result_value_sign_result_sign_result_sign_result_sign_result int\n\
    \    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign_result\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign_result_sign\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result_sign\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result_sign\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result\
    \ int\n    var decimal_result_value_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result_sign_result\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpro4zte1d_test.go:46:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_next float64\n    var remainder_abs_prev float64\n    var remainder_abs_next_int\
    \ int\n    var remainder_abs_prev_int int\n    var remainder_abs_next_int_float\
    \ float64\n    var remainder_abs_prev_int_float float64\n    var remainder_abs_next_int_float_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs float64\n    var remainder_abs_next_int_float_abs_diff\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff float64\n    var remainder_abs_next_int_float_abs_diff_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs float64\n    var\
    \ remainder_abs_next_int_float_abs_diff_abs_min float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min\
    \ float64\n    var remainder_abs_next_int_float_abs_diff_abs_min_int int\n   \
    \ var remainder_abs_prev_int_float_abs_diff_abs_min_int int\n    var remainder_abs_next_int_float_abs_diff_abs_min_int_float\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs float64\n\
    \    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_abs float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs_diff float64\n\
    \    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_abs_diff float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs_diff_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbcbl0bke_test.go:48:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: Implement me\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075119
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075118
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    fmt.Sscanf(value, \"%f\", &float_value)\n\
    \    if float_value < 0 {\n        float_value = float_value - 0.5\n    } else\
    \ {\n        float_value = float_value + 0.5\n    }\n    result = int(float_value)\n\
    \    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075121
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var num float64\n    var err error\n    if num, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if num < 0 {\n        result\
    \ = int(num - 0.5)\n    } else {\n        result = int(num + 0.5)\n    }\n   \
    \ return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate :=\
    \ closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0pxfdsq4_test.go:25:19: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075121
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    result = int(floatValue)\n    if floatValue - float64(result) >= 0.5 {\n\
    \        result++\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaji_w5ih_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: implement this function\n    return 0\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpow83hf3__test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpow83hf3__test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpow83hf3__test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpow83hf3__test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075121
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\
    \ \", err)\n        return 0\n    }\n    if float_value >= 0 {\n        result\
    \ = int(float_value + 0.5)\n    } else {\n        result = int(float_value - 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgyfullns_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075121
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        panic(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95q3v_1f_test.go:24:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_next float64\n    var remainder_abs_prev float64\n    var remainder_abs_next_int\
    \ int\n    var remainder_abs_prev_int int\n    var remainder_abs_next_float float64\n\
    \    var remainder_abs_prev_float float64\n    var remainder_abs_next_float_int\
    \ int\n    var remainder_abs_prev_float_int int\n    var remainder_abs_next_float_int_abs\
    \ int\n    var remainder_abs_prev_float_int_abs int\n    var remainder_abs_next_float_int_abs_next\
    \ int\n    var remainder_abs_prev_float_int_abs_prev int\n    var remainder_abs_next_float_int_abs_next_float\
    \ float64\n    var remainder_abs_prev_float_int_abs_prev_float float64\n    var\
    \ remainder_abs_next_float_int_abs_next_float_int int\n    var remainder_abs_prev_float_int_abs_prev_float_int\
    \ int\n    var remainder_abs_next_float_int_abs_next_float_int_abs int\n    var\
    \ remainder_abs_prev_float_int_abs_prev_float_int_abs int\n    var remainder_abs_next_float_int_abs_next_float_int_abs_next\
    \ int\n    var remainder_abs_prev_float_int_abs_prev_float_int_abs_prev int\n\
    \    var remainder_abs_next_float_int_abs_next_float_int_abs_next_float float64\n\
    \    var remainder_abs_prev_float_int_abs_prev_float_int_abs_prev_float float64\n\
    \    var remainder_abs_next_float_int_abs_next_float_int_abs_next_float_int int\n\
    \    var remainder_abs_prev_float_int_abs_prev_float_int_abs_prev_float_int int\n\
    \    var remainder_abs_next_float_int_abs_next_float_int_abs_next_float_int_abs\
    \ int\n    var remainder_abs_prev_float_int_abs\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzr9e6b4e_test.go:50:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9p484u8y_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075121
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_prev float64\n    var remainder_abs_next float64\n    var remainder_abs_prev_next\
    \ float64\n    var remainder_abs_prev_next_diff float64\n    var remainder_abs_prev_next_diff_prev\
    \ float64\n    var remainder_abs_prev_next_diff_next float64\n    var remainder_abs_prev_next_diff_prev_next\
    \ float64\n    var remainder_abs_prev_next_diff_prev_next_diff float64\n    var\
    \ remainder_abs_prev_next_diff_prev_next_diff_prev float64\n    var remainder_abs_prev_next_diff_prev_next_diff_next\
    \ float64\n    var remainder_abs_prev_next_diff_prev_next_diff_prev_next float64\n\
    \    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff float64\n\
    \    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff_prev float64\n\
    \    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff_next float64\n\
    \    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff_prev_next\
    \ float64\n    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff_prev_next_diff\
    \ float64\n    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff_prev_next_diff_prev\
    \ float64\n    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff_prev_next_diff_next\
    \ float64\n    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff_prev_next_diff_prev_next\
    \ float64\n    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_diff_prev_next_diff_prev_next_diff\
    \ float64\n    var remainder_abs_prev_next_diff_prev_next_diff_prev_next_\nfunc\
    \ TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm8i8z0nq_test.go:45:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: Implement me\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075119
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var fvalue float64\n    var err error\n    if fvalue, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n    if\
    \ fvalue > 0 {\n        result = int(fvalue + 0.5)\n    } else {\n        result\
    \ = int(fvalue - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptawoaxwg_test.go:25:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075121
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number) - 1\n    } else {\n       \
    \ result = int(number)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__1\
    \ (0.00s)\n        tmp_h8dubz2_test.go:50: expected '%!s(int=15)', got '%!s(int=14)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value > 0 {\n        result = int(float_value + 0.5)\n    } else\
    \ {\n        result = int(float_value - 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9orr9k3h_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075121
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number - 0.5)\n    } else {\n     \
    \   result = int(number + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f >\
    \ 0 {\n        result = int(f + 0.5)\n    } else {\n        result = int(f - 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075122
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result float64\n    fmt.Sscanf(value, \"%f\", &result)\n    if result < 0 {\n\
    \        result -= 0.5\n    } else {\n        result += 0.5\n    }\n    return\
    \ int(result)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: implement\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmp5pwczipc_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmp5pwczipc_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp5pwczipc_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp5pwczipc_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075122
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        panic(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95q3v_1f_test.go:24:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue > 0 {\n        result = int(floatValue + 0.5)\n    } else {\n\
    \        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgzp_2no5_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5gc_21im_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075117
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var negative bool\n    if value[0] == '-' {\n        negative\
    \ = true\n        value = value[1:]\n    }\n    if value[len(value)-1] == '.'\
    \ {\n        value = value[:len(value)-1]\n    }\n    if value[len(value)-1] >=\
    \ '5' {\n        result = 1\n    }\n    for i := len(value) - 1; i >= 0; i-- {\n\
    \        if value[i] == '.' {\n            continue\n        }\n        result\
    \ += int(value[i] - '0') * int(pow(10, len(value)-1-i))\n    }\n    if negative\
    \ {\n        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw8fqq9d3_test.go:38:45: undefined: pow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    result = int(floatValue)\n    if floatValue - float64(result) >= 0.5 {\n\
    \        result += 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfakvas_k_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result float64\n    fmt.Sscanf(value, \"%f\", &result)\n    if result < 0 {\n\
    \        result -= 0.5\n    } else {\n        result += 0.5\n    }\n    return\
    \ int(result)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    if len(value) == 0 {\n        return result\n    }\n    var\
    \ is_negative bool\n    if value[0] == '-' {\n        is_negative = true\n   \
    \     value = value[1:]\n    }\n    var integer_part, decimal_part string\n  \
    \  for i := 0; i < len(value); i++ {\n        if value[i] == '.' {\n         \
    \   integer_part = value[:i]\n            decimal_part = value[i+1:]\n       \
    \     break\n        }\n    }\n    if len(decimal_part) == 0 {\n        fmt.Sscanf(value,\
    \ \"%d\", &result)\n        return result\n    }\n    var decimal_part_int int\n\
    \    fmt.Sscanf(decimal_part, \"%d\", &decimal_part_int)\n    if decimal_part_int\
    \ < 5 {\n        fmt.Sscanf(integer_part, \"%d\", &result)\n        return result\n\
    \    }\n    var integer_part_int int\n    fmt.Sscanf(integer_part, \"%d\", &integer_part_int)\n\
    \    result = integer_part_int + 1\n    if is_negative {\n        result = -result\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075122
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyoswl2ch_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if float_value < 0 {\n        result = int(float_value\
    \ - 0.5)\n    } else {\n        result = int(float_value + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkqenutk_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_int int\n    var remainder_abs_int_next int\n    var remainder_abs_int_prev\
    \ int\n    var remainder_abs_int_next_abs float64\n    var remainder_abs_int_prev_abs\
    \ float64\n    var remainder_abs_int_next_abs_int int\n    var remainder_abs_int_prev_abs_int\
    \ int\n    var remainder_abs_int_next_abs_int_next int\n    var remainder_abs_int_prev_abs_int_prev\
    \ int\n    var remainder_abs_int_next_abs_int_next_abs float64\n    var remainder_abs_int_prev_abs_int_prev_abs\
    \ float64\n    var remainder_abs_int_next_abs_int_next_abs_int int\n    var remainder_abs_int_prev_abs_int_prev_abs_int\
    \ int\n    var remainder_abs_int_next_abs_int_next_abs_int_next int\n    var remainder_abs_int_prev_abs_int_prev_abs_int_prev\
    \ int\n    var remainder_abs_int_next_abs_int_next_abs_int_next_abs float64\n\
    \    var remainder_abs_int_prev_abs_int_prev_abs_int_prev_abs float64\n    var\
    \ remainder_abs_int_next_abs_int_next_abs_int_next_abs_int int\n    var remainder_abs_int_prev_abs_int_prev_abs_int_prev_abs_int\
    \ int\n    var remainder_abs_int_next_abs_int_next_abs_int_next_abs_int_next int\n\
    \    var remainder_abs_int_prev_abs_int_prev_abs_int_prev_abs_int_prev int\n \
    \   var remainder_abs_int_next_abs_int_next_abs_int_next_abs_int_next_abs float64\n\
    \    var remainder_abs_int_prev_abs_int_prev_abs_int_prev_abs_int_prev_abs float64\n\
    \    var remainder_abs_int_next_abs_int\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp760wnuo4_test.go:48:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        fmt.Println(err)\n        return 0\n    }\n    if\
    \ f < 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f\
    \ + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphd0_notv_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue > 0 {\n        result = int(floatValue + 0.5)\n    } else {\n\
    \        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number >= 0 {\n        result = int(number + 0.5)\n    } else {\n    \
    \    result = int(number - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        result\
    \ = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcgi_gzd5_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5gc_21im_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075117
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f - float64(int(f)) >= 0.5 {\n        result = int(f) + 1\n   \
    \ } else {\n        result = int(f)\n    }\n    if value[0] == '-' {\n       \
    \ result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjbz2gavo_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplb1g2i1w_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075118
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyoswl2ch_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if float_value < 0 {\n        float_value\
    \ = float_value * -1\n    }\n    if float_value - float64(int(float_value)) <\
    \ 0.5 {\n        result = int(float_value)\n    } else {\n        result = int(float_value)\
    \ + 1\n    }\n    if value[0] == '-' {\n        result = result * -1\n    }\n\
    \    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn97bcvo4_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var fvalue float64\n    var err error\n    if fvalue, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if fvalue < 0 {\n        result = int(fvalue\
    \ - 0.5)\n    } else {\n        result = int(fvalue + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ol21127_test.go:25:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1yzx6cmk_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if float_value < 0 {\n        result = int(float_value\
    \ - 0.5)\n    } else {\n        result = int(float_value + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkqenutk_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(\"Error:\"\
    , err)\n        return 0\n    }\n    if floatValue < 0 {\n        result = int(floatValue\
    \ - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfbcdapay_test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        result\
    \ = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcgi_gzd5_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075120
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    result = int(floatValue)\n    if floatValue - float64(result) >= 0.5 {\n\
    \        result++\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpye67dyj__test.go:25:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5gc_21im_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075117
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var float_value float64\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvrr2ki8a_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        panic(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95q3v_1f_test.go:24:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: Implement me\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075119
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        panic(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp95q3v_1f_test.go:24:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5gc_21im_test.go:25:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075117
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n\n    fmt.Sscanf(value, \"%d.%f\", &result,\
    \ &remainder)\n\n    if remainder >= 0.5 {\n        result++\n    }\n\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmplkca61eq_test.go:51: expected '%!s(int=-16)', got '%!s(int=-14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmplkca61eq_test.go:51:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075122
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number > 0 {\n        result = int(number + 0.5)\n    } else {\n     \
    \   result = int(number - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075118
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_half float64\n    var remainder_abs_half_int int\n    var remainder_abs_half_int_abs\
    \ int\n    var remainder_abs_half_int_abs_half int\n    var remainder_abs_half_int_abs_half_int\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs int\n    var remainder_abs_half_int_abs_half_int_abs_half\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs_half_int int\n    var remainder_abs_half_int_abs_half_int_abs_half_int_abs\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half int\n\
    \    var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half_int int\n \
    \   var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs int\n\
    \    var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half_int\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half_int\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs_half_int_abs\
    \ int\n    var remainder_abs_half_int_abs_half_int_abs_half_int_abs\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprakicog3_test.go:43:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075122
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpg8ns3qdk_test.go:42: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpg8ns3qdk_test.go:42:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: Implement me\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmph32wu4ju_test.go:43: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmph32wu4ju_test.go:43:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075119
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075116
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"\
    10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        f = -f\n    }\n    if f - float64(int(f)) >= 0.5 {\n        result\
    \ = int(f) + 1\n    } else {\n        result = int(f)\n    }\n    if value[0]\
    \ == '-' {\n        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660075122
