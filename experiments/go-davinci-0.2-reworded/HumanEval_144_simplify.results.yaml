language: go_test.go
name: HumanEval_144_simplify
results:
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    x_numerator *= n_denominator\n    x_denominator *= n_numerator\n    return\
    \ x_numerator % x_denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd_n18zxb_test.go:20:35: undefined: parseFraction

    /tmp/tmpd_n18zxb_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator %\
    \ xn.denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprs2cizv3_test.go:20:11: undefined: parse

    /tmp/tmprs2cizv3_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_num,\
    \ x_den := parse(x)\n    n_num, n_den := parse(n)\n    return (x_num * n_den)\
    \ % (x_den * n_num) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbvsca3ix_test.go:20:21: undefined: parse

    /tmp/tmpbvsca3ix_test.go:21:21: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator, xDenominator * nNumerator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2tn4j32_test.go:20:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:21:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return xn * nd == xd * nn\n}\n\n\
    func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqjh3fa5w_test.go:20:15: undefined: parse

    /tmp/tmpqjh3fa5w_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_n,\
    \ x_d := parse(x)\n    n_n, n_d := parse(n)\n    return (x_n * n_d) % (x_d * n_n)\
    \ == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4hlcmxg9_test.go:20:17: undefined: parse

    /tmp/tmp4hlcmxg9_test.go:21:17: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2bvomun7_test.go:20:19: undefined: parseFraction

    /tmp/tmp2bvomun7_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return xn * nd == xd * nn\n}\n\n\
    func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqjh3fa5w_test.go:20:15: undefined: parse

    /tmp/tmpqjh3fa5w_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator, xDenominator * nNumerator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2tn4j32_test.go:20:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:21:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Write your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code goes here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpoodotxw0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpoodotxw0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpoodotxw0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpoodotxw0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpoodotxw0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpoodotxw0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpoodotxw0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpoodotxw0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb7n_ii5k_test.go:20:19: undefined: parse

    /tmp/tmpb7n_ii5k_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return xn * nd == xd * nn\n}\n\n\
    func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqjh3fa5w_test.go:20:15: undefined: parse

    /tmp/tmpqjh3fa5w_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNumerator, xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xNumerator, &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator,\
    \ &nDenominator)\n    return xNumerator * nDenominator % xDenominator == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi71ltcp7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmpi71ltcp7_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmpi71ltcp7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmpi71ltcp7_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2bvomun7_test.go:20:19: undefined: parseFraction

    /tmp/tmp2bvomun7_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhforjvv_test.go:20:35: undefined: parseFraction

    /tmp/tmpjhforjvv_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Write your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhforjvv_test.go:20:35: undefined: parseFraction

    /tmp/tmpjhforjvv_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator ==\
    \ xn.denominator * nn.numerator\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyzjavuk3_test.go:20:11: undefined: parse

    /tmp/tmpyzjavuk3_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    xNumerator\
    \ *= nDenominator\n    nNumerator *= xDenominator\n    return xNumerator % nNumerator\
    \ == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_mjeseqt_test.go:20:33: undefined: parse

    /tmp/tmp_mjeseqt_test.go:21:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ true\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp4viognms_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp4viognms_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    return\
    \ (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_4pwld6z_test.go:20:35: undefined: parse

    /tmp/tmp_4pwld6z_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ true\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp4viognms_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp4viognms_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNumerator, xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xNumerator, &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator,\
    \ &nDenominator)\n    return (xNumerator * nDenominator) % (xDenominator * nNumerator)\
    \ == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmprb40b8uo_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmprb40b8uo_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmprb40b8uo_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmprb40b8uo_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhforjvv_test.go:20:35: undefined: parseFraction

    /tmp/tmpjhforjvv_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    x_numerator\
    \ *= n_denominator\n    x_denominator *= n_numerator\n    return x_numerator %\
    \ x_denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdv33lxmf_test.go:20:35: undefined: parse

    /tmp/tmpdv33lxmf_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpgywquq1a_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpgywquq1a_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpgywquq1a_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpgywquq1a_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpgywquq1a_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpgywquq1a_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpgywquq1a_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpgywquq1a_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ true\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp4viognms_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp4viognms_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator, xDenominator * nNumerator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2tn4j32_test.go:20:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:21:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := getNumeratorAndDenominator(x)\n    nNumerator, nDenominator\
    \ := getNumeratorAndDenominator(n)\n    return (xNumerator * nDenominator) % (xDenominator\
    \ * nNumerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7p8te9k9_test.go:20:33: undefined: getNumeratorAndDenominator

    /tmp/tmp7p8te9k9_test.go:21:33: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return xNum * nDen * nNum\
    \ == xDen * nNum * nDen\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpanjj_kiw_test.go:20:19: undefined: parse

    /tmp/tmpanjj_kiw_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator, xDenominator * nNumerator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2tn4j32_test.go:20:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:21:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    return\
    \ (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_4pwld6z_test.go:20:35: undefined: parse

    /tmp/tmp_4pwld6z_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.simplify(nn)\n}\n\ntype fraction\
    \ \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_ufracje_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073157
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Write your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhforjvv_test.go:20:35: undefined: parseFraction

    /tmp/tmpjhforjvv_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return xNum * nDen * nNum\
    \ * xDen % (xDen * nDen) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpazy6cvsl_test.go:20:19: undefined: parse

    /tmp/tmpazy6cvsl_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parseFraction(x)\n    nn := parseFraction(n)\n    return xn * nn == 1\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp67whe8cn_test.go:20:11: undefined: parseFraction

    /tmp/tmp67whe8cn_test.go:21:11: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parseFraction(x)\n    nn := parseFraction(n)\n    return xn * nn % 1 == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphb6t9m03_test.go:20:11: undefined: parseFraction

    /tmp/tmphb6t9m03_test.go:21:11: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3qnqqpu1_test.go:20:15: undefined: parse

    /tmp/tmp3qnqqpu1_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073157
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhforjvv_test.go:20:35: undefined: parseFraction

    /tmp/tmpjhforjvv_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return isWholeNumber(x_numerator * n_numerator, x_denominator * n_denominator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7z3hi2z4_test.go:20:35: undefined: parseFraction

    /tmp/tmp7z3hi2z4_test.go:21:35: undefined: parseFraction

    /tmp/tmp7z3hi2z4_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code goes here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpoodotxw0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpoodotxw0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpoodotxw0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpoodotxw0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpoodotxw0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpoodotxw0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpoodotxw0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpoodotxw0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    fmt.Println(x_numerator,\
    \ x_denominator, n_numerator, n_denominator)\n    return false\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmlxsl45p_test.go:20:35: undefined: parse

    /tmp/tmpmlxsl45p_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parseFraction(x)\n    nn := parseFraction(n)\n    return xn * nn % 1 == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphb6t9m03_test.go:20:11: undefined: parseFraction

    /tmp/tmphb6t9m03_test.go:21:11: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2bvomun7_test.go:20:19: undefined: parseFraction

    /tmp/tmp2bvomun7_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    // fmt.Printf(\"xNumerator: %d, xDenominator: %d\\n\", xNumerator, xDenominator)\n\
    \    // fmt.Printf(\"nNumerator: %d, nDenominator: %d\\n\", nNumerator, nDenominator)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo78t20yo_test.go:20:33: undefined: parseFraction

    /tmp/tmpo78t20yo_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator, xDenominator * nNumerator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2tn4j32_test.go:20:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:21:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator %\
    \ xn.denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprs2cizv3_test.go:20:11: undefined: parse

    /tmp/tmprs2cizv3_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xnumerator, xdenominator, nnumerator, ndenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xnumerator, &xdenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nnumerator,\
    \ &ndenominator)\n    return xnumerator * ndenominator % xdenominator == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp9q0xpugq_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmp9q0xpugq_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmp9q0xpugq_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmp9q0xpugq_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator, xDenominator * nNumerator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2tn4j32_test.go:20:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:21:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmptv4zb_dl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmptv4zb_dl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmptv4zb_dl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmptv4zb_dl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmptv4zb_dl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmptv4zb_dl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmptv4zb_dl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmptv4zb_dl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := getNumeratorAndDenominator(x)\n    n_numerator, n_denominator\
    \ := getNumeratorAndDenominator(n)\n    return x_numerator * n_denominator * n_numerator\
    \ * x_denominator % (x_denominator * n_denominator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt5wh66g6_test.go:20:35: undefined: getNumeratorAndDenominator

    /tmp/tmpt5wh66g6_test.go:21:35: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator %\
    \ xn.denominator == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnr55x847_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073157
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parse(x)\n    nNum, nDen := parse(n)\n    return (xNum * nDen) % (xDen\
    \ * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb7n_ii5k_test.go:20:19: undefined: parse

    /tmp/tmpb7n_ii5k_test.go:21:19: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNumerator, xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xNumerator, &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator,\
    \ &nDenominator)\n    return xNumerator * nDenominator % xDenominator == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi71ltcp7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmpi71ltcp7_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmpi71ltcp7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmpi71ltcp7_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu53dkiuo_test.go:20:33: undefined: parse

    /tmp/tmpu53dkiuo_test.go:21:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement this function\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8sr2wwe9_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8sr2wwe9_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8sr2wwe9_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8sr2wwe9_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8sr2wwe9_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8sr2wwe9_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8sr2wwe9_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8sr2wwe9_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := getNumeratorAndDenominator(x)\n    nNumerator, nDenominator\
    \ := getNumeratorAndDenominator(n)\n    return xNumerator * nDenominator % (xDenominator\
    \ * nNumerator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt_i9zpff_test.go:20:33: undefined: getNumeratorAndDenominator

    /tmp/tmpt_i9zpff_test.go:21:33: undefined: getNumeratorAndDenominator

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNumerator, xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xNumerator, &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator,\
    \ &nDenominator)\n    return xNumerator * nDenominator % xDenominator == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi71ltcp7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmpi71ltcp7_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmpi71ltcp7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmpi71ltcp7_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parseFraction(x)\n    nn := parseFraction(n)\n    return xn * nn % 1 == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphb6t9m03_test.go:20:11: undefined: parseFraction

    /tmp/tmphb6t9m03_test.go:21:11: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNumerator, xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xNumerator, &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator,\
    \ &nDenominator)\n    return xNumerator * nDenominator % xDenominator == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpi71ltcp7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__6 (0.00s)\n        tmpi71ltcp7_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__11\
    \ (0.00s)\n        tmpi71ltcp7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__12 (0.00s)\n        tmpi71ltcp7_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ false\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpj4jx5fhi_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpj4jx5fhi_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator, xDenominator * nNumerator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2tn4j32_test.go:20:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:21:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhforjvv_test.go:20:35: undefined: parseFraction

    /tmp/tmpjhforjvv_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return (xn * nd) % (xd * nn) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpkgvebdmr_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpkgvebdmr_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return x_numerator * n_denominator * n_numerator * x_denominator % (x_denominator\
    \ * n_denominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplh6yftzo_test.go:20:35: undefined: parseFraction

    /tmp/tmplh6yftzo_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    return\
    \ true\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__1\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__3 (0.00s)\n        tmp4viognms_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__7\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestSimplify/test_num__8 (0.00s)\n        tmp4viognms_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp4viognms_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNum,\
    \ xDen := parseFraction(x)\n    nNum, nDen := parseFraction(n)\n    return (xNum\
    \ * nDen) % (xDen * nNum) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2bvomun7_test.go:20:19: undefined: parseFraction

    /tmp/tmp2bvomun7_test.go:21:19: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator, xDenominator * nNumerator)\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2tn4j32_test.go:20:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:21:33: undefined: parseFraction

    /tmp/tmpu2tn4j32_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhforjvv_test.go:20:35: undefined: parseFraction

    /tmp/tmpjhforjvv_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator %\
    \ xn.denominator == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnr55x847_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073157
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Write your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpvm9wjvct_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpvm9wjvct_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ Your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpx905t4dp_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpx905t4dp_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement me\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpriuz9p9w_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpriuz9p9w_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp4_5l4yxg_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp4_5l4yxg_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmnxnxxa7_test.go:20:11: undefined: parse

    /tmp/tmpmnxnxxa7_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator %\
    \ xn.denominator == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnr55x847_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073157
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n   \
    \ fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmpftc8d448_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmpftc8d448_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    fmt.Println(x_numerator, x_denominator, n_numerator, n_denominator)\n   \
    \ return x_numerator * n_denominator == x_denominator * n_numerator\n}\n\nfunc\
    \ TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb2by_k45_test.go:20:35: undefined: parseFraction

    /tmp/tmpb2by_k45_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn,\
    \ xd := parse(x)\n    nn, nd := parse(n)\n    return (xn * nd) % (xd * nn) ==\
    \ 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3qnqqpu1_test.go:20:15: undefined: parse

    /tmp/tmp3qnqqpu1_test.go:21:15: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073157
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xNumerator, xDenominator, nNumerator, nDenominator int\n    fmt.Sscanf(x, \"\
    %d/%d\", &xNumerator, &xDenominator)\n    fmt.Sscanf(n, \"%d/%d\", &nNumerator,\
    \ &nDenominator)\n    return (xNumerator * nDenominator) % (xDenominator * nNumerator)\
    \ == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n\
    \     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmprb40b8uo_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmprb40b8uo_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmprb40b8uo_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmprb40b8uo_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmprb40b8uo_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator %\
    \ xn.denominator == 0\n}\n\ntype fraction \nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnr55x847_test.go:25:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073157
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parse(x)\n    nNumerator, nDenominator := parse(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu53dkiuo_test.go:20:33: undefined: parse

    /tmp/tmpu53dkiuo_test.go:21:33: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: implement this function\n    return false\n}\n\nfunc TestSimplify(t *testing.T)\
    \ {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp8sr2wwe9_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp8sr2wwe9_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp8sr2wwe9_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp8sr2wwe9_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp8sr2wwe9_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp8sr2wwe9_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp8sr2wwe9_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp8sr2wwe9_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n\
    \nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9axjmu0u_test.go:20:33: undefined: parseFraction

    /tmp/tmp9axjmu0u_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ your code here\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n \
    \ candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp5e30_dw5_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp5e30_dw5_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073156
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    //\
    \ TODO: Implement\n    return false\n}\n\nfunc TestSimplify(t *testing.T) {\n\
    \  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1/5\"\
    , \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected:\
    \ false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n  \
    \   { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     { actual:\
    \ candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmptv4zb_dl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmptv4zb_dl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmptv4zb_dl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmptv4zb_dl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmptv4zb_dl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmptv4zb_dl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmptv4zb_dl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmptv4zb_dl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator ==\
    \ xn.denominator * nn.numerator\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate\
    \ := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyzjavuk3_test.go:20:11: undefined: parse

    /tmp/tmpyzjavuk3_test.go:21:11: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xn\
    \ := parseFraction(x)\n    nn := parseFraction(n)\n    return xn * nn % 1 == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphb6t9m03_test.go:20:11: undefined: parseFraction

    /tmp/tmphb6t9m03_test.go:21:11: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parse(x)\n    n_numerator, n_denominator := parse(n)\n    x_numerator\
    \ *= n_denominator\n    x_denominator *= n_numerator\n    return x_numerator %\
    \ x_denominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdv33lxmf_test.go:20:35: undefined: parse

    /tmp/tmpdv33lxmf_test.go:21:35: undefined: parse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return isWholeNumber(xNumerator * nDenominator * nNumerator, xDenominator\
    \ * nDenominator)\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true\
    \ },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual:\
    \ candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyn8iku1i_test.go:20:33: undefined: parseFraction

    /tmp/tmpyn8iku1i_test.go:21:33: undefined: parseFraction

    /tmp/tmpyn8iku1i_test.go:22:12: undefined: isWholeNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    x_numerator,\
    \ x_denominator := parseFraction(x)\n    n_numerator, n_denominator := parseFraction(n)\n\
    \    return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0\n\
    }\n\nfunc TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"\
    5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"\
    ), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"), expected:\
    \ true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true },\n   \
    \  { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual: candidate(\"\
    2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"5/2\", \"3/5\"\
    ), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"), expected: true\
    \ },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
    1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhforjvv_test.go:20:35: undefined: parseFraction

    /tmp/tmpjhforjvv_test.go:21:35: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
- exit_code: 1
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    var\
    \ xn, xd, nn, nd int\n    fmt.Sscanf(x, \"%d/%d\", &xn, &xd)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nn, &nd)\n    return xn * nd == xd * nn\n}\n\nfunc TestSimplify(t\
    \ *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"1/6\", \"2/1\"\
    ), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"), expected: true\
    \ },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false },\n     {\
    \ actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual: candidate(\"\
    7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\", \"6/1\"\
    ), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected: false\
    \ },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n     { actual:\
    \ candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
    2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"\
    ), expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSimplify (0.00s)\n    --- FAIL: TestSimplify/test_num__0\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__2 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__4\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__5 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__6\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__9 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__10\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestSimplify/test_num__11 (0.00s)\n        tmp1fe2drcx_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestSimplify/test_num__12\
    \ (0.00s)\n        tmp1fe2drcx_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073158
- exit_code: 2
  program: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Your task is to implement a function that will simplify the expression\n//\
    \ x * n. The function returns true if x * n evaluates to a whole number and false\n\
    // otherwise. Both x and n, are string representation of a fraction, and have\
    \ the following format,\n// <numerator>/<denominator> where both numerator and\
    \ denominator are positive whole numbers.\n// You can assume that x, and n are\
    \ valid fractions, and do not have zero as denominator.\n// >>> simplify(\"1/5\"\
    , \"5/1\")\n// true\n// >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"\
    7/10\", \"10/2\")\n// false\nfunc simplify(x string, n string) bool {\n    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return xNumerator * nDenominator * nNumerator * xDenominator % (xDenominator\
    \ * nDenominator) == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n  candidate :=\
    \ simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"1/5\", \"5/1\"), expected:\
    \ true },\n     { actual: candidate(\"1/6\", \"2/1\"), expected: false },\n  \
    \   { actual: candidate(\"5/1\", \"3/1\"), expected: true },\n     { actual: candidate(\"\
    7/10\", \"10/2\"), expected: false },\n     { actual: candidate(\"2/10\", \"50/10\"\
    ), expected: true },\n     { actual: candidate(\"7/2\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"11/6\", \"6/1\"), expected: true },\n     { actual:\
    \ candidate(\"2/3\", \"5/2\"), expected: false },\n     { actual: candidate(\"\
    5/2\", \"3/5\"), expected: false },\n     { actual: candidate(\"2/4\", \"8/4\"\
    ), expected: true },\n     { actual: candidate(\"2/4\", \"4/2\"), expected: true\
    \ },\n     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual:\
    \ candidate(\"1/5\", \"1/5\"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidoy66bm_test.go:20:33: undefined: parseFraction

    /tmp/tmpidoy66bm_test.go:21:33: undefined: parseFraction

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073155
