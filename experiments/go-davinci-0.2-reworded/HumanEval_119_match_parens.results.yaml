language: go_test.go
name: HumanEval_119_match_parens
results:
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_rec(s)\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_r58w7u_test.go:26:12: undefined: match_parens_rec

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_rec(s)\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_r58w7u_test.go:26:12: undefined: match_parens_rec

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        lst_len = len(lst)\n\
    \        i       int\n        j       int\n        k       int\n        l    \
    \   int\n        m       int\n        n       int\n        s       string\n  \
    \      t       string\n        u       string\n        v       string\n      \
    \  w       string\n        x       string\n        y       string\n        z \
    \      string\n    )\n    if lst_len < 2 {\n        return \"No\"\n    }\n   \
    \ for i = 0; i < lst_len; i++ {\n        s = lst[i]\n        for j = 0; j < lst_len;\
    \ j++ {\n            if i == j {\n                continue\n            }\n  \
    \          t = lst[j]\n            for k = 0; k < lst_len; k++ {\n           \
    \     if k == i || k == j {\n                    continue\n                }\n\
    \                u = lst[k]\n                for l = 0; l < lst_len; l++ {\n \
    \                   if l == i || l == j || l == k {\n                        continue\n\
    \                    }\n                    v = lst[l]\n                    for\
    \ m = 0; m < lst_len; m++ {\n                        if m == i || m == j || m\
    \ == k || m == l {\n                            continue\n                   \
    \     }\n                        w = lst[m]\n                        for n = 0;\
    \ n < lst_len; n++ {\n                            if n == i || n == j || n ==\
    \ k || n == l || n == m {\n                                continue\n        \
    \                    }\n                            x = lst[n]\n             \
    \               y = s + t + u + v + w + x\n                            z = is_good(y)\n\
    \                            if z == \"Yes\" {\n                             \
    \   return z\n                            }\n                        }\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmrys1ah_test.go:70:33: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []rune\n    for _, r :=\
    \ range s {\n        if r == '(' {\n            stack = append(stack, r)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpn_540ory_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpn_540ory_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpn_540ory_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var count int\n    for _,\
    \ s := range lst {\n        for _, c := range s {\n            if c == '(' {\n\
    \                count++\n            } else {\n                count--\n    \
    \        }\n            if count < 0 {\n                return \"No\"\n      \
    \      }\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpzxjqx02z_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpzxjqx02z_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpzxjqx02z_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        res string\n    )\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                open++\n        \
    \    } else {\n                close++\n            }\n        }\n    }\n    if\
    \ open == close {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n\
    \    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpyqrongtc_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ check_parens(s1)\n    }\n    if check_parens(s1 + s2) == \"Yes\" {\n       \
    \ return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"Yes\" {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hwqbcfv_test.go:27:16: undefined: check_parens

    /tmp/tmp2hwqbcfv_test.go:30:16: undefined: check_parens

    /tmp/tmp2hwqbcfv_test.go:32:8: undefined: check_parens

    /tmp/tmp2hwqbcfv_test.go:35:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open int\n\
    \        close int\n    )\n    for _, s := range lst {\n        for _, c := range\
    \ s {\n            if c == '(' {\n                open++\n            } else {\n\
    \                close++\n            }\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp42tvh7tp_test.go:65: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return \"Yes\"\n    }\n    if len(s2) == 0 {\n        return \"Yes\"\n\
    \    }\n    if s1[0] == '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmped2y_lzm_test.go:71: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmped2y_lzm_test.go:71: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmped2y_lzm_test.go:71: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmped2y_lzm_test.go:71: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmped2y_lzm_test.go:71: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmped2y_lzm_test.go:71: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        c1, c2 rune\n        ok bool\n    )\n    s1, s2 = lst[0],\
    \ lst[1]\n    for i, j = 0, 0; i < len(s1) && j < len(s2); {\n        c1, c2 =\
    \ rune(s1[i]), rune(s2[j])\n        if c1 == '(' {\n            if c2 == ')' {\n\
    \                i, j = i + 1, j + 1\n            } else {\n                i++\n\
    \            }\n        } else {\n            if c2 == '(' {\n               \
    \ i, j = i + 1, j + 1\n            } else {\n                j++\n           \
    \ }\n        }\n    }\n    if i < len(s1) {\n        s1 = s1[i:]\n    }\n    if\
    \ j < len(s2) {\n        s2 = s2[j:]\n    }\n    if len(s1) == 0 && len(s2) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n        s1 = s2\n\
    \    }\n    for i = 0; i < len(s1); i++ {\n        if s1[i] == '(' {\n       \
    \     break\n        }\n    }\n    if i == len(s1) {\n        return \"No\"\n\
    \    }\n    s1 = s1[i:]\n    for i = len(s1) - 1; i >= 0; i-- {\n        if s1[i]\
    \ == ')' {\n            break\n        }\n    }\n    if i == -1 {\n        return\
    \ \"No\"\n    }\n    s1 = s1[:i+1]\n    for i = 0; i < len(s1); i++ {\n      \
    \  if s1[i] == '(' {\n            break\n        }\n    }\n    if i == len(s1)\
    \ {\n        return \"No\"\n    }\n    s1 = s1[i:]\n    for i = len(s1) - 1; i\
    \ >= 0; i-- {\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn60jsemg_test.go:85:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073603
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens_helper(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens_helper(s1)\n    }\n    return match_parens_helper(s1 + s2)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7exh0uz5_test.go:30:16: undefined: match_parens_helper

    /tmp/tmp7exh0uz5_test.go:33:16: undefined: match_parens_helper

    /tmp/tmp7exh0uz5_test.go:35:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens_helper(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens_helper(s1)\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt8pr0umy_test.go:30:16: undefined: match_parens_helper

    /tmp/tmpt8pr0umy_test.go:33:16: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if len(s) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if s[0] == ')' {\n        return \"No\"\n    }\n    if s[len(s)-1]\
    \ == '(' {\n        return \"No\"\n    }\n    var stack []byte\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, byte(c))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp4pdnm0rd_test.go:76: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp4pdnm0rd_test.go:76: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp4pdnm0rd_test.go:76: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s2\
    \ := range lst {\n        s += s2\n    }\n    var stack []rune\n    for _, r :=\
    \ range s {\n        if r == '(' {\n            stack = append(stack, r)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpys2l4y_w_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpys2l4y_w_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpys2l4y_w_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens_helper(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens_helper(s1)\n    }\n    if match_parens_helper(s1) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if match_parens_helper(s2) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaeig6whr_test.go:30:16: undefined: match_parens_helper

    /tmp/tmpaeig6whr_test.go:33:16: undefined: match_parens_helper

    /tmp/tmpaeig6whr_test.go:35:8: undefined: match_parens_helper

    /tmp/tmpaeig6whr_test.go:38:8: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ check_parens(s1)\n    }\n    if check_parens(s1) == \"Yes\" && check_parens(s2)\
    \ == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1 + s2) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"\
    Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfts5y72f_test.go:27:16: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:30:16: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:32:8: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:35:8: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:38:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        open, close int\n    )\n    s1, s2 = lst[0], lst[1]\n\
    \    for i = 0; i < len(s1); i++ {\n        if s1[i] == '(' {\n            open++\n\
    \        } else {\n            close++\n        }\n    }\n    for j = 0; j < len(s2);\
    \ j++ {\n        if s2[j] == '(' {\n            open++\n        } else {\n   \
    \         close++\n        }\n    }\n    if open == close {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpg8i9tcmj_test.go:72: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    s = lst[0]\
    \ + lst[1]\n    var stack []byte\n    for i := 0; i < len(s); i++ {\n        if\
    \ s[i] == '(' {\n            stack = append(stack, s[i])\n        } else {\n \
    \           if len(stack) == 0 {\n                return \"No\"\n            }\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp74a_jptb_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp74a_jptb_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp74a_jptb_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if len(s) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if s[0] == ')' {\n        return \"No\"\n    }\n    if s[len(s)-1]\
    \ == '(' {\n        return \"No\"\n    }\n    var stack []byte\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, byte(c))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp4pdnm0rd_test.go:76: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp4pdnm0rd_test.go:76: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp4pdnm0rd_test.go:76: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: Implement me!\n \
    \   return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpb8abe3vz_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpb8abe3vz_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpb8abe3vz_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpb8abe3vz_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpb8abe3vz_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpb8abe3vz_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpb8abe3vz_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpb8abe3vz_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpb8abe3vz_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpb8abe3vz_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpb8abe3vz_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpb8abe3vz_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []byte\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, byte(c))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpn9ahv5nj_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpn9ahv5nj_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpn9ahv5nj_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: implement this function\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpzuffm__y_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpzuffm__y_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpzuffm__y_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpzuffm__y_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpzuffm__y_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpzuffm__y_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpzuffm__y_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpzuffm__y_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpzuffm__y_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpzuffm__y_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpzuffm__y_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpzuffm__y_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        return match_parens([]string{s1[1:], s2})\n  \
    \  }\n    if s2[0] == '(' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    if s1[0] == ')' {\n        return match_parens([]string{s1[1:], s2})\n\
    \    }\n    if s2[0] == ')' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" && check_parens(s2) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if check_parens(s1 + s2) == \"Yes\" {\n  \
    \      return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"Yes\" {\n    \
    \    return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_0f8kyam_test.go:30:16: undefined: check_parens

    /tmp/tmp_0f8kyam_test.go:33:16: undefined: check_parens

    /tmp/tmp_0f8kyam_test.go:35:8: undefined: check_parens

    /tmp/tmp_0f8kyam_test.go:38:8: undefined: check_parens

    /tmp/tmp_0f8kyam_test.go:41:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open, s1_close, s2_close int\n    )\n    if len(lst) != 2\
    \ {\n        return \"No\"\n    }\n    s1, s2 = lst[0], lst[1]\n    for _, c :=\
    \ range s1 {\n        if c == '(' {\n            s1_open++\n        } else {\n\
    \            s1_close++\n        }\n    }\n    for _, c := range s2 {\n      \
    \  if c == '(' {\n            s2_open++\n        } else {\n            s2_close++\n\
    \        }\n    }\n    if s1_open == s2_close && s1_close == s2_open {\n     \
    \   return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp57v2j9qj_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp57v2j9qj_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp57v2j9qj_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp57v2j9qj_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp57v2j9qj_test.go:74: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    s1, s2 := lst[0], lst[1]\n\
    \    if len(s1) == 0 && len(s2) == 0 {\n        return \"Yes\"\n    }\n    if\
    \ len(s1) == 0 {\n        return \"No\"\n    }\n    if len(s2) == 0 {\n      \
    \  return \"No\"\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n        return\
    \ match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] == '(' {\n     \
    \   return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')' {\n\
    \        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpq7j2smer_test.go:68: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpq7j2smer_test.go:68: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpq7j2smer_test.go:68: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpq7j2smer_test.go:68: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpq7j2smer_test.go:68: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: Implement me\n  \
    \  return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var cnt int\n    for _, s\
    \ := range lst {\n        for _, c := range s {\n            if c == '(' {\n \
    \               cnt++\n            } else {\n                cnt--\n         \
    \   }\n            if cnt < 0 {\n                return \"No\"\n            }\n\
    \        }\n    }\n    if cnt == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpx5hyb61m_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpx5hyb61m_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpx5hyb61m_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if len(s) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s) % 2 != 0 {\n        return \"No\"\n    }\n   \
    \ var stack []string\n    for _, c := range s {\n        if c == '(' {\n     \
    \       stack = append(stack, \"(\")\n        } else {\n            if len(stack)\
    \ == 0 {\n                return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n \
    \   return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpmhf3ro1t_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpmhf3ro1t_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpmhf3ro1t_test.go:73: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    return match_parens_s(s)\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpplbdcm90_test.go:26:12: undefined: match_parens_s

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_string(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpheib4qs6_test.go:26:12: undefined: match_parens_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    if is_good(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ is_good(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s1 +\
    \ s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s2 + s1) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmsuq0e2z_test.go:30:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:33:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:35:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:38:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:41:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:44:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var l, r int\n    for _, s\
    \ := range lst {\n        for _, c := range s {\n            if c == '(' {\n \
    \               l++\n            } else {\n                if l > 0 {\n      \
    \              l--\n                } else {\n                    r++\n      \
    \          }\n            }\n        }\n    }\n    if l == 0 && r == 0 {\n   \
    \     return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp36rbgshu_test.go:66: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp36rbgshu_test.go:66: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp36rbgshu_test.go:66: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    str1, str2 := lst[0], lst[1]\n    if len(str1) ==\
    \ 0 && len(str2) == 0 {\n        return \"Yes\"\n    }\n    if len(str1) == 0\
    \ {\n        return check_parens(str2)\n    }\n    if len(str2) == 0 {\n     \
    \   return check_parens(str1)\n    }\n    if check_parens(str1) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if check_parens(str2) == \"Yes\" {\n     \
    \   return \"Yes\"\n    }\n    if check_parens(str1 + str2) == \"Yes\" {\n   \
    \     return \"Yes\"\n    }\n    if check_parens(str2 + str1) == \"Yes\" {\n \
    \       return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6pc8l2_6_test.go:30:16: undefined: check_parens

    /tmp/tmp6pc8l2_6_test.go:33:16: undefined: check_parens

    /tmp/tmp6pc8l2_6_test.go:35:8: undefined: check_parens

    /tmp/tmp6pc8l2_6_test.go:38:8: undefined: check_parens

    /tmp/tmp6pc8l2_6_test.go:41:8: undefined: check_parens

    /tmp/tmp6pc8l2_6_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        c1, c2 int\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  for i = 0; i < len(s1); i++ {\n        if s1[i] == '(' {\n            c1++\n\
    \        } else {\n            c1--\n        }\n    }\n    for j = 0; j < len(s2);\
    \ j++ {\n        if s2[j] == '(' {\n            c2++\n        } else {\n     \
    \       c2--\n        }\n    }\n    if c1 == 0 && c2 == 0 {\n        return \"\
    Yes\"\n    }\n    if c1 == 0 && c2 < 0 {\n        return \"Yes\"\n    }\n    if\
    \ c1 < 0 && c2 == 0 {\n        return \"Yes\"\n    }\n    if c1 < 0 && c2 < 0\
    \ {\n        if c1 + c2 == 0 {\n            return \"Yes\"\n        }\n    }\n\
    \    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfqlfhdnp_test.go:83: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpfqlfhdnp_test.go:83: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpfqlfhdnp_test.go:83: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmpfqlfhdnp_test.go:83: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpfqlfhdnp_test.go:83: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpfqlfhdnp_test.go:83: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpfqlfhdnp_test.go:83: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpfqlfhdnp_test.go:83: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    fmt.Println(s)\n    return \"Yes\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "()()\n))\n(()(())())())\n)())(()()(\n(())))(()())((\n()())\n(()(()))()\n\
    ((((((())\n)(()(()(\n)()(\n()\n)(\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp7vhmm9we_test.go:54:\
    \ expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp7vhmm9we_test.go:54: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmp7vhmm9we_test.go:54: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmp7vhmm9we_test.go:54: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmp7vhmm9we_test.go:54: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp7vhmm9we_test.go:54: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []rune\n    for _, v :=\
    \ range s {\n        if v == '(' {\n            stack = append(stack, v)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp6itgj8m1_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp6itgj8m1_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp6itgj8m1_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" && check_parens(s2) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if check_parens(s1 + s2) == \"Yes\" {\n  \
    \      return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"Yes\" {\n    \
    \    return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_0f8kyam_test.go:30:16: undefined: check_parens

    /tmp/tmp_0f8kyam_test.go:33:16: undefined: check_parens

    /tmp/tmp_0f8kyam_test.go:35:8: undefined: check_parens

    /tmp/tmp_0f8kyam_test.go:38:8: undefined: check_parens

    /tmp/tmp_0f8kyam_test.go:41:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  for i < len(s1) && j < len(s2) {\n        if s1[i] == '(' && s2[j] == ')' {\n\
    \            res += \"()\"\n            i++\n            j++\n        } else if\
    \ s1[i] == '(' {\n            res += \"(\"\n            i++\n        } else if\
    \ s2[j] == ')' {\n            res += \")\"\n            j++\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if i < len(s1) {\n        res\
    \ += s1[i:]\n    }\n    if j < len(s2) {\n        res += s2[j:]\n    }\n    if\
    \ is_good(res) {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwwrwmiy5_test.go:49:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []byte\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, byte(c))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpsy4bwxlj_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpsy4bwxlj_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpsy4bwxlj_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073608
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    var stack []rune\n    for _, r\
    \ := range s {\n        if r == '(' {\n            stack = append(stack, r)\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcor029yc_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcor029yc_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcor029yc_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073608
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var stack []rune\n    for\
    \ _, s := range lst {\n        for _, r := range s {\n            if r == '('\
    \ {\n                stack = append(stack, r)\n            } else {\n        \
    \        if len(stack) == 0 {\n                    return \"No\"\n           \
    \     }\n                stack = stack[:len(stack)-1]\n            }\n       \
    \ }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmplt0ydr2z_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmplt0ydr2z_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmplt0ydr2z_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073608
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // Your code here\n    return\
    \ \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfum5pze0_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpfum5pze0_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpfum5pze0_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpfum5pze0_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpfum5pze0_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpfum5pze0_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpfum5pze0_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpfum5pze0_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpfum5pze0_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpfum5pze0_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpfum5pze0_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpfum5pze0_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    return match_parens_helper(s)\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_bnjemr8_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    if len(lst[0]) == 0 && len(lst[1]) == 0 {\n    \
    \    return \"Yes\"\n    }\n    if len(lst[0]) == 0 {\n        return \"No\"\n\
    \    }\n    if len(lst[1]) == 0 {\n        return \"No\"\n    }\n    if lst[0][0]\
    \ == '(' && lst[1][0] == ')' {\n        return match_parens([]string{lst[0][1:],\
    \ lst[1][1:]})\n    }\n    if lst[0][0] == '(' {\n        return match_parens([]string{lst[0][1:],\
    \ lst[1]})\n    }\n    if lst[1][0] == ')' {\n        return match_parens([]string{lst[0],\
    \ lst[1][1:]})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpknmajrc9_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpknmajrc9_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpknmajrc9_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpknmajrc9_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpknmajrc9_test.go:70: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []rune\n    for _, c := range s {\n        if c\
    \ == '(' {\n            stack = append(stack, c)\n        } else {\n         \
    \   if len(stack) == 0 {\n                return \"No\"\n            }\n     \
    \       stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpedmjzeys_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpedmjzeys_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpedmjzeys_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  for i < len(s1) && j < len(s2) {\n        if s1[i] == '(' && s2[j] == ')' {\n\
    \            i++\n            j++\n        } else if s1[i] == '(' && s2[j] ==\
    \ '(' {\n            i++\n        } else if s1[i] == ')' && s2[j] == ')' {\n \
    \           j++\n        } else {\n            return \"No\"\n        }\n    }\n\
    \    if i == len(s1) && j == len(s2) {\n        res = \"Yes\"\n    } else {\n\
    \        res = \"No\"\n    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvuyi0ltq_test.go:72: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpvuyi0ltq_test.go:72: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpvuyi0ltq_test.go:72: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpvuyi0ltq_test.go:72: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpvuyi0ltq_test.go:72: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    s := lst[0] + lst[1]\n   \
    \ stack := make([]byte, 0)\n    for i := 0; i < len(s); i++ {\n        if s[i]\
    \ == '(' {\n            stack = append(stack, s[i])\n        } else {\n      \
    \      if len(stack) == 0 {\n                return \"No\"\n            }\n  \
    \          stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp5jor7_82_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp5jor7_82_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp5jor7_82_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    return is_good(s1 + s2)\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5cks5t97_test.go:30:16: undefined: is_good

    /tmp/tmp5cks5t97_test.go:33:16: undefined: is_good

    /tmp/tmp5cks5t97_test.go:35:12: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    var c int\n\
    \    for _, s1 := range lst {\n        for _, c1 := range s1 {\n            if\
    \ c1 == '(' {\n                c++\n            } else {\n                c--\n\
    \            }\n            if c < 0 {\n                return \"No\"\n      \
    \      }\n        }\n        s += s1\n    }\n    if c == 0 {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp9x1m6b02_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp9x1m6b02_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp9x1m6b02_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []rune\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, c)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcw3suv28_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcw3suv28_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcw3suv28_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  i, j = 0, 0\n    for i < len(s1) && j < len(s2) {\n        if s1[i] == '('\
    \ && s2[j] == ')' {\n            i++\n            j++\n        } else if s1[i]\
    \ == '(' && s2[j] == '(' {\n            i++\n        } else if s1[i] == ')' &&\
    \ s2[j] == ')' {\n            j++\n        } else {\n            return \"No\"\
    \n        }\n    }\n    if i < len(s1) {\n        res = s1[i:]\n    } else if\
    \ j < len(s2) {\n        res = s2[j:]\n    }\n    if len(res) % 2 == 0 {\n   \
    \     return \"No\"\n    }\n    for i := 0; i < len(res); i++ {\n        if res[i]\
    \ == '(' {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp7x87n3f5_test.go:81: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp7x87n3f5_test.go:81: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmp7x87n3f5_test.go:81: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp7x87n3f5_test.go:81: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmp7x87n3f5_test.go:81: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmp7x87n3f5_test.go:81: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp7x87n3f5_test.go:81: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_rec(s)\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_r58w7u_test.go:26:12: undefined: match_parens_rec

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    return match_parens_helper(s)\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_bnjemr8_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    return match_parens_helper(s)\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqa4yv9qi_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_rec(s)\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_r58w7u_test.go:26:12: undefined: match_parens_rec

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if is_good(s) {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfhywnfip_test.go:26:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []byte\n    for _, c := range s {\n        if c\
    \ == '(' {\n            stack = append(stack, byte(c))\n        } else {\n   \
    \         if len(stack) == 0 {\n                return \"No\"\n            }\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp1fnz4g56_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp1fnz4g56_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp1fnz4g56_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var stack []string\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                stack = append(stack, \"(\")\n            } else {\n    \
    \            if len(stack) == 0 {\n                    return \"No\"\n       \
    \         }\n                stack = stack[:len(stack)-1]\n            }\n   \
    \     }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpf7nlnqy5_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpf7nlnqy5_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpf7nlnqy5_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var cnt int\n    for _, s\
    \ := range lst {\n        for _, c := range s {\n            if c == '(' {\n \
    \               cnt++\n            } else {\n                cnt--\n         \
    \   }\n            if cnt < 0 {\n                return \"No\"\n            }\n\
    \        }\n    }\n    if cnt == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpx5hyb61m_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpx5hyb61m_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpx5hyb61m_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    return match_parens_helper(s)\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_bnjemr8_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_rec(s)\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_r58w7u_test.go:26:12: undefined: match_parens_rec

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var count int\n    for _, c := range\
    \ s {\n        if c == '(' {\n            count++\n        } else {\n        \
    \    count--\n        }\n        if count < 0 {\n            return \"No\"\n \
    \       }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmphe6nclyu_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmphe6nclyu_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmphe6nclyu_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var l, r int\n    for _, s\
    \ := range lst {\n        for _, c := range s {\n            if c == '(' {\n \
    \               l++\n            } else {\n                if l > 0 {\n      \
    \              l--\n                } else {\n                    r++\n      \
    \          }\n            }\n        }\n    }\n    if l == 0 && r == 0 {\n   \
    \     return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp36rbgshu_test.go:66: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp36rbgshu_test.go:66: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp36rbgshu_test.go:66: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    if is_good(s) {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt6lc9dy5_test.go:26:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []rune\n    for _, r :=\
    \ range s {\n        if r == '(' {\n            stack = append(stack, r)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpwmme76wk_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpwmme76wk_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpwmme76wk_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        left, right\
    \ int\n        res string\n    )\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                left++\n        \
    \    } else {\n                right++\n            }\n        }\n    }\n    if\
    \ left == right {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n\
    \    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpne77acsu_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens_helper(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens_helper(s1)\n    }\n    if match_parens_helper(s1) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if match_parens_helper(s2) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if match_parens_helper(s1 + s2) == \"Yes\"\
    \ {\n        return \"Yes\"\n    }\n    if match_parens_helper(s2 + s1) == \"\
    Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmfea8nie_test.go:30:16: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:33:16: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:35:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:38:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:41:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:44:8: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var result string = \"Yes\"\
    \n    var open, close int = 0, 0\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                open++\n        \
    \    } else {\n                close++\n            }\n        }\n    }\n    if\
    \ open != close {\n        result = \"No\"\n    }\n    return result\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp2a5egkks_test.go:63: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  for i < len(s1) && j < len(s2) {\n        if s1[i] == '(' && s2[j] == ')' {\n\
    \            res += \"()\"\n            i++\n            j++\n        } else if\
    \ s1[i] == '(' {\n            res += \"(\"\n            i++\n        } else if\
    \ s2[j] == ')' {\n            res += \")\"\n            j++\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    for i < len(s1) {\n        res\
    \ += string(s1[i])\n        i++\n    }\n    for j < len(s2) {\n        res +=\
    \ string(s2[j])\n        j++\n    }\n    if is_good(res) {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoobxo32y_test.go:51:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073610
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073610
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    if is_good(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ is_good(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s1 +\
    \ s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s2 + s1) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp33xe86n5_test.go:27:16: undefined: is_good

    /tmp/tmp33xe86n5_test.go:30:16: undefined: is_good

    /tmp/tmp33xe86n5_test.go:32:8: undefined: is_good

    /tmp/tmp33xe86n5_test.go:35:8: undefined: is_good

    /tmp/tmp33xe86n5_test.go:38:8: undefined: is_good

    /tmp/tmp33xe86n5_test.go:41:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073610
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: Implement me\n  \
    \  return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    if is_good(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ is_good(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s1 +\
    \ s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s2 + s1) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp33xe86n5_test.go:27:16: undefined: is_good

    /tmp/tmp33xe86n5_test.go:30:16: undefined: is_good

    /tmp/tmp33xe86n5_test.go:32:8: undefined: is_good

    /tmp/tmp33xe86n5_test.go:35:8: undefined: is_good

    /tmp/tmp33xe86n5_test.go:38:8: undefined: is_good

    /tmp/tmp33xe86n5_test.go:41:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073610
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var stack []string\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                stack = append(stack, \"(\")\n            } else {\n    \
    \            if len(stack) == 0 {\n                    return \"No\"\n       \
    \         }\n                stack = stack[:len(stack)-1]\n            }\n   \
    \     }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpf7nlnqy5_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpf7nlnqy5_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpf7nlnqy5_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    fmt.Println(s)\n    return \"Yes\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "()()\n))\n(()(())())())\n)())(()()(\n(())))(()())((\n()())\n(()(()))()\n\
    ((((((())\n)(()(()(\n)()(\n()\n)(\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpz0gg7o1v_test.go:54:\
    \ expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpz0gg7o1v_test.go:54: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmpz0gg7o1v_test.go:54: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpz0gg7o1v_test.go:54: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmpz0gg7o1v_test.go:54: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpz0gg7o1v_test.go:54: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    return check_parens(s1 + s2)\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxw18iosx_test.go:30:16: undefined: check_parens

    /tmp/tmpxw18iosx_test.go:33:16: undefined: check_parens

    /tmp/tmpxw18iosx_test.go:35:12: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm89jmi9e_test.go:74: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpm89jmi9e_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    fmt.Println(s)\n    var stack []string\n\
    \    for _, c := range s {\n        if c == '(' {\n            stack = append(stack,\
    \ \"(\")\n        } else {\n            if len(stack) == 0 {\n               \
    \ return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n   \
    \     }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "()()\n))\n(()(())())())\n)())(()()(\n(())))(()())((\n()())\n(()(()))()\n\
    ((((((())\n)(()(()(\n)()(\n()\n)(\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmprq6kpyv1_test.go:68:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmprq6kpyv1_test.go:68: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmprq6kpyv1_test.go:68: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073610
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    s := lst[0] + lst[1]\n   \
    \ return match_parens_helper(s)\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuiq3i2hc_test.go:23:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        res string\n    )\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                open++\n        \
    \    } else {\n                close++\n            }\n        }\n    }\n    if\
    \ open == close {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n\
    \    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpyqrongtc_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []byte\n    for _, c := range s {\n        if c\
    \ == '(' {\n            stack = append(stack, byte(c))\n        } else {\n   \
    \         if len(stack) == 0 {\n                return \"No\"\n            }\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp1fnz4g56_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp1fnz4g56_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp1fnz4g56_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []byte\n    for i := 0; i < len(s); i++ {\n   \
    \     if s[i] == '(' {\n            stack = append(stack, s[i])\n        } else\
    \ {\n            if len(stack) == 0 {\n                return \"No\"\n       \
    \     }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp21hezssj_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp21hezssj_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp21hezssj_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []rune\n    for _, v :=\
    \ range s {\n        if v == '(' {\n            stack = append(stack, v)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp6itgj8m1_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp6itgj8m1_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp6itgj8m1_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm89jmi9e_test.go:74: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpm89jmi9e_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var stack []string\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                stack = append(stack, \"(\")\n            } else {\n    \
    \            if len(stack) == 0 {\n                    return \"No\"\n       \
    \         }\n                stack = stack[:len(stack)-1]\n            }\n   \
    \     }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpf7nlnqy5_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpf7nlnqy5_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpf7nlnqy5_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        open, close int\n    )\n    s1, s2 = lst[0], lst[1]\n\
    \    for i = 0; i < len(s1); i++ {\n        if s1[i] == '(' {\n            open++\n\
    \        } else {\n            close++\n        }\n    }\n    for j = 0; j < len(s2);\
    \ j++ {\n        if s2[j] == '(' {\n            open++\n        } else {\n   \
    \         close++\n        }\n    }\n    if open == close {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpg8i9tcmj_test.go:72: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    if is_good(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ is_good(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s1 +\
    \ s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s2 + s1) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmsuq0e2z_test.go:30:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:33:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:35:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:38:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:41:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:44:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    if is_good(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ is_good(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s1 +\
    \ s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s2 + s1) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmsuq0e2z_test.go:30:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:33:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:35:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:38:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:41:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:44:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        lst_len int\
    \ = len(lst)\n        str1, str2 string\n        str1_len, str2_len int\n    \
    \    str1_open, str2_open int\n        str1_close, str2_close int\n        str1_open_close,\
    \ str2_open_close int\n        str1_close_open, str2_close_open int\n        str1_open_close_open,\
    \ str2_open_close_open int\n        str1_close_open_close, str2_close_open_close\
    \ int\n        str1_open_close_open_close, str2_open_close_open_close int\n  \
    \      str1_close_open_close_open, str2_close_open_close_open int\n        str1_open_close_open_close_open,\
    \ str2_open_close_open_close_open int\n        str1_close_open_close_open_close,\
    \ str2_close_open_close_open_close int\n        str1_open_close_open_close_open_close,\
    \ str2_open_close_open_close_open_close int\n        str1_close_open_close_open_close_open,\
    \ str2_close_open_close_open_close_open int\n        str1_open_close_open_close_open_close_open,\
    \ str2_open_close_open_close_open_close_open int\n        str1_close_open_close_open_close_open_close,\
    \ str2_close_open_close_open_close_open_close int\n        str1_open_close_open_close_open_close_open_close,\
    \ str2_open_close_open_close_open_close_open_close int\n        str1_close_open_close_open_close_open_close_open,\
    \ str2_close_open_close_open_close_open_close_open int\n        str1_open_close_open_close_open_close_open_close_open,\
    \ str2_open_close_open_close_open_close_open_close_open int\n        str1_close_open_close_open_close_\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp05uro94g_test.go:43:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073610
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        res string\n    )\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                open++\n        \
    \    } else {\n                close++\n            }\n        }\n    }\n    if\
    \ open == close {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n\
    \    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpyqrongtc_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var cnt int\n    for _, c := range\
    \ s {\n        if c == '(' {\n            cnt++\n        } else {\n          \
    \  cnt--\n        }\n        if cnt < 0 {\n            return \"No\"\n       \
    \ }\n    }\n    if cnt == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpmnjs1_7z_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpmnjs1_7z_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpmnjs1_7z_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        return match_parens([]string{s1[1:], s2})\n  \
    \  }\n    if s2[0] == '(' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    if s1[0] == ')' {\n        return match_parens([]string{s1[1:], s2})\n\
    \    }\n    if s2[0] == ')' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    str1, str2 := lst[0], lst[1]\n    if len(str1) ==\
    \ 0 || len(str2) == 0 {\n        return \"No\"\n    }\n    if len(str1) % 2 !=\
    \ 0 || len(str2) % 2 != 0 {\n        return \"No\"\n    }\n    if is_good(str1\
    \ + str2) {\n        return \"Yes\"\n    }\n    if is_good(str2 + str1) {\n  \
    \      return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphs44abk5_test.go:32:8: undefined: is_good

    /tmp/tmphs44abk5_test.go:35:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []rune\n    for _, c := range s {\n        if c\
    \ == '(' {\n            stack = append(stack, c)\n        } else {\n         \
    \   if len(stack) == 0 {\n                return \"No\"\n            }\n     \
    \       stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpfgs4f748_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpfgs4f748_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpfgs4f748_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    return match_parens_s(s)\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpplbdcm90_test.go:26:12: undefined: match_parens_s

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var count int\n    for _, v := range\
    \ s {\n        if v == '(' {\n            count++\n        } else {\n        \
    \    count--\n        }\n        if count < 0 {\n            return \"No\"\n \
    \       }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmphs2f5szz_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmphs2f5szz_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmphs2f5szz_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left += 1\n            } else {\n                if left\
    \ > 0 {\n                    left -= 1\n                } else {\n           \
    \         right += 1\n                }\n            }\n        }\n    }\n   \
    \ if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmplhys3hu1_test.go:66: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        lst_len = len(lst)\n\
    \        str_len = len(lst[0]) + len(lst[1])\n        str = make([]byte, str_len)\n\
    \        i, j, k int\n    )\n    for i = 0; i < lst_len; i++ {\n        for j\
    \ = 0; j < len(lst[i]); j++ {\n            str[k] = lst[i][j]\n            k++\n\
    \        }\n    }\n    fmt.Println(string(str))\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "()()\n))\n(()(())())())\n)())(()()(\n(())))(()())((\n()())\n(()(()))()\n\
    ((((((())\n)(()(()(\n)()(\n()\n)(\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpvqb69gn5_test.go:62:\
    \ expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpvqb69gn5_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmpvqb69gn5_test.go:62: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpvqb69gn5_test.go:62: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmpvqb69gn5_test.go:62: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpvqb69gn5_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_recur(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpymtoo__i_test.go:26:12: undefined: match_parens_recur

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2})\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens([]string{s1})\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n \
    \       return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] ==\
    \ '(' {\n        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0]\
    \ == ')' {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []byte\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, '(')\n \
    \       } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp2l8h_d9h_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp2l8h_d9h_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp2l8h_d9h_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []rune\n    for _, r :=\
    \ range s {\n        if r == '(' {\n            stack = append(stack, r)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpn_540ory_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpn_540ory_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpn_540ory_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        left, right\
    \ int\n        s string\n    )\n    for _, s = range lst {\n        for _, c :=\
    \ range s {\n            if c == '(' {\n                left++\n            }\
    \ else {\n                right++\n            }\n        }\n    }\n    if left\
    \ == right {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpihgiwcqi_test.go:65: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ check_parens(s1)\n    }\n    if check_parens(s1) == \"Yes\" && check_parens(s2)\
    \ == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1 + s2) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"\
    Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfts5y72f_test.go:27:16: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:30:16: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:32:8: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:35:8: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:38:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var stack []rune\n    for\
    \ _, s := range lst {\n        for _, r := range s {\n            if r == '('\
    \ {\n                stack = append(stack, r)\n            } else {\n        \
    \        if len(stack) == 0 {\n                    return \"No\"\n           \
    \     }\n                stack = stack[:len(stack)-1]\n            }\n       \
    \ }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmplt0ydr2z_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmplt0ydr2z_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmplt0ydr2z_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073608
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        return match_parens([]string{s1[1:], s2})\n  \
    \  }\n    if s2[0] == '(' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    if s1[0] == ')' {\n        return match_parens([]string{s1[1:], s2})\n\
    \    }\n    if s2[0] == ')' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  for i < len(s1) && j < len(s2) {\n        if s1[i] == '(' && s2[j] == ')' {\n\
    \            res += \"()\"\n            i++\n            j++\n        } else if\
    \ s1[i] == '(' {\n            res += \"(\"\n            i++\n        } else if\
    \ s2[j] == ')' {\n            res += \")\"\n            j++\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if i < len(s1) {\n        res\
    \ += s1[i:]\n    }\n    if j < len(s2) {\n        res += s2[j:]\n    }\n    if\
    \ is_good(res) {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwwrwmiy5_test.go:49:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []string\n    for _, v := range s {\n        if\
    \ v == '(' {\n            stack = append(stack, \"(\")\n        } else {\n   \
    \         if len(stack) == 0 {\n                return \"No\"\n            }\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp2lcr8v_7_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp2lcr8v_7_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp2lcr8v_7_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(lst) == 1 {\n        return check_parens(lst[0])\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        if check_parens(lst[i]) ==\
    \ \"Yes\" {\n            return \"Yes\"\n        }\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpalt_bzby_test.go:26:16: undefined: check_parens

    /tmp/tmpalt_bzby_test.go:29:12: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    str1, str2 := lst[0], lst[1]\n    if len(str1) ==\
    \ 0 || len(str2) == 0 {\n        return \"No\"\n    }\n    if str1[0] == ')' ||\
    \ str2[0] == ')' {\n        return \"No\"\n    }\n    if str1[len(str1)-1] ==\
    \ '(' || str2[len(str2)-1] == '(' {\n        return \"No\"\n    }\n    if len(str1)\
    \ % 2 == 1 || len(str2) % 2 == 1 {\n        return \"No\"\n    }\n    if len(str1)\
    \ == 2 && str1[0] == '(' && str1[1] == ')' {\n        return \"Yes\"\n    }\n\
    \    if len(str2) == 2 && str2[0] == '(' && str2[1] == ')' {\n        return \"\
    Yes\"\n    }\n    if len(str1) == 2 && str1[0] == ')' && str1[1] == '(' {\n  \
    \      return \"Yes\"\n    }\n    if len(str2) == 2 && str2[0] == ')' && str2[1]\
    \ == '(' {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp0rfp_3m6_test.go:77: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp0rfp_3m6_test.go:77: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp0rfp_3m6_test.go:77: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp0rfp_3m6_test.go:77: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp0rfp_3m6_test.go:77: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp0rfp_3m6_test.go:77: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var result string\n    var\
    \ stack []string\n    for _, s := range lst {\n        for _, c := range s {\n\
    \            if c == '(' {\n                stack = append(stack, \"(\")\n   \
    \         } else {\n                if len(stack) > 0 {\n                    stack\
    \ = stack[:len(stack)-1]\n                } else {\n                    return\
    \ \"No\"\n                }\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        result = \"Yes\"\n    } else {\n        result = \"No\"\n  \
    \  }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxheyii7d_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxheyii7d_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxheyii7d_test.go:69: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073611
