name: HumanEval_144_simplify
language: go_test.go
prompt: "package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Your task is to implement a function that will simplify the expression\n// x *\
  \ n. The function returns true if x * n evaluates to a whole number and false\n\
  // otherwise. Both x and n, are string representation of a fraction, and have the\
  \ following format,\n// <numerator>/<denominator> where both numerator and denominator\
  \ are positive whole numbers.\n// You can assume that x, and n are valid fractions,\
  \ and do not have zero as denominator.\n// >>> simplify(\"1/5\", \"5/1\")\n// true\n\
  // >>> simplify(\"1/6\", \"2/1\")\n// false\n// >>> simplify(\"7/10\", \"10/2\"\
  )\n// false\nfunc simplify(x string, n string) bool {\n"
tests: "func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate(\"1/5\", \"5/1\"), expected: true },\n     { actual: candidate(\"\
  1/6\", \"2/1\"), expected: false },\n     { actual: candidate(\"5/1\", \"3/1\"),\
  \ expected: true },\n     { actual: candidate(\"7/10\", \"10/2\"), expected: false\
  \ },\n     { actual: candidate(\"2/10\", \"50/10\"), expected: true },\n     { actual:\
  \ candidate(\"7/2\", \"4/2\"), expected: true },\n     { actual: candidate(\"11/6\"\
  , \"6/1\"), expected: true },\n     { actual: candidate(\"2/3\", \"5/2\"), expected:\
  \ false },\n     { actual: candidate(\"5/2\", \"3/5\"), expected: false },\n   \
  \  { actual: candidate(\"2/4\", \"8/4\"), expected: true },\n     { actual: candidate(\"\
  2/4\", \"4/2\"), expected: true },\n     { actual: candidate(\"1/5\", \"5/1\"),\
  \ expected: true },\n     { actual: candidate(\"1/5\", \"1/5\"), expected: false\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    x_numerator, x_denominator := parseFraction(x)\n    n_numerator,\
    \ n_denominator := parseFraction(n)\n    x_numerator *= n_denominator\n    x_denominator\
    \ *= n_numerator\n    return x_numerator % x_denominator == 0\n}\n", "    xNumerator,\
    \ xDenominator := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n\
    \    return (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n",
  "    xn := parse(x)\n    nn := parse(n)\n    return xn.numerator * nn.denominator\
    \ % xn.denominator == 0\n}\n", "    xNumerator, xDenominator := parseFraction(x)\n\
    \    nNumerator, nDenominator := parseFraction(n)\n    return (xNumerator * nDenominator)\
    \ % (xDenominator * nNumerator) == 0\n}\n", "    x_num, x_den := parse(x)\n  \
    \  n_num, n_den := parse(n)\n    return (x_num * n_den) % (x_den * n_num) == 0\n\
    }\n", "    xNumerator, xDenominator := parseFraction(x)\n    nNumerator, nDenominator\
    \ := parseFraction(n)\n    return isWholeNumber(xNumerator * nDenominator, xDenominator\
    \ * nNumerator)\n}\n", "    xn, xd := parse(x)\n    nn, nd := parse(n)\n    return\
    \ xn * nd == xd * nn\n}\n", "    x_n, x_d := parse(x)\n    n_n, n_d := parse(n)\n\
    \    return (x_n * n_d) % (x_d * n_n) == 0\n}\n", "    xNum, xDen := parseFraction(x)\n\
    \    nNum, nDen := parseFraction(n)\n    return (xNum * nDen) % (xDen * nNum)\
    \ == 0\n}\n", "    // your code here\n    return false\n}\n", "    xn, xd := parse(x)\n\
    \    nn, nd := parse(n)\n    return xn * nd == xd * nn\n}\n", "    var xNum, xDen,\
    \ nNum, nDen int\n    fmt.Sscanf(x, \"%d/%d\", &xNum, &xDen)\n    fmt.Sscanf(n,\
    \ \"%d/%d\", &nNum, &nDen)\n    return xNum * nDen == xDen * nNum\n}\n", "   \
    \ xNumerator, xDenominator := parseFraction(x)\n    nNumerator, nDenominator :=\
    \ parseFraction(n)\n    return isWholeNumber(xNumerator * nDenominator, xDenominator\
    \ * nNumerator)\n}\n", "    var xNum, xDen, nNum, nDen int\n    fmt.Sscanf(x,\
    \ \"%d/%d\", &xNum, &xDen)\n    fmt.Sscanf(n, \"%d/%d\", &nNum, &nDen)\n    return\
    \ xNum * nDen == xDen * nNum\n}\n", "    xNumerator, xDenominator := parseFraction(x)\n\
    \    nNumerator, nDenominator := parseFraction(n)\n    return xNumerator * nDenominator\
    \ * nNumerator * xDenominator % (xDenominator * nDenominator) == 0\n}\n", "  \
    \  return false\n}\n", "    // Write your code here\n    return false\n}\n", " \
    \   xn := parse(x)\n    nn := parse(n)\n    return xn * nn % 1 == 0\n}\n", " \
    \   // Your code goes here\n    return false\n}\n", "    xNumerator, xDenominator\
    \ := parseFraction(x)\n    nNumerator, nDenominator := parseFraction(n)\n    return\
    \ (xNumerator * nDenominator) % (xDenominator * nNumerator) == 0\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
