name: HumanEval_119_match_parens
language: go_test.go
prompt: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // You are given a list of two strings, both strings consist of open\n// parentheses\
  \ '(' or close parentheses ')' only.\n// Your job is to check if it is possible\
  \ to concatenate the two strings in\n// some order, that the resulting string will\
  \ be good.\n// A string S is considered to be good if and only if all parentheses\
  \ in S\n// are balanced. For example: the string '(())()' is good, while the string\n\
  // '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return\
  \ 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"()(\", \")\"})\n\
  // \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"No\"\nfunc match_parens(lst\
  \ []string) string {\n"
tests: "func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\"\
  \ },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n  \
  \   { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n\
  \     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n\
  \     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\"\
  \ },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n\
  \     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n\
  \     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n\
  \     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n \
  \    { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     {\
  \ actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n     { actual:\
  \ candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc :=\
  \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    var s string\n    for _, v := range lst {\n        s += v\n   \
    \ }\n    return match_parens_rec(s)\n}\n", "    var s string\n    for _, v :=\
    \ range lst {\n        s += v\n    }\n    return match_parens_rec(s)\n}\n", " \
    \   var (\n        lst_len = len(lst)\n        i       int\n        j       int\n\
    \        k       int\n        l       int\n        m       int\n        n    \
    \   int\n        s       string\n        t       string\n        u       string\n\
    \        v       string\n        w       string\n        x       string\n    \
    \    y       string\n        z       string\n    )\n    if lst_len < 2 {\n   \
    \     return \"No\"\n    }\n    for i = 0; i < lst_len; i++ {\n        s = lst[i]\n\
    \        for j = 0; j < lst_len; j++ {\n            if i == j {\n            \
    \    continue\n            }\n            t = lst[j]\n            for k = 0; k\
    \ < lst_len; k++ {\n                if k == i || k == j {\n                  \
    \  continue\n                }\n                u = lst[k]\n                for\
    \ l = 0; l < lst_len; l++ {\n                    if l == i || l == j || l == k\
    \ {\n                        continue\n                    }\n               \
    \     v = lst[l]\n                    for m = 0; m < lst_len; m++ {\n        \
    \                if m == i || m == j || m == k || m == l {\n                 \
    \           continue\n                        }\n                        w = lst[m]\n\
    \                        for n = 0; n < lst_len; n++ {\n                     \
    \       if n == i || n == j || n == k || n == l || n == m {\n                \
    \                continue\n                            }\n                   \
    \         x = lst[n]\n                            y = s + t + u + v + w + x\n\
    \                            z = is_good(y)\n                            if z\
    \ == \"Yes\" {\n                                return z\n                   \
    \         }\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return \"No\"\n}\n", "    var s string\n\
    \    for _, v := range lst {\n        s += v\n    }\n    var stack []rune\n  \
    \  for _, r := range s {\n        if r == '(' {\n            stack = append(stack,\
    \ r)\n        } else {\n            if len(stack) == 0 {\n                return\
    \ \"No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n", "    var (\n        s1, s2 string\n        s1_open, s2_open int\n\
    \        s1_close, s2_close int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n   \
    \ for _, c := range s1 {\n        if c == '(' {\n            s1_open++\n     \
    \   } else {\n            s1_close++\n        }\n    }\n    for _, c := range\
    \ s2 {\n        if c == '(' {\n            s2_open++\n        } else {\n     \
    \       s2_close++\n        }\n    }\n    if s1_open == s2_close && s1_close ==\
    \ s2_open {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n", "    var\
    \ open, close int\n    for _, s := range lst {\n        for _, c := range s {\n\
    \            if c == '(' {\n                open++\n            } else {\n   \
    \             close++\n            }\n        }\n    }\n    if open == close {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n", "    var count int\n\
    \    for _, s := range lst {\n        for _, c := range s {\n            if c\
    \ == '(' {\n                count++\n            } else {\n                count--\n\
    \            }\n            if count < 0 {\n                return \"No\"\n  \
    \          }\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n\
    \    }\n    return \"No\"\n}\n", "    var (\n        open, close int\n       \
    \ res string\n    )\n    for _, s := range lst {\n        for _, c := range s\
    \ {\n            if c == '(' {\n                open++\n            } else {\n\
    \                close++\n            }\n        }\n    }\n    if open == close\
    \ {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n    }\n    return\
    \ res\n}\n", "    var left, right int\n    for _, s := range lst {\n        for\
    \ _, c := range s {\n            if c == '(' {\n                left++\n     \
    \       } else {\n                right++\n            }\n        }\n    }\n \
    \   if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n",
  "    if len(lst) != 2 {\n        return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n\
    \    if len(s1) == 0 {\n        return check_parens(s2)\n    }\n    if len(s2)\
    \ == 0 {\n        return check_parens(s1)\n    }\n    if check_parens(s1 + s2)\
    \ == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 + s1) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n", "    var\
    \ left, right int\n    for _, s := range lst {\n        for _, c := range s {\n\
    \            if c == '(' {\n                left++\n            } else {\n   \
    \             right++\n            }\n        }\n    }\n    if left == right {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n", "    if len(lst) != 2\
    \ {\n        return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1)\
    \ == 0 && len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n\
    \        return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n\
    \        return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n", "    var (\n        open int\n        close int\n    )\n    for _, s :=\
    \ range lst {\n        for _, c := range s {\n            if c == '(' {\n    \
    \            open++\n            } else {\n                close++\n         \
    \   }\n        }\n    }\n    if open == close {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n", "    if len(lst) != 2 {\n        return \"No\"\n   \
    \ }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\
    \n    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n", "    return \"Yes\"\n}\n", "    var (\n\
    \        s1, s2 string\n        i, j int\n        c1, c2 rune\n        ok bool\n\
    \    )\n    s1, s2 = lst[0], lst[1]\n    for i, j = 0, 0; i < len(s1) && j < len(s2);\
    \ {\n        c1, c2 = rune(s1[i]), rune(s2[j])\n        if c1 == '(' {\n     \
    \       if c2 == ')' {\n                i, j = i + 1, j + 1\n            } else\
    \ {\n                i++\n            }\n        } else {\n            if c2 ==\
    \ '(' {\n                i, j = i + 1, j + 1\n            } else {\n         \
    \       j++\n            }\n        }\n    }\n    if i < len(s1) {\n        s1\
    \ = s1[i:]\n    }\n    if j < len(s2) {\n        s2 = s2[j:]\n    }\n    if len(s1)\
    \ == 0 && len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n\
    \        s1 = s2\n    }\n    for i = 0; i < len(s1); i++ {\n        if s1[i] ==\
    \ '(' {\n            break\n        }\n    }\n    if i == len(s1) {\n        return\
    \ \"No\"\n    }\n    s1 = s1[i:]\n    for i = len(s1) - 1; i >= 0; i-- {\n   \
    \     if s1[i] == ')' {\n            break\n        }\n    }\n    if i == -1 {\n\
    \        return \"No\"\n    }\n    s1 = s1[:i+1]\n    for i = 0; i < len(s1);\
    \ i++ {\n        if s1[i] == '(' {\n            break\n        }\n    }\n    if\
    \ i == len(s1) {\n        return \"No\"\n    }\n    s1 = s1[i:]\n    for i = len(s1)\
    \ - 1; i >= 0; i-- {", "    if len(lst) != 2 {\n        return \"No\"\n    }\n\
    \    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n       \
    \ return \"Yes\"\n    }\n    if len(s1) == 0 {\n        return match_parens_helper(s2)\n\
    \    }\n    if len(s2) == 0 {\n        return match_parens_helper(s1)\n    }\n\
    \    return match_parens_helper(s1 + s2)\n}\n", "    if len(lst) != 2 {\n    \
    \    return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens_helper(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens_helper(s1)\n    }\n    return \"Yes\"\n}\n", "    var s string\n\
    \    for _, s1 := range lst {\n        s += s1\n    }\n    if len(s) == 0 {\n\
    \        return \"Yes\"\n    }\n    if s[0] == ')' {\n        return \"No\"\n\
    \    }\n    if s[len(s)-1] == '(' {\n        return \"No\"\n    }\n    var stack\
    \ []byte\n    for _, c := range s {\n        if c == '(' {\n            stack\
    \ = append(stack, byte(c))\n        } else {\n            if len(stack) == 0 {\n\
    \                return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n \
    \   return \"No\"\n}\n", "    return \"Yes\"\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
