name: HumanEval_68_pluck
language: go_test.go
prompt: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// \"\
  Given a list representing a branch of a tree that has non-negative integer nodes\n\
  // your task is to pluck one of the nodes and return it.\n// The plucked node should\
  \ be the node with the smallest even value.\n// If multiple nodes with the same\
  \ smallest even value are found return the node that has smallest index.\n// The\
  \ plucked node should be returned in a list, [ smalest_value, its index ],\n// If\
  \ there are no even values or the given list is empty, return [].\n// Example 1:\n\
  // >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck([]int{1,\
  \ 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest even value, and 2 has\
  \ the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n// PATCH list\n// Example\
  \ 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0, 1}\n// Explanation: 0 is\
  \ the smallest value, but  there are two zeros,\n// so we will choose the first\
  \ zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <=\
  \ 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n"
tests: "func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
  \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
  \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
  \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
  \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
  \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0,\
  \ 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
  \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
  \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    var result []int\n    var min int\n    var minIndex int\n    var\
    \ minFound bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n      \
    \      if !minFound {\n                min = v\n                minIndex = i\n\
    \                minFound = true\n            } else if v < min {\n          \
    \      min = v\n                minIndex = i\n            }\n        }\n    }\n\
    \    if minFound {\n        result = append(result, min)\n        result = append(result,\
    \ minIndex)\n    }\n    return result\n}\n", "    var result []int\n    if len(arr)\
    \ == 0 {\n        return result\n    }\n    var minEven int\n    var minEvenIndex\
    \ int\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if minEven\
    \ == 0 {\n                minEven = v\n                minEvenIndex = i\n    \
    \        } else if v < minEven {\n                minEven = v\n              \
    \  minEvenIndex = i\n            }\n        }\n    }\n    if minEven != 0 {\n\
    \        result = append(result, minEven)\n        result = append(result, minEvenIndex)\n\
    \    }\n    return result\n}\n", "    var minEven int\n    var minEvenIndex int\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if minEven\
    \ == 0 {\n                minEven = v\n                minEvenIndex = i\n    \
    \        } else if v < minEven {\n                minEven = v\n              \
    \  minEvenIndex = i\n            }\n        }\n    }\n    if minEven == 0 {\n\
    \        return []int{}\n    }\n    return []int{minEven, minEvenIndex}\n}\n",
  "    var min int\n    var minIndex int\n    var minFound bool\n    for i, v := range\
    \ arr {\n        if v % 2 == 0 {\n            if !minFound {\n               \
    \ min = v\n                minIndex = i\n                minFound = true\n   \
    \         } else if v < min {\n                min = v\n                minIndex\
    \ = i\n            }\n        }\n    }\n    if minFound {\n        return []int{min,\
    \ minIndex}\n    }\n    return []int{}\n}\n", "    var result []int\n    if len(arr)\
    \ == 0 {\n        return result\n    }\n    min := -1\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if min == -1 {\n                min\
    \ = v\n                result = []int{min, i}\n            } else if v < min {\n\
    \                min = v\n                result = []int{min, i}\n           \
    \ }\n        }\n    }\n    return result\n}\n", "    var result []int\n    var\
    \ minEven int\n    var minEvenIndex int\n    var minEvenFound bool\n\n    for\
    \ i, v := range arr {\n        if v % 2 == 0 {\n            if !minEvenFound {\n\
    \                minEven = v\n                minEvenIndex = i\n             \
    \   minEvenFound = true\n            } else if v < minEven {\n               \
    \ minEven = v\n                minEvenIndex = i\n            }\n        }\n  \
    \  }\n\n    if minEvenFound {\n        result = append(result, minEven)\n    \
    \    result = append(result, minEvenIndex)\n    }\n\n    return result\n}\n",
  "    var min int\n    var minIndex int\n    var minFound bool\n    for i, v := range\
    \ arr {\n        if v % 2 == 0 {\n            if !minFound {\n               \
    \ min = v\n                minIndex = i\n                minFound = true\n   \
    \         } else if v < min {\n                min = v\n                minIndex\
    \ = i\n            }\n        }\n    }\n    if minFound {\n        return []int{min,\
    \ minIndex}\n    }\n    return []int{}\n}\n", "    var min int\n    var index\
    \ int\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if min\
    \ == 0 {\n                min = v\n                index = i\n            } else\
    \ if v < min {\n                min = v\n                index = i\n         \
    \   }\n        }\n    }\n    if min == 0 {\n        return []int{}\n    }\n  \
    \  return []int{min, index}\n}\n", "    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n    min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n  \
    \      if v % 2 == 0 && v < min {\n            min = v\n            minIndex =\
    \ i\n        }\n    }\n    if min % 2 == 0 {\n        return []int{min, minIndex}\n\
    \    }\n    return []int{}\n}\n", "    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n    min := -1\n    minIndex := -1\n    for i, v := range arr {\n     \
    \   if v % 2 == 0 {\n            if min == -1 || v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == -1 {\n        return []int{}\n    }\n    return []int{min, minIndex}\n}\n",
  "    var result []int\n    var min int\n    var index int\n    for i, v := range\
    \ arr {\n        if v % 2 == 0 {\n            if min == 0 {\n                min\
    \ = v\n                index = i\n            } else if v < min {\n          \
    \      min = v\n                index = i\n            }\n        }\n    }\n \
    \   if min != 0 {\n        result = append(result, min)\n        result = append(result,\
    \ index)\n    }\n    return result\n}\n", "    if len(arr) == 0 {\n        return\
    \ []int{}\n    }\n    var min int\n    var minIndex int\n    var minFound bool\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minFound\
    \ {\n                min = v\n                minIndex = i\n                minFound\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minFound {\n   \
    \     return []int{min, minIndex}\n    }\n    return []int{}\n}\n", "    if len(arr)\
    \ == 0 {\n        return []int{}\n    }\n    min := arr[0]\n    minIndex := 0\n\
    \    for i, v := range arr {\n        if v % 2 == 0 && v < min {\n           \
    \ min = v\n            minIndex = i\n        }\n    }\n    if min % 2 == 0 {\n\
    \        return []int{min, minIndex}\n    }\n    return []int{}\n}\n", "    if\
    \ len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n    index\
    \ := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v < min {\n    \
    \        min = v\n            index = i\n        }\n    }\n    if min % 2 == 0\
    \ {\n        return []int{min, index}\n    }\n    return []int{}\n}\n", "    if\
    \ len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n    minIndex\
    \ := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v < min {\n    \
    \        min = v\n            minIndex = i\n        }\n    }\n    if min % 2 ==\
    \ 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n}\n", " \
    \   var result []int\n    var min int\n    var minIndex int\n    for i, v := range\
    \ arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n        \
    \        min = v\n                minIndex = i\n            } else if v < min\
    \ {\n                min = v\n                minIndex = i\n            }\n  \
    \      }\n    }\n    if len(result) > 0 {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n", " \
    \   if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n   \
    \ minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v < min\
    \ {\n            min = v\n            minIndex = i\n        }\n    }\n    if min\
    \ % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var min_index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                min_index\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    min_index = i\n            }\n        }\n    }\n    if min == 0 {\n     \
    \   return []int{}\n    }\n    return []int{min, min_index}\n}\n", "    var res\
    \ []int\n    var min int\n    var minIndex int\n    for i, v := range arr {\n\
    \        if v % 2 == 0 {\n            if min == 0 {\n                min = v\n\
    \                minIndex = i\n            } else if v < min {\n             \
    \   min = v\n                minIndex = i\n            }\n        }\n    }\n \
    \   if min != 0 {\n        res = append(res, min)\n        res = append(res, minIndex)\n\
    \    }\n    return res\n}\n", "    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n \
    \       if v % 2 == 0 {\n            if min == 0 {\n                min = v\n\
    \                minIndex = i\n            } else if v < min {\n             \
    \   min = v\n                minIndex = i\n            }\n        }\n    }\n \
    \   if min == 0 {\n        return []int{}\n    }\n    return []int{min, minIndex}\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
