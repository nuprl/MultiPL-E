language: go_test.go
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var minFound\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minFound\
    \ {\n                min = v\n                minIndex = i\n                minFound\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minFound {\n   \
    \     result = append(result, min)\n        result = append(result, minIndex)\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var minEven int\n    var minEvenIndex int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if minEven == 0 {\n                minEven\
    \ = v\n                minEvenIndex = i\n            } else if v < minEven {\n\
    \                minEven = v\n                minEvenIndex = i\n            }\n\
    \        }\n    }\n    if minEven != 0 {\n        result = append(result, minEven)\n\
    \        result = append(result, minEvenIndex)\n    }\n    return result\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpg77eg3fk_test.go:78: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpg77eg3fk_test.go:78:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIndex int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if minEven == 0 {\n                minEven\
    \ = v\n                minEvenIndex = i\n            } else if v < minEven {\n\
    \                minEven = v\n                minEvenIndex = i\n            }\n\
    \        }\n    }\n    if minEven == 0 {\n        return []int{}\n    }\n    return\
    \ []int{minEven, minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpmhmj56st_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpmhmj56st_test.go:73:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := -1\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == -1 {\n                min = v\n                result = []int{min,\
    \ i}\n            } else if v < min {\n                min = v\n             \
    \   result = []int{min, i}\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minEven int\n    var minEvenIndex int\n   \
    \ var minEvenFound bool\n\n    for i, v := range arr {\n        if v % 2 == 0\
    \ {\n            if !minEvenFound {\n                minEven = v\n           \
    \     minEvenIndex = i\n                minEvenFound = true\n            } else\
    \ if v < minEven {\n                minEven = v\n                minEvenIndex\
    \ = i\n            }\n        }\n    }\n\n    if minEvenFound {\n        result\
    \ = append(result, minEven)\n        result = append(result, minEvenIndex)\n \
    \   }\n\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var index int\n    for i, v := range arr {\n       \
    \ if v % 2 == 0 {\n            if min == 0 {\n                min = v\n      \
    \          index = i\n            } else if v < min {\n                min = v\n\
    \                index = i\n            }\n        }\n    }\n    if min == 0 {\n\
    \        return []int{}\n    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpl3z4nd_c_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpl3z4nd_c_test.go:73:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := -1\n  \
    \  minIndex := -1\n    for i, v := range arr {\n        if v % 2 == 0 {\n    \
    \        if min == -1 || v < min {\n                min = v\n                minIndex\
    \ = i\n            }\n        }\n    }\n    if min == -1 {\n        return []int{}\n\
    \    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n          \
    \      min = v\n                index = i\n            } else if v < min {\n \
    \               min = v\n                index = i\n            }\n        }\n\
    \    }\n    if min != 0 {\n        result = append(result, min)\n        result\
    \ = append(result, index)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpgyoxv8z6_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpgyoxv8z6_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    var minFound bool\n    for i, v := range arr {\n  \
    \      if v % 2 == 0 {\n            if !minFound {\n                min = v\n\
    \                minIndex = i\n                minFound = true\n            }\
    \ else if v < min {\n                min = v\n                minIndex = i\n \
    \           }\n        }\n    }\n    if minFound {\n        return []int{min,\
    \ minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v < min\
    \ {\n            min = v\n            index = i\n        }\n    }\n    if min\
    \ % 2 == 0 {\n        return []int{min, index}\n    }\n    return []int{}\n}\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpnjn9081w_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n\
    \                min = v\n                minIndex = i\n            } else if\
    \ v < min {\n                min = v\n                minIndex = i\n         \
    \   }\n        }\n    }\n    if len(result) > 0 {\n        result = append(result,\
    \ min)\n        result = append(result, minIndex)\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp7aufvh6u_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var min_index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                min_index\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    min_index = i\n            }\n        }\n    }\n    if min == 0 {\n     \
    \   return []int{}\n    }\n    return []int{min, min_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkyf_pi3o_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkyf_pi3o_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var res []int\n    var min int\n    var minIndex int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n          \
    \      min = v\n                minIndex = i\n            } else if v < min {\n\
    \                min = v\n                minIndex = i\n            }\n      \
    \  }\n    }\n    if min != 0 {\n        res = append(res, min)\n        res =\
    \ append(res, minIndex)\n    }\n    return res\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpezrodd5c_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpezrodd5c_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minEven int = -1\n    var minEvenIndex int\
    \ = -1\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if minEven\
    \ == -1 {\n                minEven = v\n                minEvenIndex = i\n   \
    \         } else if v < minEven {\n                minEven = v\n             \
    \   minEvenIndex = i\n            }\n        }\n    }\n    if minEven != -1 {\n\
    \        result = append(result, minEven)\n        result = append(result, minEvenIndex)\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n\
    \                min = v\n                minIndex = i\n            } else if\
    \ v < min {\n                min = v\n                minIndex = i\n         \
    \   }\n        }\n    }\n    if len(result) > 0 {\n        result = append(result,\
    \ min)\n        result = append(result, minIndex)\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp7aufvh6u_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := 10001\n\
    \    minIndex := -1\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if minIndex == -1 {\n        return []int{}\n    }\n    return []int{min, minIndex}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n       \
    \         min = v\n                minIndex = i\n            } else if v < min\
    \ {\n                min = v\n                minIndex = i\n            }\n  \
    \      }\n    }\n    if min != 0 {\n        result = append(result, min)\n   \
    \     result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp0wufju4e_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp0wufju4e_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return []int{}\n    }\n    return []int{min, minIndex}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpji4thvt8_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpji4thvt8_test.go:73:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var res []int\n    if len(arr) == 0 {\n        return res\n    }\n  \
    \  min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n        if v\
    \ % 2 == 0 && v < min {\n            min = v\n            minIndex = i\n     \
    \   }\n    }\n    if min % 2 == 0 {\n        res = append(res, min)\n        res\
    \ = append(res, minIndex)\n    }\n    return res\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp1o7splq1_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n\n    if minFound {\n   \
    \     return []int{min, minIndex}\n    }\n\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var min_index int\n    var min_found bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !min_found {\n   \
    \             min = v\n                min_index = i\n                min_found\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       min_index = i\n            }\n        }\n    }\n    if min_found {\n \
    \       return []int{min, min_index}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIndex int\n    var minEvenFound bool\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minEvenFound\
    \ {\n                minEven = v\n                minEvenIndex = i\n         \
    \       minEvenFound = true\n            } else if v < minEven {\n           \
    \     minEven = v\n                minEvenIndex = i\n            }\n        }\n\
    \    }\n    if minEvenFound {\n        return []int{minEven, minEvenIndex}\n \
    \   }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n  \
    \              min = v\n                index = i\n            } else if v < min\
    \ {\n                min = v\n                index = i\n            }\n     \
    \   }\n    }\n    if len(result) > 0 {\n        result = append(result, min)\n\
    \        result = append(result, index)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp8ee55o2n_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp8ee55o2n_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp8ee55o2n_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var minFound\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minFound\
    \ {\n                min = v\n                minIndex = i\n                minFound\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minFound {\n   \
    \     result = append(result, min)\n        result = append(result, minIndex)\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var found\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !found\
    \ {\n                min = v\n                minIndex = i\n                found\
    \ = true\n            } else {\n                if v < min {\n               \
    \     min = v\n                    minIndex = i\n                }\n         \
    \   }\n        }\n    }\n    if found {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    minEven := -1\n\
    \    minEvenIndex := -1\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if minEven == -1 || v < minEven {\n                minEven = v\n\
    \                minEvenIndex = i\n            }\n        }\n    }\n    if minEven\
    \ == -1 {\n        return []int{}\n    }\n    return []int{minEven, minEvenIndex}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var minEven int\n\
    \    var minEvenIndex int\n    for i, v := range arr {\n        if v % 2 == 0\
    \ {\n            if minEven == 0 {\n                minEven = v\n            \
    \    minEvenIndex = i\n            } else if v < minEven {\n                minEven\
    \ = v\n                minEvenIndex = i\n            }\n        }\n    }\n   \
    \ if minEven == 0 {\n        return []int{}\n    }\n    return []int{minEven,\
    \ minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp12qgzh0f_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp12qgzh0f_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n     \
    \   if v % 2 == 0 && v < min {\n            min = v\n            minIndex = i\n\
    \        }\n    }\n    if min % 2 == 0 {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp_zqfg_jj_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v < min && v % 2 ==\
    \ 0 {\n            min = v\n            minIndex = i\n        }\n    }\n    if\
    \ min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpekd4ks5k_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n  \
    \              min = v\n                index = i\n            } else if v < min\
    \ {\n                min = v\n                index = i\n            }\n     \
    \   }\n    }\n    if len(result) > 0 {\n        result = append(result, min)\n\
    \        result = append(result, index)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp8ee55o2n_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp8ee55o2n_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp8ee55o2n_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var minEven int\n\
    \    var minEvenIndex int\n    for i, v := range arr {\n        if v % 2 == 0\
    \ {\n            if minEven == 0 {\n                minEven = v\n            \
    \    minEvenIndex = i\n            } else if v < minEven {\n                minEven\
    \ = v\n                minEvenIndex = i\n            }\n        }\n    }\n   \
    \ if minEven == 0 {\n        return []int{}\n    }\n    return []int{minEven,\
    \ minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp12qgzh0f_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp12qgzh0f_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return result\n    }\n    result = append(result, min)\n   \
    \ result = append(result, minIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpm681is2e_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpm681is2e_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min = arr[0]\n    var minIndex = 0\n    for i, v := range arr {\n\
    \        if v % 2 == 0 && v < min {\n            min = v\n            minIndex\
    \ = i\n        }\n    }\n    if min % 2 == 0 {\n        result = append(result,\
    \ min)\n        result = append(result, minIndex)\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpwem5_bcw_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ != 0 {\n        result = append(result, min)\n        result = append(result,\
    \ minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp45p9a2wk_test.go:78: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp45p9a2wk_test.go:78:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var index int\n    for i, v := range arr {\n       \
    \ if v % 2 == 0 {\n            if min == 0 {\n                min = v\n      \
    \          index = i\n            } else if v < min {\n                min = v\n\
    \                index = i\n            }\n        }\n    }\n    if min == 0 {\n\
    \        return []int{}\n    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpl3z4nd_c_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpl3z4nd_c_test.go:73:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var isFirst\
    \ bool = true\n    for i, v := range arr {\n        if v % 2 == 0 {\n        \
    \    if isFirst {\n                min = v\n                minIndex = i\n   \
    \             isFirst = false\n            } else {\n                if v < min\
    \ {\n                    min = v\n                    minIndex = i\n         \
    \       }\n            }\n        }\n    }\n    if !isFirst {\n        result\
    \ = append(result, min)\n        result = append(result, minIndex)\n    }\n  \
    \  return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIndex int\n    var minEvenFound bool\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minEvenFound\
    \ {\n                minEven = v\n                minEvenIndex = i\n         \
    \       minEvenFound = true\n            } else if v < minEven {\n           \
    \     minEven = v\n                minEvenIndex = i\n            }\n        }\n\
    \    }\n    if minEvenFound {\n        return []int{minEven, minEvenIndex}\n \
    \   }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n     \
    \   if v % 2 == 0 && v < min {\n            min = v\n            minIndex = i\n\
    \        }\n    }\n    if min % 2 == 0 {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp_zqfg_jj_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n\
    \                min = v\n                minIndex = i\n            } else if\
    \ v < min {\n                min = v\n                minIndex = i\n         \
    \   }\n        }\n    }\n    if len(result) == 0 {\n        return result\n  \
    \  }\n    result = append(result, min)\n    result = append(result, minIndex)\n\
    \    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpak3rsxlx_test.go:76: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpak3rsxlx_test.go:76:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmpak3rsxlx_test.go:76: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpak3rsxlx_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpak3rsxlx_test.go:76: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpak3rsxlx_test.go:76:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var res []int\n    if len(arr) == 0 {\n        return res\n    }\n  \
    \  min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n        if v\
    \ % 2 == 0 && v < min {\n            min = v\n            minIndex = i\n     \
    \   }\n    }\n    if min % 2 == 0 {\n        res = append(res, min)\n        res\
    \ = append(res, minIndex)\n    }\n    return res\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp1o7splq1_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minEven int\n    var minEvenIndex int\n   \
    \ for i, v := range arr {\n        if v % 2 == 0 {\n            if minEven ==\
    \ 0 {\n                minEven = v\n                minEvenIndex = i\n       \
    \     } else if v < minEven {\n                minEven = v\n                minEvenIndex\
    \ = i\n            }\n        }\n    }\n    if minEven != 0 {\n        result\
    \ = append(result, minEven)\n        result = append(result, minEvenIndex)\n \
    \   }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp5amystct_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp5amystct_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n          \
    \      min = v\n                index = i\n            } else if v < min {\n \
    \               min = v\n                index = i\n            }\n        }\n\
    \    }\n    if min != 0 {\n        result = append(result, min)\n        result\
    \ = append(result, index)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpgyoxv8z6_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpgyoxv8z6_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min = -1\n\
    \    var minIndex = -1\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == -1 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == -1 {\n     \
    \   return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n       \
    \         min = v\n                minIndex = i\n            } else if v < min\
    \ {\n                min = v\n                minIndex = i\n            }\n  \
    \      }\n    }\n    if min != 0 {\n        result = append(result, min)\n   \
    \     result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp0wufju4e_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp0wufju4e_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n       \
    \         min = v\n                minIndex = i\n            } else if v < min\
    \ {\n                min = v\n                minIndex = i\n            }\n  \
    \      }\n    }\n    if min != 0 {\n        result = append(result, min)\n   \
    \     result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp0wufju4e_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp0wufju4e_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v < min && v % 2 ==\
    \ 0 {\n            min = v\n            minIndex = i\n        }\n    }\n    if\
    \ min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpekd4ks5k_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIndex int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if minEven == 0 {\n                minEven\
    \ = v\n                minEvenIndex = i\n            } else if v < minEven {\n\
    \                minEven = v\n                minEvenIndex = i\n            }\n\
    \        }\n    }\n    if minEven == 0 {\n        return []int{}\n    }\n    return\
    \ []int{minEven, minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpmhmj56st_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpmhmj56st_test.go:73:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIdx int\n    var minEvenFound bool\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minEvenFound\
    \ {\n                minEven = v\n                minEvenIdx = i\n           \
    \     minEvenFound = true\n            } else if v < minEven {\n             \
    \   minEven = v\n                minEvenIdx = i\n            }\n        }\n  \
    \  }\n    if minEvenFound {\n        return []int{minEven, minEvenIdx}\n    }\n\
    \    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var minEven, minEvenIndex\
    \ int\n    minEven = -1\n    minEvenIndex = -1\n    for i, v := range arr {\n\
    \        if v % 2 == 0 {\n            if minEven == -1 {\n                minEven\
    \ = v\n                minEvenIndex = i\n            } else if v < minEven {\n\
    \                minEven = v\n                minEvenIndex = i\n            }\n\
    \        }\n    }\n    if minEven == -1 {\n        return []int{}\n    }\n   \
    \ return []int{minEven, minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v < min && v % 2 ==\
    \ 0 {\n            min = v\n            minIndex = i\n        }\n    }\n    if\
    \ min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpekd4ks5k_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return []int{}\n    }\n    return []int{min, minIndex}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpji4thvt8_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpji4thvt8_test.go:73:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var index int\n    var found bool\n\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if !found {\n            \
    \    min = v\n                index = i\n                found = true\n      \
    \      } else if v < min {\n                min = v\n                index = i\n\
    \            }\n        }\n    }\n\n    if found {\n        return []int{min,\
    \ index}\n    }\n\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n     \
    \   if v % 2 == 0 && v < min {\n            min = v\n            minIndex = i\n\
    \        }\n    }\n    if min % 2 == 0 {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp_zqfg_jj_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return result\n    }\n    result = append(result, min)\n   \
    \ result = append(result, minIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpm681is2e_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpm681is2e_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var smallestEven int\n    var smallestEvenIndex int\n    var smallestEvenFound\
    \ bool\n\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if\
    \ !smallestEvenFound {\n                smallestEven = v\n                smallestEvenIndex\
    \ = i\n                smallestEvenFound = true\n            } else if v < smallestEven\
    \ {\n                smallestEven = v\n                smallestEvenIndex = i\n\
    \            }\n        }\n    }\n\n    if smallestEvenFound {\n        return\
    \ []int{smallestEven, smallestEvenIndex}\n    }\n\n    return []int{}\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n\
    \                min = v\n                minIndex = i\n            } else if\
    \ v < min {\n                min = v\n                minIndex = i\n         \
    \   }\n        }\n    }\n    if len(result) > 0 {\n        result = append(result,\
    \ min)\n        result = append(result, minIndex)\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp7aufvh6u_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var res []int\n    if len(arr) == 0 {\n        return res\n    }\n  \
    \  var min int\n    var minIndex int\n    for i, v := range arr {\n        if\
    \ v % 2 == 0 {\n            if min == 0 {\n                min = v\n         \
    \       minIndex = i\n            } else if v < min {\n                min = v\n\
    \                minIndex = i\n            }\n        }\n    }\n    if min ==\
    \ 0 {\n        return res\n    }\n    res = append(res, min)\n    res = append(res,\
    \ minIndex)\n    return res\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpqmpqt0pd_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpqmpqt0pd_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // your code here\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmph90rt9o5_test.go:58: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmph90rt9o5_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmph90rt9o5_test.go:58: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmph90rt9o5_test.go:58:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmph90rt9o5_test.go:58: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmph90rt9o5_test.go:58:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var minEven int\n\
    \    var minEvenIndex int\n    for i, v := range arr {\n        if v % 2 == 0\
    \ {\n            if minEven == 0 {\n                minEven = v\n            \
    \    minEvenIndex = i\n            } else if v < minEven {\n                minEven\
    \ = v\n                minEvenIndex = i\n            }\n        }\n    }\n   \
    \ if minEven == 0 {\n        return []int{}\n    }\n    return []int{minEven,\
    \ minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp12qgzh0f_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp12qgzh0f_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n          \
    \      min = v\n                index = i\n            } else if v < min {\n \
    \               min = v\n                index = i\n            }\n        }\n\
    \    }\n    if min != 0 {\n        result = append(result, min)\n        result\
    \ = append(result, index)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpgyoxv8z6_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpgyoxv8z6_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int = -1\n    var minIndex int = -1\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if minIndex == -1 {\n              \
    \  min = v\n                minIndex = i\n            } else if v < min {\n  \
    \              min = v\n                minIndex = i\n            }\n        }\n\
    \    }\n    if minIndex == -1 {\n        return []int{}\n    }\n    return []int{min,\
    \ minIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var res []int\n    var min int\n    var minIndex int\n    var minFound\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minFound\
    \ {\n                min = v\n                minIndex = i\n                minFound\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minFound {\n   \
    \     res = append(res, min)\n        res = append(res, minIndex)\n    }\n   \
    \ return res\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v < min && v % 2 ==\
    \ 0 {\n            min = v\n            minIndex = i\n        }\n    }\n    if\
    \ min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpekd4ks5k_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n  \
    \              min = v\n                index = i\n            } else if v < min\
    \ {\n                min = v\n                index = i\n            }\n     \
    \   }\n    }\n    if len(result) > 0 {\n        result = append(result, min)\n\
    \        result = append(result, index)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp8ee55o2n_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp8ee55o2n_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp8ee55o2n_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp8ee55o2n_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    var found bool\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if !found {\n\
    \                min = v\n                index = i\n                found = true\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if found {\n        result = append(result,\
    \ min)\n        result = append(result, index)\n    }\n    return result\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n\
    \                min = v\n                minIndex = i\n            } else if\
    \ v < min {\n                min = v\n                minIndex = i\n         \
    \   }\n        }\n    }\n    if len(result) > 0 {\n        result = append(result,\
    \ min)\n        result = append(result, minIndex)\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp7aufvh6u_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ != 0 {\n        result = append(result, min)\n        result = append(result,\
    \ minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp45p9a2wk_test.go:78: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp45p9a2wk_test.go:78:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var minExists\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minExists\
    \ {\n                min = v\n                minIndex = i\n                minExists\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minExists {\n  \
    \      result = append(result, min)\n        result = append(result, minIndex)\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var min_index int\n    var min_found bool\n    for i, v := range arr {\n\
    \        if v % 2 == 0 {\n            if !min_found {\n                min = v\n\
    \                min_index = i\n                min_found = true\n           \
    \ } else {\n                if v < min {\n                    min = v\n      \
    \              min_index = i\n                }\n            }\n        }\n  \
    \  }\n    if min_found {\n        return []int{min, min_index}\n    }\n    return\
    \ []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIndex int\n    var minEvenFound bool\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minEvenFound\
    \ {\n                minEven = v\n                minEvenIndex = i\n         \
    \       minEvenFound = true\n            } else if v < minEven {\n           \
    \     minEven = v\n                minEvenIndex = i\n            }\n        }\n\
    \    }\n    if minEvenFound {\n        return []int{minEven, minEvenIndex}\n \
    \   }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := -1\n  \
    \  minIndex := -1\n    for index, value := range arr {\n        if value % 2 ==\
    \ 0 {\n            if min == -1 || value < min {\n                min = value\n\
    \                minIndex = index\n            }\n        }\n    }\n    if min\
    \ == -1 {\n        return []int{}\n    }\n    return []int{min, minIndex}\n}\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n       \
    \         min = v\n                minIndex = i\n            } else if v < min\
    \ {\n                min = v\n                minIndex = i\n            }\n  \
    \      }\n    }\n    if min != 0 {\n        result = append(result, min)\n   \
    \     result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp0wufju4e_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp0wufju4e_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minEven int\n    var minEvenIndex int\n   \
    \ for i, v := range arr {\n        if v % 2 == 0 {\n            if minEven ==\
    \ 0 {\n                minEven = v\n                minEvenIndex = i\n       \
    \     } else if v < minEven {\n                minEven = v\n                minEvenIndex\
    \ = i\n            }\n        }\n    }\n    if minEven != 0 {\n        result\
    \ = append(result, minEven)\n        result = append(result, minEvenIndex)\n \
    \   }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp5amystct_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp5amystct_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n     \
    \   if v % 2 == 0 && v < min {\n            min = v\n            minIndex = i\n\
    \        }\n    }\n    if min % 2 == 0 {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp_zqfg_jj_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIndex int\n    var minEvenFound bool\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minEvenFound\
    \ {\n                minEven = v\n                minEvenIndex = i\n         \
    \       minEvenFound = true\n            } else if v < minEven {\n           \
    \     minEven = v\n                minEvenIndex = i\n            }\n        }\n\
    \    }\n    if minEvenFound {\n        return []int{minEven, minEvenIndex}\n \
    \   }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var smallestEven int\n    var smallestEvenIndex int\n    var smallestEvenFound\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !smallestEvenFound\
    \ {\n                smallestEven = v\n                smallestEvenIndex = i\n\
    \                smallestEvenFound = true\n            } else if v < smallestEven\
    \ {\n                smallestEven = v\n                smallestEvenIndex = i\n\
    \            }\n        }\n    }\n    if smallestEvenFound {\n        return []int{smallestEven,\
    \ smallestEvenIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var minFound\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minFound\
    \ {\n                min = v\n                minIndex = i\n                minFound\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minFound {\n   \
    \     result = append(result, min)\n        result = append(result, minIndex)\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var smallestEven\
    \ int\n    var smallestEvenIndex int\n    for i, v := range arr {\n        if\
    \ v % 2 == 0 {\n            if smallestEven == 0 {\n                smallestEven\
    \ = v\n                smallestEvenIndex = i\n            } else if v < smallestEven\
    \ {\n                smallestEven = v\n                smallestEvenIndex = i\n\
    \            }\n        }\n    }\n    if smallestEven == 0 {\n        return []int{}\n\
    \    }\n    return []int{smallestEven, smallestEvenIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpwkucuuf2_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpwkucuuf2_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIndex int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if minEven == 0 {\n                minEven\
    \ = v\n                minEvenIndex = i\n            } else if v < minEven {\n\
    \                minEven = v\n                minEvenIndex = i\n            }\n\
    \        }\n    }\n    if minEven == 0 {\n        return []int{}\n    }\n    return\
    \ []int{minEven, minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpmhmj56st_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpmhmj56st_test.go:73:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n          \
    \      min = v\n                index = i\n            } else if v < min {\n \
    \               min = v\n                index = i\n            }\n        }\n\
    \    }\n    if min != 0 {\n        result = append(result, min)\n        result\
    \ = append(result, index)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpgyoxv8z6_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpgyoxv8z6_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var evens []int\n    for _, v := range arr {\n        if v % 2 == 0 {\n\
    \            evens = append(evens, v)\n        }\n    }\n    if len(evens) ==\
    \ 0 {\n        return []int{}\n    }\n    min := evens[0]\n    for _, v := range\
    \ evens {\n        if v < min {\n            min = v\n        }\n    }\n    for\
    \ i, v := range arr {\n        if v == min {\n            return []int{min, i}\n\
    \        }\n    }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var minFound\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minFound\
    \ {\n                min = v\n                minIndex = i\n                minFound\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minFound {\n   \
    \     result = append(result, min)\n        result = append(result, minIndex)\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v < min && v % 2 ==\
    \ 0 {\n            min = v\n            minIndex = i\n        }\n    }\n    if\
    \ min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpekd4ks5k_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return result\n    }\n    result = append(result, min)\n   \
    \ result = append(result, minIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpm681is2e_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpm681is2e_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var minEven int\n\
    \    var minEvenIndex int\n    for i, v := range arr {\n        if v % 2 == 0\
    \ {\n            if minEven == 0 {\n                minEven = v\n            \
    \    minEvenIndex = i\n            } else if v < minEven {\n                minEven\
    \ = v\n                minEvenIndex = i\n            }\n        }\n    }\n   \
    \ if minEven == 0 {\n        return []int{}\n    }\n    return []int{minEven,\
    \ minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp12qgzh0f_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp12qgzh0f_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var evens []int\n    var evensIndex []int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            evens = append(evens, v)\n         \
    \   evensIndex = append(evensIndex, i)\n        }\n    }\n    if len(evens) ==\
    \ 0 {\n        return []int{}\n    }\n    min := evens[0]\n    minIndex := evensIndex[0]\n\
    \    for i, v := range evens {\n        if v < min {\n            min = v\n  \
    \          minIndex = evensIndex[i]\n        }\n    }\n    return []int{min, minIndex}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var result []int\n\
    \    var min int\n    for i, v := range arr {\n        if v % 2 == 0 {\n     \
    \       if len(result) == 0 {\n                result = []int{v, i}\n        \
    \        min = v\n            } else if v < min {\n                result = []int{v,\
    \ i}\n                min = v\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var found bool\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if !found {\n            \
    \    min = v\n                minIndex = i\n                found = true\n   \
    \         } else if v < min {\n                min = v\n                minIndex\
    \ = i\n            }\n        }\n    }\n    if found {\n        return []int{min,\
    \ minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n\
    \                min = v\n                minIndex = i\n            } else if\
    \ v < min {\n                min = v\n                minIndex = i\n         \
    \   }\n        }\n    }\n    if len(result) > 0 {\n        result = append(result,\
    \ min)\n        result = append(result, minIndex)\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp7aufvh6u_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if len(result) == 0 {\n\
    \                min = v\n                minIndex = i\n            } else if\
    \ v < min {\n                min = v\n                minIndex = i\n         \
    \   }\n        }\n    }\n    if len(result) > 0 {\n        result = append(result,\
    \ min)\n        result = append(result, minIndex)\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp7aufvh6u_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmp7aufvh6u_test.go:75: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp7aufvh6u_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n     \
    \   if v % 2 == 0 && v < min {\n            min = v\n            minIndex = i\n\
    \        }\n    }\n    if min % 2 == 0 {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp_zqfg_jj_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minEven int\n    var minEvenIndex int\n    var minEvenFound bool\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minEvenFound\
    \ {\n                minEven = v\n                minEvenIndex = i\n         \
    \       minEvenFound = true\n            } else if v < minEven {\n           \
    \     minEven = v\n                minEvenIndex = i\n            }\n        }\n\
    \    }\n    if minEvenFound {\n        return []int{minEven, minEvenIndex}\n \
    \   }\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return result\n    }\n    result = append(result, min)\n   \
    \ result = append(result, minIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpm681is2e_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpm681is2e_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // your code here\n    return []int{}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmph90rt9o5_test.go:58: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    \    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmph90rt9o5_test.go:58:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[]'\n    --- FAIL: TestPluck/test_num__3\
    \ (0.00s)\n        tmph90rt9o5_test.go:58: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmph90rt9o5_test.go:58:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmph90rt9o5_test.go:58: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmph90rt9o5_test.go:58:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var minEven int\n    var minEvenIndex int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if minEven == 0 {\n                minEven\
    \ = v\n                minEvenIndex = i\n            } else if v < minEven {\n\
    \                minEven = v\n                minEvenIndex = i\n            }\n\
    \        }\n    }\n    if minEven == 0 {\n        return result\n    }\n    result\
    \ = append(result, minEven)\n    result = append(result, minEvenIndex)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpxkbssmbb_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpxkbssmbb_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ != 0 {\n        result = append(result, min)\n        result = append(result,\
    \ minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp45p9a2wk_test.go:78: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp45p9a2wk_test.go:78:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var minEven int\n    var minEvenIndex int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if minEven == 0 {\n                minEven\
    \ = v\n                minEvenIndex = i\n            } else if v < minEven {\n\
    \                minEven = v\n                minEvenIndex = i\n            }\n\
    \        }\n    }\n    if minEven == 0 {\n        return result\n    }\n    result\
    \ = append(result, minEven)\n    result = append(result, minEvenIndex)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpxkbssmbb_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpxkbssmbb_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return result\n    }\n    result = append(result, min)\n   \
    \ result = append(result, minIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpm681is2e_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpm681is2e_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var minEven int\n    var minEvenIndex int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            if minEven == 0 {\n                minEven\
    \ = v\n                minEvenIndex = i\n            } else if v < minEven {\n\
    \                minEven = v\n                minEvenIndex = i\n            }\n\
    \        }\n    }\n    if minEven == 0 {\n        return result\n    }\n    result\
    \ = append(result, minEven)\n    result = append(result, minEvenIndex)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpxkbssmbb_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpxkbssmbb_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var res []int\n    if len(arr) == 0 {\n        return res\n    }\n  \
    \  var min int\n    var minIndex int\n    for i, v := range arr {\n        if\
    \ v % 2 == 0 {\n            if min == 0 {\n                min = v\n         \
    \       minIndex = i\n            } else if v < min {\n                min = v\n\
    \                minIndex = i\n            }\n        }\n    }\n    if min ==\
    \ 0 {\n        return res\n    }\n    res = append(res, min)\n    res = append(res,\
    \ minIndex)\n    return res\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpqmpqt0pd_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpqmpqt0pd_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var found\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !found\
    \ {\n                min = v\n                minIndex = i\n                found\
    \ = true\n            } else {\n                if v < min {\n               \
    \     min = v\n                    minIndex = i\n                }\n         \
    \   }\n        }\n    }\n    if found {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n       \
    \         min = v\n                minIndex = i\n            } else if v < min\
    \ {\n                min = v\n                minIndex = i\n            }\n  \
    \      }\n    }\n    if min != 0 {\n        result = append(result, min)\n   \
    \     result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp0wufju4e_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp0wufju4e_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min, index int\n    for i, v := range arr {\n        if v % 2 ==\
    \ 0 {\n            if min == 0 {\n                min = v\n                index\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    index = i\n            }\n        }\n    }\n    if min == 0 {\n        return\
    \ []int{}\n    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpg8nvnn3s_test.go:72: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpg8nvnn3s_test.go:72:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := arr[0]\n    for _, v := range arr {\n        if v % 2 == 0 &&\
    \ v < min {\n            min = v\n        }\n    }\n    if min % 2 != 0 {\n  \
    \      return result\n    }\n    for i, v := range arr {\n        if v == min\
    \ {\n            result = append(result, min, i)\n            return result\n\
    \        }\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpl6te0lmt_test.go:76: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return result\n    }\n    result = append(result, min)\n   \
    \ result = append(result, minIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpm681is2e_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpm681is2e_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := -1\n    minIndex := -1\n    for i, v := range arr {\n        if\
    \ v % 2 == 0 {\n            if min == -1 {\n                min = v\n        \
    \        minIndex = i\n            } else if v < min {\n                min =\
    \ v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == -1 {\n        return result\n    }\n    result = append(result, min)\n  \
    \  result = append(result, minIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074262
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var minEven =\
    \ -1\n    var minEvenIndex = -1\n    for i, v := range arr {\n        if v % 2\
    \ == 0 {\n            if minEven == -1 {\n                minEven = v\n      \
    \          minEvenIndex = i\n            } else if v < minEven {\n           \
    \     minEven = v\n                minEvenIndex = i\n            }\n        }\n\
    \    }\n    if minEven == -1 {\n        return []int{}\n    }\n    return []int{minEven,\
    \ minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074262
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var found\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !found\
    \ {\n                min = v\n                minIndex = i\n                found\
    \ = true\n            } else {\n                if v < min {\n               \
    \     min = v\n                    minIndex = i\n                }\n         \
    \   }\n        }\n    }\n    if found {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minEven int\n    var minEvenIndex int\n   \
    \ for i, v := range arr {\n        if v % 2 == 0 {\n            if minEven ==\
    \ 0 {\n                minEven = v\n                minEvenIndex = i\n       \
    \     } else if v < minEven {\n                minEven = v\n                minEvenIndex\
    \ = i\n            }\n        }\n    }\n    if minEven != 0 {\n        result\
    \ = append(result, minEven)\n        result = append(result, minEvenIndex)\n \
    \   }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp5amystct_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp5amystct_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    var count int\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if count ==\
    \ 0 {\n                min = v\n                index = i\n                count++\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if count > 0 {\n        result = append(result,\
    \ min)\n        result = append(result, index)\n    }\n    return result\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var minEven int\n\
    \    var minEvenIndex int\n    for i, v := range arr {\n        if v % 2 == 0\
    \ {\n            if minEven == 0 {\n                minEven = v\n            \
    \    minEvenIndex = i\n            } else if v < minEven {\n                minEven\
    \ = v\n                minEvenIndex = i\n            }\n        }\n    }\n   \
    \ if minEven == 0 {\n        return []int{}\n    }\n    return []int{minEven,\
    \ minEvenIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp12qgzh0f_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp12qgzh0f_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var minIndex int\n    for i, v := range arr {\n        if v % 2 == 0 {\n\
    \            if min == 0 {\n                min = v\n                minIndex\
    \ = i\n            } else if v < min {\n                min = v\n            \
    \    minIndex = i\n            }\n        }\n    }\n    if min == 0 {\n      \
    \  return []int{}\n    }\n    return []int{min, minIndex}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpayy2951z_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpayy2951z_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ == 0 {\n        return result\n    }\n    result = append(result, min)\n   \
    \ result = append(result, minIndex)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpm681is2e_test.go:79: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpm681is2e_test.go:79:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := -1\n  \
    \  index := -1\n    for i, v := range arr {\n        if v % 2 == 0 {\n       \
    \     if min == -1 || v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == -1 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var min int\n    var minIndex int\n    var minFound bool\n    for i,\
    \ v := range arr {\n        if v % 2 == 0 {\n            if !minFound {\n    \
    \            min = v\n                minIndex = i\n                minFound =\
    \ true\n            } else if v < min {\n                min = v\n           \
    \     minIndex = i\n            }\n        }\n    }\n    if minFound {\n     \
    \   return []int{min, minIndex}\n    }\n    return []int{}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v < min\
    \ {\n            min = v\n            index = i\n        }\n    }\n    if min\
    \ % 2 == 0 {\n        return []int{min, index}\n    }\n    return []int{}\n}\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpnjn9081w_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n       \
    \         min = v\n                minIndex = i\n            } else if v < min\
    \ {\n                min = v\n                minIndex = i\n            }\n  \
    \      }\n    }\n    if min != 0 {\n        result = append(result, min)\n   \
    \     result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp0wufju4e_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp0wufju4e_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v < min && v % 2 ==\
    \ 0 {\n            min = v\n            minIndex = i\n        }\n    }\n    if\
    \ min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpekd4ks5k_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var found\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !found\
    \ {\n                min = v\n                minIndex = i\n                found\
    \ = true\n            } else {\n                if v < min {\n               \
    \     min = v\n                    minIndex = i\n                }\n         \
    \   }\n        }\n    }\n    if found {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var minFound\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minFound\
    \ {\n                min = v\n                minIndex = i\n                minFound\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minFound {\n   \
    \     result = append(result, min)\n        result = append(result, minIndex)\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var minFound\
    \ bool\n\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if\
    \ !minFound {\n                min = v\n                minIndex = i\n       \
    \         minFound = true\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n\n    if\
    \ minFound {\n        result = append(result, min)\n        result = append(result,\
    \ minIndex)\n    }\n\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var index int\n    for i, v :=\
    \ range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n          \
    \      min = v\n                index = i\n            } else if v < min {\n \
    \               min = v\n                index = i\n            }\n        }\n\
    \    }\n    if min != 0 {\n        result = append(result, min)\n        result\
    \ = append(result, index)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpgyoxv8z6_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpgyoxv8z6_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    for i, v := range arr {\n        if v % 2 == 0 {\n \
    \           if min == 0 {\n                min = v\n                result = []int{min,\
    \ i}\n            } else if v < min {\n                min = v\n             \
    \   result = []int{min, i}\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp_0bycydd_test.go:73: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074262
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    var min int\n    var minIndex int\n    for i, v := range arr {\n    \
    \    if v % 2 == 0 {\n            if min == 0 {\n                min = v\n   \
    \             minIndex = i\n            } else if v < min {\n                min\
    \ = v\n                minIndex = i\n            }\n        }\n    }\n    if min\
    \ != 0 {\n        result = append(result, min)\n        result = append(result,\
    \ minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp45p9a2wk_test.go:78: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp45p9a2wk_test.go:78:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    if len(arr) == 0 {\n        return result\n   \
    \ }\n    min := arr[0]\n    minIndex := 0\n    for i, v := range arr {\n     \
    \   if v % 2 == 0 && v < min {\n            min = v\n            minIndex = i\n\
    \        }\n    }\n    if min % 2 == 0 {\n        result = append(result, min)\n\
    \        result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp_zqfg_jj_test.go:73: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074260
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    var minFound\
    \ bool\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if !minFound\
    \ {\n                min = v\n                minIndex = i\n                minFound\
    \ = true\n            } else if v < min {\n                min = v\n         \
    \       minIndex = i\n            }\n        }\n    }\n    if minFound {\n   \
    \     result = append(result, min)\n        result = append(result, minIndex)\n\
    \    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var min int\n    var minIndex int\n    for i, v\
    \ := range arr {\n        if v % 2 == 0 {\n            if min == 0 {\n       \
    \         min = v\n                minIndex = i\n            } else if v < min\
    \ {\n                min = v\n                minIndex = i\n            }\n  \
    \      }\n    }\n    if min != 0 {\n        result = append(result, min)\n   \
    \     result = append(result, minIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmp0wufju4e_test.go:75: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmp0wufju4e_test.go:75:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    minIndex := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min {\n            min = v\n            minIndex = i\n        }\n    }\n   \
    \ if min % 2 == 0 {\n        return []int{min, minIndex}\n    }\n    return []int{}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmpj0x6j594_test.go:71: expected '[%!s(int=2) %!s(int=1)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    var min int\n\
    \    var index int\n    for i, v := range arr {\n        if v % 2 == 0 {\n   \
    \         if min == 0 {\n                min = v\n                index = i\n\
    \            } else if v < min {\n                min = v\n                index\
    \ = i\n            }\n        }\n    }\n    if min == 0 {\n        return []int{}\n\
    \    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpkfbiv9wr_test.go:76: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=5)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpkfbiv9wr_test.go:76:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074258
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var evens []int\n    var evensIndex []int\n    for i, v := range arr\
    \ {\n        if v % 2 == 0 {\n            evens = append(evens, v)\n         \
    \   evensIndex = append(evensIndex, i)\n        }\n    }\n    if len(evens) ==\
    \ 0 {\n        return []int{}\n    }\n    min := evens[0]\n    minIndex := evensIndex[0]\n\
    \    for i, v := range evens {\n        if v < min {\n            min = v\n  \
    \          minIndex = evensIndex[i]\n        }\n    }\n    return []int{min, minIndex}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
- exit_code: 0
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minEven int = 10001\n    var minEvenIndex int\
    \ = 10001\n    for i, v := range arr {\n        if v % 2 == 0 && v < minEven {\n\
    \            minEven = v\n            minEvenIndex = i\n        }\n    }\n   \
    \ if minEven < 10001 {\n        result = append(result, minEven)\n        result\
    \ = append(result, minEvenIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074262
