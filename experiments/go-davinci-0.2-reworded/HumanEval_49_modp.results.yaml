language: go_test.go
name: HumanEval_49_modp
results:
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmphxzfj7qd_test.go:50: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmphxzfj7qd_test.go:50: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmphxzfj7qd_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmphxzfj7qd_test.go:50: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    r := modp(n/2, p)\n    r = (r * r) % p\n    if n % 2 == 1 {\n    \
    \    r = (r * 2) % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return (modp(n/2, p) * modp(n/2, p)) % p\n    }\n    return (modp(n/2, p) *\
    \ modp(n/2, p) * 2) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpxbu6cqic_test.go:51: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpxbu6cqic_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=61)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpxbu6cqic_test.go:51: expected '%!s(int=8)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpxbu6cqic_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=78)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * modp(1, p) % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0?, 0x5)\n\
    \t/tmp/tmpko_rte_g_test.go:19 +0x10d fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef76d\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0x9d\
    \ fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6fd\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0438 sp=0xc0201e0408 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e04c8 sp=0xc0201e0498 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0558 sp=0xc0201e0528 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0588 sp=0xc0201e0558 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e05b8 sp=0xc0201e0588 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e05e8 sp=0"
  timestamp: 1660074780
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        return modp(n+p,\
    \ p)\n    }\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n     \
    \   return n\n    }\n    if n%2 == 0 {\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p\n    }\n    return modp(n/2, p) * modp(n/2, p) * n % p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpv00atxx7_test.go:54: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpv00atxx7_test.go:54: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpv00atxx7_test.go:54: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpv00atxx7_test.go:54: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return n * modp(n-1, p) % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp1bglm3hw_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp1bglm3hw_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp1bglm3hw_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp1bglm3hw_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp63ik8hha_test.go:51: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp63ik8hha_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=61)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp63ik8hha_test.go:51: expected '%!s(int=8)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp63ik8hha_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=78)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int = 1\n    for i\
    \ := 0; i < n; i++ {\n        result = (result * 2) % p\n    }\n    return result\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // n = n % p\n    // if n < 0:\n\
    \    //     n += p\n    // return n\n    return n % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp1q1pjp6l_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp1q1pjp6l_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp1q1pjp6l_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp1q1pjp6l_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp1q1pjp6l_test.go:46: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp1q1pjp6l_test.go:46: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    } else {\n        return modp(n/2, p) * modp(n/2, p) * 2 % p\n    }\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var r int\n    r = 1\n    for\
    \ n > 0 {\n        if n & 1 != 0 {\n            r = (r * 2) % p\n        }\n \
    \       n >>= 1\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmptrkinocx_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmptrkinocx_test.go:50: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmptrkinocx_test.go:50: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmptrkinocx_test.go:50: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmptrkinocx_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmptrkinocx_test.go:50: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return n * modp(n-1, p) % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp1bglm3hw_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp1bglm3hw_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp1bglm3hw_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp1bglm3hw_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (1 << uint(n)) % p\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpfwlgmfhi_test.go:42: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpfwlgmfhi_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * modp(1, p) % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0?, 0x5)\n\
    \t/tmp/tmpko_rte_g_test.go:19 +0x10d fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef76d\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0x9d\
    \ fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6fd\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0438 sp=0xc0201e0408 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e04c8 sp=0xc0201e0498 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0558 sp=0xc0201e0528 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0588 sp=0xc0201e0558 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e05b8 sp=0xc0201e0588 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e05e8 sp=0"
  timestamp: 1660074780
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n%2 == 0 {\n        return\
    \ modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpxt4497rv_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpxt4497rv_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpxt4497rv_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpxt4497rv_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * modp(1, p) % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0?, 0x5)\n\
    \t/tmp/tmpko_rte_g_test.go:19 +0x10d fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef76d\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0x9d\
    \ fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6fd\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0438 sp=0xc0201e0408 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e04c8 sp=0xc0201e0498 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e0558 sp=0xc0201e0528 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e0588 sp=0xc0201e0558 pc=0x4ef711\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1\
    \ fp=0xc0201e05b8 sp=0xc0201e0588 pc=0x4ef711\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmpko_rte_g_test.go:26 +0xb1 fp=0xc0201e05e8 sp=0"
  timestamp: 1660074780
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgal6j0hy_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgal6j0hy_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
