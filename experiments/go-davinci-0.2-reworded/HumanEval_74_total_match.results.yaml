language: go_test.go
name: HumanEval_74_total_match
results:
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var lst1_total_chars, lst2_total_chars int\n\
    \    for _, str := range lst1 {\n        lst1_total_chars += len(str)\n    }\n\
    \    for _, str := range lst2 {\n        lst2_total_chars += len(str)\n    }\n\
    \    if lst1_total_chars < lst2_total_chars {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpwgn017ik_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    if len(lst1) ==\
    \ len(lst2) {\n        return lst1\n    }\n    var sum1, sum2 int\n    for _,\
    \ v := range lst1 {\n        sum1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        sum2 += len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp5bn9bd7__test.go:69: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp5bn9bd7__test.go:69:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp5bn9bd7__test.go:69: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp5bn9bd7__test.go:69:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp5bn9bd7__test.go:69: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, v := range\
    \ lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n    \
    \    total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpq3w9kaql_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n   \
    \ }\n    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpdr66r3pn_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpdr66r3pn_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpdr66r3pn_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ s := range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2\
    \ {\n        total2 += len(s)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpc6kr4mw__test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpfvk8sgrq_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    var total1 int\n\
    \    var total2 int\n    for _, s := range lst1 {\n        total1 += len(s)\n\
    \    }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if\
    \ total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcgidb_xi_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpcgidb_xi_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpcgidb_xi_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ str := range lst1 {\n        total1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        total2 += len(str)\n    }\n    if total1 < total2 {\n      \
    \  return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpq5s_85se_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpfvk8sgrq_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    total1 := 0\n \
    \   total2 := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n    }\n\
    \    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1\
    \ == total2 {\n        return lst1\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpp20i6ou7_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpp20i6ou7_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpp20i6ou7_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    total1 := 0\n    total2 := 0\n    for _, str\
    \ := range lst1 {\n        total1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        total2 += len(str)\n    }\n    if total1 < total2 {\n      \
    \  return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmptk706cl4_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ == total2 {\n        return lst1\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmpc94vlv01_test.go:70: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpc94vlv01_test.go:70: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, str\
    \ := range lst1 {\n        total1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        total2 += len(str)\n    }\n    if total1 < total2 {\n      \
    \  return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2lx11r34_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int = 0\n    var total2 int = 0\n\
    \    for _, s := range lst1 {\n        total1 += len(s)\n    }\n    for _, s :=\
    \ range lst2 {\n        total2 += len(s)\n    }\n    if total1 < total2 {\n  \
    \      return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd9mkr7kg_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    total1 := 0\n \
    \   total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n    }\n\
    \    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpa9cac7sb_test.go:64: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // your code here\n    return nil\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp5635dxhf_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp5635dxhf_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp5635dxhf_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp5635dxhf_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp5635dxhf_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp5635dxhf_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    sum1 := 0\n  \
    \  sum2 := 0\n    for _, s := range lst1 {\n        sum1 += len(s)\n    }\n  \
    \  for _, s := range lst2 {\n        sum2 += len(s)\n    }\n    if sum1 < sum2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpv2mcng6o_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpv2mcng6o_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpv2mcng6o_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        total2 += len(v)\n    }\n    if total1 == total2 {\n        return\
    \ lst1\n    } else if total1 < total2 {\n        return lst1\n    } else {\n \
    \       return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpp20i6ou7_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpp20i6ou7_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpp20i6ou7_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ s := range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2\
    \ {\n        total2 += len(s)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpc6kr4mw__test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, s := range\
    \ lst1 {\n        sum1 += len(s)\n    }\n    for _, s := range lst2 {\n      \
    \  sum2 += len(s)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcqu1vh06_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, v := range\
    \ lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n    \
    \    total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpq3w9kaql_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpp20i6ou7_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpp20i6ou7_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpp20i6ou7_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n   \
    \ }\n    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpdr66r3pn_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpdr66r3pn_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpdr66r3pn_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 == total2 {\n        return\
    \ lst1\n    }\n    if total1 < total2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 <= total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, s :=\
    \ range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n\
    \        total2 += len(s)\n    }\n    if total1 <= total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpp20i6ou7_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpp20i6ou7_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpp20i6ou7_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ str := range lst1 {\n        total1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        total2 += len(str)\n    }\n    if total1 == total2 {\n     \
    \   return lst1\n    } else if total1 < total2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    total1 := 0\n \
    \   total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp8kxw1b74_test.go:64: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpfvk8sgrq_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return nil\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmprntfsi0w_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmprntfsi0w_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmprntfsi0w_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmprntfsi0w_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmprntfsi0w_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmprntfsi0w_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpfvk8sgrq_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var sum1, sum2 int\n    for _, s := range lst1\
    \ {\n        sum1 += len(s)\n    }\n    for _, s := range lst2 {\n        sum2\
    \ += len(s)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsr265o1l_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var lst1_total_chars int = 0\n    var lst2_total_chars\
    \ int = 0\n    for _, str := range lst1 {\n        lst1_total_chars += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        lst2_total_chars += len(str)\n\
    \    }\n    if lst1_total_chars < lst2_total_chars {\n        return lst1\n  \
    \  } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp8ke264b2_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var sum1, sum2 int\n    for _, s := range lst1\
    \ {\n        sum1 += len(s)\n    }\n    for _, s := range lst2 {\n        sum2\
    \ += len(s)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsr265o1l_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpp20i6ou7_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpp20i6ou7_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpp20i6ou7_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 <= total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmp0hgevtin_test.go:67: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0hgevtin_test.go:67: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    lst1_total :=\
    \ 0\n    lst2_total := 0\n    for _, s := range lst1 {\n        lst1_total +=\
    \ len(s)\n    }\n    for _, s := range lst2 {\n        lst2_total += len(s)\n\
    \    }\n    if lst1_total < lst2_total {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2_o_qpru_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2_o_qpru_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2_o_qpru_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n   \
    \ }\n    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpdr66r3pn_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpdr66r3pn_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpdr66r3pn_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, s :=\
    \ range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n\
    \        total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpu_foe234_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var lst1_total, lst2_total int\n    for _, v\
    \ := range lst1 {\n        lst1_total += len(v)\n    }\n    for _, v := range\
    \ lst2 {\n        lst2_total += len(v)\n    }\n    if lst1_total < lst2_total\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpe0rqzuc6_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 <= total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_chars1 := 0\n    total_chars2 := 0\n  \
    \  for _, str := range lst1 {\n        total_chars1 += len(str)\n    }\n    for\
    \ _, str := range lst2 {\n        total_chars2 += len(str)\n    }\n    if total_chars1\
    \ < total_chars2 {\n        return lst1\n    } else {\n        return lst2\n \
    \   }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpc9r5ay1s_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    var total1 int\n\
    \    var total2 int\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsobpuxuq_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpsobpuxuq_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpsobpuxuq_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    var total1 int\n\
    \    var total2 int\n    for _, v := range lst1 {\n        total1 += len(v)\n\
    \    }\n    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if\
    \ total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpkp39i06k_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpkp39i06k_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpkp39i06k_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // your code here\n    return nil\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp5635dxhf_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp5635dxhf_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp5635dxhf_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp5635dxhf_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp5635dxhf_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp5635dxhf_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, s :=\
    \ range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n\
    \        total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpu_foe234_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpp20i6ou7_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpp20i6ou7_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpp20i6ou7_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ <= total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmp3bxypphz_test.go:67: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp3bxypphz_test.go:67: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpfvk8sgrq_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    if len(lst1) ==\
    \ len(lst2) {\n        return lst1\n    }\n    var lst1_len, lst2_len int\n  \
    \  for _, v := range lst1 {\n        lst1_len += len(v)\n    }\n    for _, v :=\
    \ range lst2 {\n        lst2_len += len(v)\n    }\n    if lst1_len < lst2_len\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpjwkj1291_test.go:69: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpjwkj1291_test.go:69:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpjwkj1291_test.go:69: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpjwkj1291_test.go:69:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpjwkj1291_test.go:69: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 <= total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var lst1_total, lst2_total int\n    for _, s\
    \ := range lst1 {\n        lst1_total += len(s)\n    }\n    for _, s := range\
    \ lst2 {\n        lst2_total += len(s)\n    }\n    if lst1_total < lst2_total\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpjaeyi5_x_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpfvk8sgrq_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    sum1 := 0\n   \
    \ sum2 := 0\n    for _, s := range lst1 {\n        sum1 += len(s)\n    }\n   \
    \ for _, s := range lst2 {\n        sum2 += len(s)\n    }\n    if sum1 < sum2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqq4tph6m_test.go:64: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ v := range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        total2 += len(v)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    } else if total1 > total2 {\n        return lst2\n    } else {\n \
    \       return lst1\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074524
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // TODO: implement\n    return nil\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp7hap29v0_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp7hap29v0_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp7hap29v0_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp7hap29v0_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp7hap29v0_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp7hap29v0_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074524
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ str := range lst1 {\n        total1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        total2 += len(str)\n    }\n    if total1 < total2 {\n      \
    \  return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpq5s_85se_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    var total1 int\n\
    \    var total2 int\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsobpuxuq_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpsobpuxuq_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpsobpuxuq_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpp20i6ou7_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpp20i6ou7_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpp20i6ou7_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    total1 := 0\n \
    \   total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n    }\n\
    \    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpa9cac7sb_test.go:64: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n   \
    \ }\n    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpdr66r3pn_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpdr66r3pn_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpdr66r3pn_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpp20i6ou7_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpp20i6ou7_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpp20i6ou7_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    var total1 int\n\
    \    var total2 int\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsobpuxuq_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpsobpuxuq_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpsobpuxuq_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, s :=\
    \ range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n\
    \        total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpu_foe234_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var lst1_total, lst2_total int\n    for _, str\
    \ := range lst1 {\n        lst1_total += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        lst2_total += len(str)\n    }\n    if lst1_total < lst2_total\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpk8zc4zk5_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074524
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    total1 := 0\n    total2 := 0\n    for _, s :=\
    \ range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n\
    \        total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd3lgvuht_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074524
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    var total1 int\n\
    \    var total2 int\n    for _, str := range lst1 {\n        total1 += len(str)\n\
    \    }\n    for _, str := range lst2 {\n        total2 += len(str)\n    }\n  \
    \  if total1 < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxl8df5np_test.go:64: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074524
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var sum1, sum2 int\n    for _, v := range lst1\
    \ {\n        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n        sum2\
    \ += len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpwj6yqi9k_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074524
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, str := range\
    \ lst1 {\n        total1 += len(str)\n    }\n    for _, str := range lst2 {\n\
    \        total2 += len(str)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpqao3r56n_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, s := range lst1 {\n        total1 += len(s)\n   \
    \ }\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpd1x9ey6v_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpd1x9ey6v_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpd1x9ey6v_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, s := range\
    \ lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n    \
    \    total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsmwnebf7_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return nil\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmprntfsi0w_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmprntfsi0w_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmprntfsi0w_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmprntfsi0w_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmprntfsi0w_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmprntfsi0w_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total1 := 0\n\
    \    total2 := 0\n    for _, v := range lst1 {\n        total1 += len(v)\n   \
    \ }\n    for _, v := range lst2 {\n        total2 += len(v)\n    }\n    if total1\
    \ < total2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpdr66r3pn_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpdr66r3pn_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpdr66r3pn_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074520
