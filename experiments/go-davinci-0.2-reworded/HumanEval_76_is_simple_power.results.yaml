language: go_test.go
name: HumanEval_76_is_simple_power
results:
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprx4710e4_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpgufoivst_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprx4710e4_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpgufoivst_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy5lm0_56_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkh90iwjq_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++\
    \ {\n        if x == n * n {\n            return true\n        }\n        n =\
    \ n * n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x < n {\n        return false\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++\
    \ {\n        if i == x {\n            return true\n        }\n        if i * i\
    \ > x {\n            return false\n        }\n        if i * i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpgufoivst_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x % i == 0 {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp8s9p3trv_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp8s9p3trv_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp8s9p3trv_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp8s9p3trv_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n\
    \        return false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpe_etfq5__test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n * n {\n            return true\n        }\n  \
    \      n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 0; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvmn5c3i5_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ <= x; i++ {\n        if x == n*n {\n            return true\n        }\n   \
    \     n = n*n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpgufoivst_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    for i := 1; i <= x; i++\
    \ {\n        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbckmm2hj_test.go:29:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkh90iwjq_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if x % i == 0 {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp07uu32nt_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp07uu32nt_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp07uu32nt_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp07uu32nt_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    for i := 1; i < x; i++\
    \ {\n        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb214jeya_test.go:29:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzmtf4zi0_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n*n == x {\n        \
    \    return true\n        }\n        n *= n\n    }\n    return false\n}\n\nfunc\
    \ TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if x % i == 0 {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp07uu32nt_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp07uu32nt_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp07uu32nt_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp07uu32nt_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprx4710e4_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x % i == 0 {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp8s9p3trv_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp8s9p3trv_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp8s9p3trv_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp8s9p3trv_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    for i := 1; i < x; i++\
    \ {\n        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb214jeya_test.go:29:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8e01s4bo_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n\
    \        return false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpe_etfq5__test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if i == x {\n         \
    \   return true\n        }\n        if i * n > x {\n            return false\n\
    \        }\n        n *= i\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpnapuqfng_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpnapuqfng_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpnapuqfng_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpnapuqfng_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n\
    \        return false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmphbahuucc_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8tgcn6lq_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    if x / n\
    \ == 1 {\n        return true\n    }\n    return is_simple_power(x / n, n)\n}\n\
    \nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for x > 1 {\n        if x % n != 0 {\n            return false\n\
    \        }\n        x /= n\n    }\n    return true\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkh90iwjq_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiezwpn1g_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n * n {\n            return true\n        }\n  \
    \      n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 0; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvduf5_2f_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpgufoivst_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n * n {\n            return true\n        }\n  \
    \      n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpexm7wv7p_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n * n {\n            return true\n        }\n  \
    \      n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ <= x; i++ {\n        if x == n * n {\n            return true\n        }\n \
    \       n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if x == n * n {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpfyl_ug20_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073346
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    return x == n * n\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp9gdao_m9_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmp9gdao_m9_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073346
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++\
    \ {\n        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_9lhi4o3_test.go:29:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073346
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9s3p9uv6_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy5lm0_56_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++\
    \ {\n        if i * i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073346
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if n**i == x {\n            return true\n        }\n   \
    \ }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjsn04ao9_test.go:35:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n\
    \        return false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpe_etfq5__test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ <= x; i++ {\n        if x == n*n {\n            return true\n        }\n   \
    \     n = n*n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073346
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    for i := 1; i < x; i++ {\n        if n**i == x {\n            return\
    \ true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcrjexzom_test.go:26:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpexm7wv7p_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if x == n * n {\n     \
    \       return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073346
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ <= x; i++ {\n        if x == n * n {\n            return true\n        }\n \
    \       n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if x == n*n {\n       \
    \     return true\n        }\n        n *= n\n    }\n    return false\n}\n\nfunc\
    \ TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073346
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8e01s4bo_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps8g9nhsi_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n * n {\n            return true\n        }\n  \
    \      n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n * n {\n            return true\n        }\n  \
    \      n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkh90iwjq_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n\
    \        return false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpe_etfq5__test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n\
    \        if n ** i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_x_r75mj_test.go:29:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8tgcn6lq_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpt_87k_1v_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpt_87k_1v_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpt_87k_1v_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpt_87k_1v_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpt_87k_1v_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073346
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ <= x; i++ {\n        if n**i == x {\n            return true\n        }\n  \
    \  }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmpi7llup_test.go:35:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++\
    \ {\n        if i*i > x {\n            return false\n        }\n        if i*i\
    \ == x {\n            return true\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073347
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 1; i <= x; i++\
    \ {\n        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7rd8cp08_test.go:29:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8tgcn6lq_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ <= x; i++ {\n        if n**i == x {\n            return true\n        }\n  \
    \  }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmpi7llup_test.go:35:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8tgcn6lq_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprx4710e4_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if x % i == 0 {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp07uu32nt_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp07uu32nt_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp07uu32nt_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp07uu32nt_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n\n    if n == 1 {\n        return\
    \ false\n    }\n\n    for i := 1; i < x; i++ {\n        if n**i == x {\n     \
    \       return true\n        }\n    }\n\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr9nihfd9_test.go:34:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n * n {\n            return true\n        }\n  \
    \      n *= n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmp0_sw_3sg_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++\
    \ {\n        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_9lhi4o3_test.go:29:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp92705fyk_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    for i := 1; i <= x; i++\
    \ {\n        if n ** i == x {\n            return true\n        }\n    }\n   \
    \ return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate :=\
    \ is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3ndyazn4_test.go:29:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzmtf4zi0_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    for i := 1; i < x; i++ {\n        if n**i == x {\n            return\
    \ true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcrjexzom_test.go:26:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n * n {\n            return true\n        }\n  \
    \      if x < n * n {\n            return false\n        }\n        n *= n\n \
    \   }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmplmqj6oht_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n\n    if n == 1 {\n        return\
    \ false\n    }\n\n    for i := 2; i < x; i++ {\n        if n**i == x {\n     \
    \       return true\n        }\n    }\n\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1lwm9wx9_test.go:34:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxbk7nda6_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0mkr345_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmph73_25x6_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n\
    \        return false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpe_etfq5__test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 0; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvmn5c3i5_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8tgcn6lq_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n\
    \        return false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpe_etfq5__test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++\
    \ {\n        if i * i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073346
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprx4710e4_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8e01s4bo_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    for i := 1; i < x; i++\
    \ {\n        if n*n == x {\n            return true\n        }\n        n *= n\n\
    \    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpjylkg1dk_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073346
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if x == n ** i {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsoui3mll_test.go:32:22: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpjbxopefj_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpjbxopefj_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if i == x {\n         \
    \   return true\n        }\n        if i*n > x {\n            return false\n \
    \       }\n        n *= i\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp0w46ixcc_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp0w46ixcc_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp0w46ixcc_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp0w46ixcc_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ < x; i++ {\n        if x == n*n {\n            return true\n        }\n    \
    \    n = n*n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073347
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkh90iwjq_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6y747p0k_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073345
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    for x >\
    \ n {\n        x /= n\n    }\n    return x == n\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073347
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n\
    \        return false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpe_etfq5__test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8e01s4bo_test.go:32:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n ** i == x {\n     \
    \       return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprx4710e4_test.go:32:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073342
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    for i := 2; i\
    \ <= x; i++ {\n        if n**i == x {\n            return true\n        }\n  \
    \  }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxjzujzpl_test.go:35:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073347
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073343
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\n// >>> is_simple_power(1, 4)\n// true\n// >>>\
    \ is_simple_power(2, 2)\n// true\n// >>> is_simple_power(8, 2)\n// true\n// >>>\
    \ is_simple_power(3, 2)\n// false\n// >>> is_simple_power(3, 1)\n// false\n//\
    \ >>> is_simple_power(5, 3)\n// false\nfunc is_simple_power(x int, n int) bool\
    \ {\n    if x == 1 {\n        return true\n    }\n    if n == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if x == n * n {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073347
