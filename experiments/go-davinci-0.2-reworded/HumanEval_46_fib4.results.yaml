language: go_test.go
name: HumanEval_46_fib4
results:
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 310\n    }\n    if\
    \ n == 14 {\n        return 504\n    }\n    if n == 15 {\n        return 818\n\
    \    }\n    if n == 16 {\n        return 1322\n    }\n    if n == 17 {\n     \
    \   return 2140\n    }\n    if n == 18 {\n        return 3458\n    }\n    if n\
    \ == 19 {\n        return 5618\n    }\n    if n == 20 {\n        return 9176\n\
    \    }\n    if n == 21 {\n        return 14890\n    }\n    if n == 22 {\n    \
    \    return 24006\n    }\n    if n == 23 {\n        return 38896\n    }\n    if\
    \ n == 24 {\n        return 62990\n    }\n    if n == 25 {\n        return 102076\n\
    \    }\n    if n == 26 {\n        return 165066\n    }\n    if n == 27 {\n   \
    \     return 267150\n    }\n    if n == 28 {\n        return 432216\n    }\n \
    \   if n == 29 {\n        return 699366\n    }\n    if n == 30 {\n        return\
    \ 1130552\n    }\n    if n == 31 {\n        return 1829708\n    }\n    if n ==\
    \ 32 {\n        return 2960260\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpve136ydm_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073868
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n * 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d := 0,\
    \ 2, 0, 4\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a + b\
    \ + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpmpyf8vfs_test.go:51: expected '%!s(int=4)', got '%!s(int=12)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpmpyf8vfs_test.go:51: expected\
    \ '%!s(int=28)', got '%!s(int=84)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpmpyf8vfs_test.go:51: expected '%!s(int=104)', got '%!s(int=312)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpmpyf8vfs_test.go:51: expected\
    \ '%!s(int=386)', got '%!s(int=1160)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    a, b,\
    \ c, d := 0, 0, 2, 4\n    for i := 5; i <= n; i++ {\n        a, b, c, d = b, c,\
    \ d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpp8dyax2q_test.go:63: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpp8dyax2q_test.go:63: expected\
    \ '%!s(int=28)', got '%!s(int=46)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpp8dyax2q_test.go:63: expected '%!s(int=104)', got '%!s(int=170)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpp8dyax2q_test.go:63: expected\
    \ '%!s(int=386)', got '%!s(int=632)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 40\n    }\n    if n == 10 {\n        return\
    \ 66\n    }\n    if n == 11 {\n        return 108\n    }\n    if n == 12 {\n \
    \       return 176\n    }\n    if n == 13 {\n        return 286\n    }\n    if\
    \ n == 14 {\n        return 464\n    }\n    if n == 15 {\n        return 754\n\
    \    }\n    if n == 16 {\n        return 1218\n    }\n    if n == 17 {\n     \
    \   return 1974\n    }\n    if n == 18 {\n        return 3192\n    }\n    if n\
    \ == 19 {\n        return 5166\n    }\n    if n == 20 {\n        return 8358\n\
    \    }\n    if n == 21 {\n        return 13524\n    }\n    if n == 22 {\n    \
    \    return 21882\n    }\n    if n == 23 {\n        return 35306\n    }\n    if\
    \ n == 24 {\n        return 57188\n    }\n    if n == 25 {\n        return 92494\n\
    \    }\n    if n == 26 {\n        return 149682\n    }\n    if n == 27 {\n   \
    \     return 242166\n    }\n    if n == 28 {\n        return 391848\n    }\n \
    \   if n == 29 {\n        return 633512\n    }\n    if n == 30 {\n        return\
    \ 1025370\n    }\n    if n == 31 {\n        return 1656802\n    }\n    if n ==\
    \ 32 {\n        return 2682172\n    }\n    if n == 33 {\n        return 4\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr4anm0n5_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073868
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 26\n    }\n    if n == 9 {\n        return 48\n\
    \    }\n    if n == 10 {\n        return 88\n    }\n    if n == 11 {\n       \
    \ return 162\n    }\n    if n == 12 {\n        return 296\n    }\n    if n ==\
    \ 13 {\n        return 544\n    }\n    if n == 14 {\n        return 1008\n   \
    \ }\n    if n == 15 {\n        return 1864\n    }\n    if n == 16 {\n        return\
    \ 3432\n    }\n    if n == 17 {\n        return 6328\n    }\n    if n == 18 {\n\
    \        return 11664\n    }\n    if n == 19 {\n        return 21472\n    }\n\
    \    if n == 20 {\n        return 39648\n    }\n    if n == 21 {\n        return\
    \ 72768\n    }\n    if n == 22 {\n        return 133344\n    }\n    if n == 23\
    \ {\n        return 243712\n    }\n    if n == 24 {\n        return 447232\n \
    \   }\n    if n == 25 {\n        return 817152\n    }\n    if n == 26 {\n    \
    \    return 1488896\n    }\n    if n == 27 {\n        return 2717184\n    }\n\
    \    if n == 28 {\n        return 4949248\n    }\n    if n == 29 {\n        return\
    \ 9011200\n    }\n    if n == 30 {\n        return 16386560\n    }\n    if n ==\
    \ 31 {\n        return 29833728\n    }\n    if n == 32 {\n        return 54436864\n\
    \    }\n    if n == 33 {\n        return 99003904\n   \nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6nmli7th_test.go:124:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073868
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpkliu2cr8_test.go:48: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpkliu2cr8_test.go:48: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpkliu2cr8_test.go:48: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpkliu2cr8_test.go:48: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        e :=\
    \ a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return a + b + c + d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n\n    if n == 0 {\n        return 0\n    }\n\n    if n == 1 {\n  \
    \      return 0\n    }\n\n    if n == 2 {\n        return 2\n    }\n\n    if n\
    \ == 3 {\n        return 0\n    }\n\n    a := 0\n    b := 0\n    c := 2\n    d\
    \ := 0\n    for i := 4; i <= n; i++ {\n        d = a + b + c\n        a = b\n\
    \        b = c\n        c = d\n    }\n\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmp_brz1sv7_test.go:72: expected '%!s(int=28)', got '%!s(int=26)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmp_brz1sv7_test.go:72: expected\
    \ '%!s(int=104)', got '%!s(int=88)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmp_brz1sv7_test.go:72: expected '%!s(int=386)', got '%!s(int=298)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        a = b\n        b = c\n        c = d\n        d = a + b + c\n    }\n\
    \    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpmw06rqp2_test.go:64: expected '%!s(int=28)', got '%!s(int=22)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpmw06rqp2_test.go:64: expected\
    \ '%!s(int=104)', got '%!s(int=74)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpmw06rqp2_test.go:64: expected '%!s(int=386)', got '%!s(int=250)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        d = a + b + c\n        a = b\n        b =\
    \ c\n        c = d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpwfxddq13_test.go:66: expected '%!s(int=28)', got '%!s(int=26)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpwfxddq13_test.go:66: expected\
    \ '%!s(int=104)', got '%!s(int=88)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpwfxddq13_test.go:66: expected '%!s(int=386)', got '%!s(int=298)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmptknt6vqe_test.go:49: expected '%!s(int=4)', got '%!s(int=16)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmptknt6vqe_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=260)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmptknt6vqe_test.go:49: expected '%!s(int=104)', got '%!s(int=1686)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmptknt6vqe_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=10936)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n\n    if n < 2 {\n        return 0\n    }\n\n    if n == 2 {\n   \
    \     return 2\n    }\n\n    if n == 3 {\n        return 0\n    }\n\n    a :=\
    \ 0\n    b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n     \
    \   a, b, c, d = b, c, d, a + b + c + d\n    }\n\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n  \
    \      d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpy9tji1j9_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpy9tji1j9_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpy9tji1j9_test.go:50: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpy9tji1j9_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073870
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 26\n\
    \    }\n    if n == 9 {\n        return 48\n    }\n    if n == 10 {\n        return\
    \ 90\n    }\n    if n == 11 {\n        return 170\n    }\n    if n == 12 {\n \
    \       return 322\n    }\n    if n == 13 {\n        return 616\n    }\n    if\
    \ n == 14 {\n        return 1180\n    }\n    if n == 15 {\n        return 2268\n\
    \    }\n    if n == 16 {\n        return 4376\n    }\n    if n == 17 {\n     \
    \   return 8452\n    }\n    if n == 18 {\n        return 16380\n    }\n    if\
    \ n == 19 {\n        return 31752\n    }\n    if n == 20 {\n        return 61440\n\
    \    }\n    if n == 21 {\n        return 118784\n    }\n    if n == 22 {\n   \
    \     return 229376\n    }\n    if n == 23 {\n        return 443392\n    }\n \
    \   if n == 24 {\n        return 851968\n    }\n    if n == 25 {\n        return\
    \ 1638400\n    }\n    if n == 26 {\n        return 3164160\n    }\n    if n ==\
    \ 27 {\n        return 6094848\n    }\n    if n == 28 {\n        return 11730944\n\
    \    }\n    if n == 29 {\n        return 22654208\n    }\n    if n == 30 {\n \
    \       return 43737088\n    }\n    if n == 31 {\n        return 84526080\n  \
    \  }\n    if n == 32 {\n        return 163840064\n    }\n   \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpphp6_2i7_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    a, b, c, d := 0, 0, 2, 2\n    for i := 5; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpucf6hy9x_test.go:60: expected '%!s(int=28)', got '%!s(int=30)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpucf6hy9x_test.go:60: expected\
    \ '%!s(int=104)', got '%!s(int=112)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpucf6hy9x_test.go:60: expected '%!s(int=386)', got '%!s(int=416)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073871
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d := 0, 0,\
    \ 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 24\n    }\n    if n == 9 {\n        return 40\n\
    \    }\n    if n == 10 {\n        return 66\n    }\n    if n == 11 {\n       \
    \ return 108\n    }\n    if n == 12 {\n        return 176\n    }\n    if n ==\
    \ 13 {\n        return 286\n    }\n    if n == 14 {\n        return 464\n    }\n\
    \    if n == 15 {\n        return 752\n    }\n    if n == 16 {\n        return\
    \ 1218\n    }\n    if n == 17 {\n        return 1970\n    }\n    if n == 18 {\n\
    \        return 3188\n    }\n    if n == 19 {\n        return 5158\n    }\n  \
    \  if n == 20 {\n        return 8346\n    }\n    if n == 21 {\n        return\
    \ 13504\n    }\n    if n == 22 {\n        return 21852\n    }\n    if n == 23\
    \ {\n        return 35356\n    }\n    if n == 24 {\n        return 57208\n   \
    \ }\n    if n == 25 {\n        return 92564\n    }\n    if n == 26 {\n       \
    \ return 149772\n    }\n    if n == 27 {\n        return 242036\n    }\n    if\
    \ n == 28 {\n        return 391796\n    }\n    if n == 29 {\n        return 633828\n\
    \    }\n    if n == 30 {\n        return 1025624\n    }\n    if n == 31 {\n  \
    \      return 1659452\n    }\n    if n == 32 {\n        return 2685076\n    }\n\
    \    if n == 33 {\n        return 4334128\n    }\n    if n == 34 {\n       \n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpben7letz_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073871
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpfcbqi4_2_test.go:68: expected '%!s(int=28)', got '%!s(int=30)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpfcbqi4_2_test.go:68: expected\
    \ '%!s(int=104)', got '%!s(int=108)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpfcbqi4_2_test.go:68: expected '%!s(int=386)', got '%!s(int=402)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 40\n    }\n    if n == 10 {\n        return\
    \ 66\n    }\n    if n == 11 {\n        return 106\n    }\n    if n == 12 {\n \
    \       return 172\n    }\n    if n == 13 {\n        return 276\n    }\n    if\
    \ n == 14 {\n        return 444\n    }\n    if n == 15 {\n        return 714\n\
    \    }\n    if n == 16 {\n        return 1150\n    }\n    if n == 17 {\n     \
    \   return 1844\n    }\n    if n == 18 {\n        return 2974\n    }\n    if n\
    \ == 19 {\n        return 4796\n    }\n    if n == 20 {\n        return 7740\n\
    \    }\n    if n == 21 {\n        return 12486\n    }\n    if n == 22 {\n    \
    \    return 20126\n    }\n    if n == 23 {\n        return 32412\n    }\n    if\
    \ n == 24 {\n        return 52438\n    }\n    if n == 25 {\n        return 84850\n\
    \    }\n    if n == 26 {\n        return 137300\n    }\n    if n == 27 {\n   \
    \     return 220848\n    }\n    if n == 28 {\n        return 357350\n    }\n \
    \   if n == 29 {\n        return 578198\n    }\n    if n == 30 {\n        return\
    \ 935548\n    }\n    if n == 31 {\n        return 1504046\n    }\n    if n ==\
    \ 32 {\n        return 2438544\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmfp6dhd6_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073871
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i < n; i++ {\n\
    \        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return a+b+c+d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpqixgrkkt_test.go:54: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpqixgrkkt_test.go:54: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpqixgrkkt_test.go:54: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpqixgrkkt_test.go:54: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmph9gzqftz_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmph9gzqftz_test.go:42: expected\
    \ '%!s(int=28)', got '%!s(int=0)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmph9gzqftz_test.go:42: expected '%!s(int=104)', got '%!s(int=0)'\n \
    \   --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmph9gzqftz_test.go:42: expected\
    \ '%!s(int=386)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    var a,\
    \ b, c, d, e int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    e = 2\n    for\
    \ i := 5; i <= n; i++ {\n        a = b + c + d + e\n        b = c\n        c =\
    \ d\n        d = e\n        e = a\n    }\n    return a\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 4\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 24\n    }\n    if n == 9 {\n        return 42\n\
    \    }\n    if n == 10 {\n        return 70\n    }\n    if n == 11 {\n       \
    \ return 116\n    }\n    if n == 12 {\n        return 190\n    }\n    if n ==\
    \ 13 {\n        return 310\n    }\n    if n == 14 {\n        return 500\n    }\n\
    \    if n == 15 {\n        return 810\n    }\n    if n == 16 {\n        return\
    \ 1302\n    }\n    if n == 17 {\n        return 2102\n    }\n    if n == 18 {\n\
    \        return 3404\n    }\n    if n == 19 {\n        return 5506\n    }\n  \
    \  if n == 20 {\n        return 8910\n    }\n    if n == 21 {\n        return\
    \ 14320\n    }\n    if n == 22 {\n        return 23230\n    }\n    if n == 23\
    \ {\n        return 37550\n    }\n    if n == 24 {\n        return 60780\n   \
    \ }\n    if n == 25 {\n        return 98310\n    }\n    if n == 26 {\n       \
    \ return 159130\n    }\n    if n == 27 {\n        return 257440\n    }\n    if\
    \ n == 28 {\n        return 416570\n    }\n    if n == 29 {\n        return 674010\n\
    \    }\n    if n == 30 {\n        return 1091550\n    }\n    if n == 31 {\n  \
    \      return 1765760\n    }\n    if n == 32 {\n        return 2857310\n    }\n\
    \    if n == 33 {\n        return 4614070\n    }\n    if n == 34 {\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv32tegmb_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073871
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d := 0, 0,\
    \ 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 308\n    }\n    if\
    \ n == 14 {\n        return 500\n    }\n    if n == 15 {\n        return 810\n\
    \    }\n    if n == 16 {\n        return 1308\n    }\n    if n == 17 {\n     \
    \   return 2118\n    }\n    if n == 18 {\n        return 3426\n    }\n    if n\
    \ == 19 {\n        return 5544\n    }\n    if n == 20 {\n        return 8970\n\
    \    }\n    if n == 21 {\n        return 14514\n    }\n    if n == 22 {\n    \
    \    return 23484\n    }\n    if n == 23 {\n        return 37978\n    }\n    if\
    \ n == 24 {\n        return 61462\n    }\n    if n == 25 {\n        return 99440\n\
    \    }\n    if n == 26 {\n        return 160902\n    }\n    if n == 27 {\n   \
    \     return 260344\n    }\n    if n == 28 {\n        return 421246\n    }\n \
    \   if n == 29 {\n        return 682190\n    }\n    if n == 30 {\n        return\
    \ 1103434\n    }\n    if n == 31 {\n        return 1785674\n    }\n    if n ==\
    \ 32 {\n        return 2889098\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdcxen0ic_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073871
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    if n == 4 {\n\
    \        return 2\n    }\n    if n == 5 {\n        return 4\n    }\n    if n ==\
    \ 6 {\n        return 8\n    }\n    if n == 7 {\n        return 14\n    }\n  \
    \  if n == 8 {\n        return 26\n    }\n    if n == 9 {\n        return 48\n\
    \    }\n    if n == 10 {\n        return 90\n    }\n    if n == 11 {\n       \
    \ return 170\n    }\n    if n == 12 {\n        return 322\n    }\n    if n ==\
    \ 13 {\n        return 614\n    }\n    if n == 14 {\n        return 1182\n   \
    \ }\n    if n == 15 {\n        return 2270\n    }\n    if n == 16 {\n        return\
    \ 4398\n    }\n    if n == 17 {\n        return 8486\n    }\n    if n == 18 {\n\
    \        return 16450\n    }\n    if n == 19 {\n        return 31966\n    }\n\
    \    if n == 20 {\n        return 62274\n    }\n    if n == 21 {\n        return\
    \ 121058\n    }\n    if n == 22 {\n        return 235582\n    }\n    if n == 23\
    \ {\n        return 456354\n    }\n    if n == 24 {\n        return 887906\n \
    \   }\n    if n == 25 {\n        return 1732170\n    }\n    if n == 26 {\n   \
    \     return 3376722\n    }\n    if n == 27 {\n        return 6570126\n    }\n\
    \    if n == 28 {\n        return 12770478\n    }\n    if n == 29 {\n        return\
    \ 24826202\n    }\n    if n == 30 {\n        return 48265874\n    }\n    if n\
    \ == 31 {\n        return 93955810\n    }\n    if n == 32 {\n        return 182745586\n\
    \    }\n    if n == 33 {\n        return 354928\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi7ww7sqr_test.go:123:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073871
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    n1 := 0\n\
    \    n2 := 0\n    n3 := 2\n    n4 := 0\n    for i := 4; i <= n; i++ {\n      \
    \  n4 = n1 + n2 + n3 + n4\n        n1 = n2\n        n2 = n3\n        n3 = n4\n\
    \    }\n    return n4\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp8xfcshej_test.go:61: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp8xfcshej_test.go:61: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp8xfcshej_test.go:61: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp8xfcshej_test.go:61: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    }\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n  \
    \  return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073870
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    var a, b, c, d int\n    a = 0\n    b = 0\n    c\
    \ = 2\n    d = 0\n    for i := 4; i <= n; i++ {\n        a = b\n        b = c\n\
    \        c = d\n        d = a + b + c\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmp1bbspflu_test.go:67: expected '%!s(int=28)', got '%!s(int=22)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmp1bbspflu_test.go:67: expected\
    \ '%!s(int=104)', got '%!s(int=74)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmp1bbspflu_test.go:67: expected '%!s(int=386)', got '%!s(int=250)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpn0bqnl20_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpn0bqnl20_test.go:53: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpn0bqnl20_test.go:53: expected '%!s(int=104)', got '%!s(int=148)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpn0bqnl20_test.go:53: expected\
    \ '%!s(int=386)', got '%!s(int=550)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 190\n    }\n    if n == 13 {\n        return 310\n    }\n    if\
    \ n == 14 {\n        return 504\n    }\n    if n == 15 {\n        return 818\n\
    \    }\n    if n == 16 {\n        return 1322\n    }\n    if n == 17 {\n     \
    \   return 2140\n    }\n    if n == 18 {\n        return 3458\n    }\n    if n\
    \ == 19 {\n        return 5618\n    }\n    if n == 20 {\n        return 9176\n\
    \    }\n    if n == 21 {\n        return 14890\n    }\n    if n == 22 {\n    \
    \    return 24006\n    }\n    if n == 23 {\n        return 38896\n    }\n    if\
    \ n == 24 {\n        return 62990\n    }\n    if n == 25 {\n        return 102086\n\
    \    }\n    if n == 26 {\n        return 165076\n    }\n    if n == 27 {\n   \
    \     return 267150\n    }\n    if n == 28 {\n        return 434226\n    }\n \
    \   if n == 29 {\n        return 701424\n    }\n    if n == 30 {\n        return\
    \ 1135650\n    }\n    if n == 31 {\n        return 1836674\n    }\n    if n ==\
    \ 32 {\n        return 2972304\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7r9ag3ox_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073871
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n\n    if n == 0 {\n        return 0\n    }\n\n    if n == 1 {\n  \
    \      return 0\n    }\n\n    if n == 2 {\n        return 2\n    }\n\n    if n\
    \ == 3 {\n        return 0\n    }\n\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 44\n    }\n    if n == 10 {\n        return\
    \ 78\n    }\n    if n == 11 {\n        return 136\n    }\n    if n == 12 {\n \
    \       return 240\n    }\n    if n == 13 {\n        return 420\n    }\n    if\
    \ n == 14 {\n        return 740\n    }\n    if n == 15 {\n        return 1284\n\
    \    }\n    if n == 16 {\n        return 2268\n    }\n    if n == 17 {\n     \
    \   return 4052\n    }\n    if n == 18 {\n        return 7196\n    }\n    if n\
    \ == 19 {\n        return 12844\n    }\n    if n == 20 {\n        return 22932\n\
    \    }\n    if n == 21 {\n        return 40980\n    }\n    if n == 22 {\n    \
    \    return 73028\n    }\n    if n == 23 {\n        return 130924\n    }\n   \
    \ if n == 24 {\n        return 234948\n    }\n    if n == 25 {\n        return\
    \ 422444\n    }\n    if n == 26 {\n        return 759388\n    }\n    if n == 27\
    \ {\n        return 1358772\n    }\n    if n == 28 {\n        return 2448140\n\
    \    }\n    if n == 29 {\n        return 4396692\n    }\n    if n == 30 {\n  \
    \      return 7945356\n    }\n    if n == 31 {\n        return 14348948\n    }\n\
    \    if n == 32 {\n        return 25907932\n    }\n    if\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj7mt1iaq_test.go:125:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073871
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    } else if n == 2 {\n        return 2\n    } else if n == 3 {\n      \
    \  return 0\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    }\n\n    a, b, c, d\
    \ := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d,\
    \ a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 118\n    }\n    if n == 12 {\n \
    \       return 196\n    }\n    if n == 13 {\n        return 322\n    }\n    if\
    \ n == 14 {\n        return 524\n    }\n    if n == 15 {\n        return 846\n\
    \    }\n    if n == 16 {\n        return 1370\n    }\n    if n == 17 {\n     \
    \   return 2216\n    }\n    if n == 18 {\n        return 3566\n    }\n    if n\
    \ == 19 {\n        return 5782\n    }\n    if n == 20 {\n        return 9348\n\
    \    }\n    if n == 21 {\n        return 15130\n    }\n    if n == 22 {\n    \
    \    return 24478\n    }\n    if n == 23 {\n        return 39608\n    }\n    if\
    \ n == 24 {\n        return 64086\n    }\n    if n == 25 {\n        return 103694\n\
    \    }\n    if n == 26 {\n        return 167780\n    }\n    if n == 27 {\n   \
    \     return 271474\n    }\n    if n == 28 {\n        return 439254\n    }\n \
    \   if n == 29 {\n        return 710708\n    }\n    if n == 30 {\n        return\
    \ 1149842\n    }\n    if n == 31 {\n        return 1860650\n    }\n    if n ==\
    \ 32 {\n        return 3010598\n    }\n    if n == 33 {\n        return\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxu74f6wg_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073871
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        e :=\
    \ a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return a + b + c + d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    var a, b, c, d int\n    a = 0\n    b = 0\n    c\
    \ = 2\n    d = 0\n    for i := 4; i <= n; i++ {\n        a = b\n        b = c\n\
    \        c = d\n        d = a + b + c\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmp1bbspflu_test.go:67: expected '%!s(int=28)', got '%!s(int=22)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmp1bbspflu_test.go:67: expected\
    \ '%!s(int=104)', got '%!s(int=74)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmp1bbspflu_test.go:67: expected '%!s(int=386)', got '%!s(int=250)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 70\n    }\n    if n == 11 {\n        return 116\n    }\n    if n == 12 {\n \
    \       return 188\n    }\n    if n == 13 {\n        return 306\n    }\n    if\
    \ n == 14 {\n        return 496\n    }\n    if n == 15 {\n        return 804\n\
    \    }\n    if n == 16 {\n        return 1298\n    }\n    if n == 17 {\n     \
    \   return 2098\n    }\n    if n == 18 {\n        return 3396\n    }\n    if n\
    \ == 19 {\n        return 5492\n    }\n    if n == 20 {\n        return 8890\n\
    \    }\n    if n == 21 {\n        return 14382\n    }\n    if n == 22 {\n    \
    \    return 23272\n    }\n    if n == 23 {\n        return 37654\n    }\n    if\
    \ n == 24 {\n        return 60926\n    }\n    if n == 25 {\n        return 98580\n\
    \    }\n    if n == 26 {\n        return 159544\n    }\n    if n == 27 {\n   \
    \     return 258074\n    }\n    if n == 28 {\n        return 418118\n    }\n \
    \   if n == 29 {\n        return 676192\n    }\n    if n == 30 {\n        return\
    \ 1094314\n    }\n    if n == 31 {\n        return 1770506\n    }\n    if n ==\
    \ 32 {\n        return 2864920\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpak9wezbx_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8),\
    \ expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual:\
    \ candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpl5qo7e13_test.go:64: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpl5qo7e13_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        e :=\
    \ a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = e\n\
    \    }\n    return a + b + c + d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=54)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp5on4kvgh_test.go:64: expected '%!s(int=104)', got '%!s(int=200)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp5on4kvgh_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=744)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n  \
    \      a, b, c, d = b, c, d, a + b + c + d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n      \
    \  return 2\n    } else if n == 3 {\n        return 0\n    } else {\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    }\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    a := 0\n\
    \    b := 0\n    c := 2\n    d := 4\n    for i := 5; i <= n; i++ {\n        a\
    \ = b + c + d\n        b = c\n        c = d\n        d = a\n    }\n    return\
    \ a\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpoihgmvzy_test.go:69: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpoihgmvzy_test.go:69: expected\
    \ '%!s(int=28)', got '%!s(int=40)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpoihgmvzy_test.go:69: expected '%!s(int=104)', got '%!s(int=136)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpoihgmvzy_test.go:69: expected\
    \ '%!s(int=386)', got '%!s(int=460)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n;\
    \ i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc\
    \ TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n\
    \     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 2\n    }\n    if n ==\
    \ 5 {\n        return 4\n    }\n    if n == 6 {\n        return 8\n    }\n   \
    \ if n == 7 {\n        return 14\n    }\n    if n == 8 {\n        return 24\n\
    \    }\n    if n == 9 {\n        return 42\n    }\n    if n == 10 {\n        return\
    \ 72\n    }\n    if n == 11 {\n        return 120\n    }\n    if n == 12 {\n \
    \       return 200\n    }\n    if n == 13 {\n        return 328\n    }\n    if\
    \ n == 14 {\n        return 536\n    }\n    if n == 15 {\n        return 872\n\
    \    }\n    if n == 16 {\n        return 1408\n    }\n    if n == 17 {\n     \
    \   return 2288\n    }\n    if n == 18 {\n        return 3720\n    }\n    if n\
    \ == 19 {\n        return 6048\n    }\n    if n == 20 {\n        return 9840\n\
    \    }\n    if n == 21 {\n        return 16008\n    }\n    if n == 22 {\n    \
    \    return 25944\n    }\n    if n == 23 {\n        return 42152\n    }\n    if\
    \ n == 24 {\n        return 68464\n    }\n    if n == 25 {\n        return 111616\n\
    \    }\n    if n == 26 {\n        return 180480\n    }\n    if n == 27 {\n   \
    \     return 292088\n    }\n    if n == 28 {\n        return 472568\n    }\n \
    \   if n == 29 {\n        return 764656\n    }\n    if n == 30 {\n        return\
    \ 1236224\n    }\n    if n == 31 {\n        return 1996832\n    }\n    if n ==\
    \ 32 {\n        return 3230400\n    }\n    if n == 33 {\n       \nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_lr76qzp_test.go:126:6: expected ''('', found TestFib4

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 2 {\n        return\
    \ 0\n    } else if n == 2 {\n        return 2\n    } else if n == 3 {\n      \
    \  return 0\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++\
    \ {\n        a, b, c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t\
    \ *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual:\
    \ candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    a := 0\n    b := 0\n    c := 2\n    d := 0\n   \
    \ for i := 4; i <= n; i++ {\n        d = a + b + c\n        a = b\n        b =\
    \ c\n        c = d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n\
    \  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__1 (0.00s)\n\
    \        tmpwfxddq13_test.go:66: expected '%!s(int=28)', got '%!s(int=26)'\n \
    \   --- FAIL: TestFib4/test_num__2 (0.00s)\n        tmpwfxddq13_test.go:66: expected\
    \ '%!s(int=104)', got '%!s(int=88)'\n    --- FAIL: TestFib4/test_num__3 (0.00s)\n\
    \        tmpwfxddq13_test.go:66: expected '%!s(int=386)', got '%!s(int=298)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 3 {\n        return\
    \ n * 2\n    }\n\n    a, b, c, d := 0, 0, 2, 0\n    for i := 3; i <= n; i++ {\n\
    \        d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\
    \nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpttjpxrmx_test.go:50: expected '%!s(int=4)', got '%!s(int=16)'\n  \
    \  --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpttjpxrmx_test.go:50: expected\
    \ '%!s(int=28)', got '%!s(int=260)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpttjpxrmx_test.go:50: expected '%!s(int=104)', got '%!s(int=1686)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpttjpxrmx_test.go:50: expected\
    \ '%!s(int=386)', got '%!s(int=10936)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a := 0\n   \
    \ b := 0\n    c := 2\n    d := 0\n    for i := 4; i <= n; i++ {\n        a, b,\
    \ c, d = b, c, d, a+b+c+d\n    }\n    return d\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    a, b, c, d :=\
    \ 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n        a, b, c, d = b, c, d, a+b+c+d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n      \
    \  return 0\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n\
    \        return 0\n    }\n    if n == 4 {\n        return 4\n    }\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T)\
    \ {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10),\
    \ expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=28)', got '%!s(int=44)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmp89ur1q66_test.go:59: expected '%!s(int=104)', got '%!s(int=162)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmp89ur1q66_test.go:59: expected\
    \ '%!s(int=386)', got '%!s(int=602)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 4 {\n        return\
    \ n\n    }\n    a, b, c, d := 0, 0, 2, 0\n    for i := 4; i <= n; i++ {\n    \
    \    d = a + b + c + d\n        a, b, c = b, c, d\n    }\n    return d\n}\n\n\
    func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected:\
    \ 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12),\
    \ expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpljeit2vf_test.go:49: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpljeit2vf_test.go:49: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 1
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n < 0 {\n        return\
    \ 0\n    }\n    if n < 2 {\n        return n\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    var a, b, c,\
    \ d int\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for i := 4; i <= n; i++\
    \ {\n        d = a + b + c + d\n        a = b\n        b = c\n        c = d\n\
    \    }\n    return d\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate := fib4\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual:\
    \ candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n\
    \     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFib4 (0.00s)\n    --- FAIL: TestFib4/test_num__0 (0.00s)\n\
    \        tmpj7isb_od_test.go:64: expected '%!s(int=4)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestFib4/test_num__1 (0.00s)\n        tmpj7isb_od_test.go:64: expected\
    \ '%!s(int=28)', got '%!s(int=102)'\n    --- FAIL: TestFib4/test_num__2 (0.00s)\n\
    \        tmpj7isb_od_test.go:64: expected '%!s(int=104)', got '%!s(int=662)'\n\
    \    --- FAIL: TestFib4/test_num__3 (0.00s)\n        tmpj7isb_od_test.go:64: expected\
    \ '%!s(int=386)', got '%!s(int=4294)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073872
- exit_code: 0
  program: "package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// The\
    \ Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3)\
    \ -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please\
    \ write a function to efficiently compute the n-th element of the fib4 number\
    \ sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n\
    // >>> fib4(7)\n// 14\nfunc fib4(n int) int {\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n      \
    \  return 2\n    }\n    if n == 3 {\n        return 0\n    }\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nfunc TestFib4(t *testing.T) {\n  candidate\
    \ := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     {\
    \ actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected:\
    \ 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073869
