name: HumanEval_111_histogram
language: go_test.go
prompt: "package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Given a string representing a space separated lowercase letters, return a map\n\
  // of the letter with the most repetition and containing the corresponding count.\n\
  // If several letters have the same occurrence, return all of them.\n// Example:\n\
  // >>> histogram(\"a b c\")\n// map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}\n//\
  \ >>> histogram(\"a b b a\")\n// map[string]int{\"a\": 2, \"b\": 2}\n// >>> histogram(\"\
  a b c a b\")\n// map[string]int{\"a\": 2, \"b\": 2}\n// >>> histogram(\"b b b b\
  \ a\")\n// map[string]int{\"b\": 4}\n// >>> histogram(\"\")\n// PATCH dict\nfunc\
  \ histogram(test string) map[string]int {\n"
tests: "func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\"\
  : 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"\
  a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"\
  a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"\
  r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual:\
  \ candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual:\
  \ candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n\
  \     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"\
  a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests\
  \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif\
  \ fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\t\
  t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    // PATCH: initialize the map\n    hist := make(map[string]int)\n\
    \    // PATCH: if test is empty, return the map\n    if test == \"\" {\n     \
    \   return hist\n    }\n    // PATCH: split the string into a slice\n    letters\
    \ := strings.Split(test, \" \")\n    // PATCH: initialize the max count\n    maxCount\
    \ := 0\n    // PATCH: loop over the slice\n    for _, letter := range letters\
    \ {\n        // PATCH: if the letter is not in the map, add it\n        if _,\
    \ ok := hist[letter]; !ok {\n            hist[letter] = 0\n        }\n       \
    \ // PATCH: increment the count\n        hist[letter]++\n        // PATCH: if\
    \ the count is greater than the max count, update the max count\n        if hist[letter]\
    \ > maxCount {\n            maxCount = hist[letter]\n        }\n    }\n    //\
    \ PATCH: loop over the map\n    for letter, count := range hist {\n        //\
    \ PATCH: if the count is less than the max count, delete the letter\n        if\
    \ count < maxCount {\n            delete(hist, letter)\n        }\n    }\n   \
    \ return hist\n}\n", "    var histogram = make(map[string]int)\n    var max =\
    \ 0\n    var max_letters = make(map[string]int)\n    for _, letter := range test\
    \ {\n        histogram[string(letter)]++\n        if histogram[string(letter)]\
    \ > max {\n            max = histogram[string(letter)]\n            max_letters\
    \ = make(map[string]int)\n            max_letters[string(letter)] = max\n    \
    \    } else if histogram[string(letter)] == max {\n            max_letters[string(letter)]\
    \ = max\n        }\n    }\n    return max_letters\n}\n", "    var histo = make(map[string]int)\n\
    \    var max int\n    var max_letters []string\n    for _, letter := range test\
    \ {\n        histo[string(letter)] += 1\n        if histo[string(letter)] > max\
    \ {\n            max = histo[string(letter)]\n            max_letters = []string{string(letter)}\n\
    \        } else if histo[string(letter)] == max {\n            max_letters = append(max_letters,\
    \ string(letter))\n        }\n    }\n    for _, letter := range max_letters {\n\
    \        histo[letter] = max\n    }\n    return histo\n}\n", "    var histogram\
    \ = make(map[string]int)\n    var max = 0\n    for _, letter := range test {\n\
    \        histogram[string(letter)]++\n        if histogram[string(letter)] > max\
    \ {\n            max = histogram[string(letter)]\n        }\n    }\n    var result\
    \ = make(map[string]int)\n    for letter, count := range histogram {\n       \
    \ if count == max {\n            result[letter] = count\n        }\n    }\n  \
    \  return result\n}\n", "    // PATCH: return an empty map if the string is empty\n\
    \    if test == \"\" {\n        return map[string]int{}\n    }\n    // PATCH:\
    \ remove the space at the end of the string\n    if test[len(test)-1] == ' ' {\n\
    \        test = test[:len(test)-1]\n    }\n    // PATCH: remove the space at the\
    \ beginning of the string\n    if test[0] == ' ' {\n        test = test[1:]\n\
    \    }\n    // PATCH: remove the space at the end of the string\n    if test[len(test)-1]\
    \ == ' ' {\n        test = test[:len(test)-1]\n    }\n    // PATCH: remove the\
    \ space at the beginning of the string\n    if test[0] == ' ' {\n        test\
    \ = test[1:]\n    }\n    // PATCH: remove the space at the end of the string\n\
    \    if test[len(test)-1] == ' ' {\n        test = test[:len(test)-1]\n    }\n\
    \    // PATCH: remove the space at the beginning of the string\n    if test[0]\
    \ == ' ' {\n        test = test[1:]\n    }\n    // PATCH: remove the space at\
    \ the end of the string\n    if test[len(test)-1] == ' ' {\n        test = test[:len(test)-1]\n\
    \    }\n    // PATCH: remove the space at the beginning of the string\n    if\
    \ test[0] == ' ' {\n        test = test[1:]\n    }\n    // PATCH: remove the space\
    \ at the end of the string\n    if test[len(test)-1] == ' ' {\n        test =\
    \ test[:len(test)-1]\n    }\n    // PATCH: remove the space at the beginning of\
    \ the string\n    if test[0] == ' ' {\n        test = test[1:]\n    }\n    //\
    \ PATCH: remove the space at the end of the string\n    if test[len(test)-1] ==\
    \ ' ' {\n        test = test[:len(test)-1]\n    }\n    // PATCH: remove the space\
    \ at the beginning of the string\n", "    var histo = make(map[string]int)\n \
    \   for _, letter := range test {\n        histo[string(letter)]++\n    }\n  \
    \  return histo\n}\n", "    // TODO: implement\n    return nil\n}\n", "    var\
    \ histogram = make(map[string]int)\n    for _, letter := range test {\n      \
    \  histogram[string(letter)]++\n    }\n    return histogram\n}\n", "    var histogram\
    \ = make(map[string]int)\n    var max int\n    var max_letters []string\n    for\
    \ _, letter := range test {\n        histogram[string(letter)]++\n        if histogram[string(letter)]\
    \ > max {\n            max = histogram[string(letter)]\n            max_letters\
    \ = []string{string(letter)}\n        } else if histogram[string(letter)] == max\
    \ {\n            max_letters = append(max_letters, string(letter))\n        }\n\
    \    }\n    for _, letter := range max_letters {\n        histogram[letter] =\
    \ max\n    }\n    return histogram\n}\n", "    return map[string]int{}\n}\n",
  "    return nil\n}\n", "    // TODO: Implement me\n    return nil\n}\n", "    var\
    \ histogram = make(map[string]int)\n    var max int\n    var max_letters []string\n\
    \    for _, letter := range test {\n        histogram[string(letter)] += 1\n \
    \       if histogram[string(letter)] > max {\n            max = histogram[string(letter)]\n\
    \            max_letters = []string{string(letter)}\n        } else if histogram[string(letter)]\
    \ == max {\n            max_letters = append(max_letters, string(letter))\n  \
    \      }\n    }\n    for _, letter := range max_letters {\n        histogram[letter]\
    \ = max\n    }\n    return histogram\n}\n", "    // TODO: Implement me\n    return\
    \ nil\n}\n", "    var histogram = make(map[string]int)\n    for _, letter := range\
    \ test {\n        histogram[string(letter)]++\n    }\n    return histogram\n}\n",
  "    var histogram = make(map[string]int)\n    var max int\n    var max_letters\
    \ []string\n    for _, letter := range test {\n        histogram[string(letter)]\
    \ += 1\n        if histogram[string(letter)] > max {\n            max = histogram[string(letter)]\n\
    \            max_letters = []string{string(letter)}\n        } else if histogram[string(letter)]\
    \ == max {\n            max_letters = append(max_letters, string(letter))\n  \
    \      }\n    }\n    for _, letter := range max_letters {\n        histogram[letter]\
    \ = max\n    }\n    return histogram\n}\n", "    // TODO: implement this function\n\
    \    return nil\n}\n", "    var result map[string]int\n    result = make(map[string]int)\n\
    \    for _, v := range test {\n        result[string(v)]++\n    }\n    return\
    \ result\n}\n", "    // TODO: implement\n    return nil\n}\n", "    var result\
    \ map[string]int\n    result = make(map[string]int)\n    for _, letter := range\
    \ test {\n        result[string(letter)] += 1\n    }\n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
