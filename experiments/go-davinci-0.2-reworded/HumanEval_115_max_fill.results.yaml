language: go_test.go
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    var result int\n    for i\
    \ := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n  \
    \          if grid[i][j] == 1 {\n                result += capacity\n        \
    \    }\n        }\n    }\n    return result\n}\n\nfunc TestMax_Fill(t *testing.T)\
    \ {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__1\
    \ (0.00s)\n        tmpf6tq4q1m_test.go:58: expected '%!s(int=5)', got '%!s(int=18)'\n\
    \    --- FAIL: TestMax_Fill/test_num__3 (0.00s)\n        tmpf6tq4q1m_test.go:58:\
    \ expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestMax_Fill/test_num__4\
    \ (0.00s)\n        tmpf6tq4q1m_test.go:58: expected '%!s(int=2)', got '%!s(int=72)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmphn7l_wdm_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmphn7l_wdm_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmphn7l_wdm_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmphn7l_wdm_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    if len(grid) == 0 {\n   \
    \     return 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n \
    \   if capacity == 0 {\n        return 0\n    }\n    // fill the first row\n \
    \   for i := 0; i < len(grid[0]); i++ {\n        if grid[0][i] == 1 {\n      \
    \      grid[0][i] = capacity\n        }\n    }\n    // fill the rest of the rows\n\
    \    for i := 1; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                grid[i][j] = grid[i-1][j]\
    \ - 1\n            }\n        }\n    }\n    // count the number of times we filled\
    \ the buckets\n    count := 0\n    for i := 0; i < len(grid); i++ {\n        for\
    \ j := 0; j < len(grid[i]); j++ {\n            if grid[i][j] > 0 {\n         \
    \       count += capacity - grid[i][j]\n            }\n        }\n    }\n    return\
    \ count\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp1rt2qedv_test.go:82: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp1rt2qedv_test.go:82:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__4\
    \ (0.00s)\n        tmp1rt2qedv_test.go:82: expected '%!s(int=2)', got '%!s(int=4)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // Your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpj5h_ohkl_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpj5h_ohkl_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpj5h_ohkl_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpj5h_ohkl_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me!\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpd61i38eb_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpd61i38eb_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpd61i38eb_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpd61i38eb_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO - Add your code here\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp86vqaczr_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp86vqaczr_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    if len(grid) == 0 {\n   \
    \     return 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n \
    \   if capacity == 0 {\n        return 0\n    }\n    // find max height\n    max_height\
    \ := 0\n    for _, row := range grid {\n        for _, cell := range row {\n \
    \           if cell > max_height {\n                max_height = cell\n      \
    \      }\n        }\n    }\n    // fill wells\n    count := 0\n    for h := 0;\
    \ h < max_height; h++ {\n        for _, row := range grid {\n            for _,\
    \ cell := range row {\n                if cell > 0 {\n                    count\
    \ += 1\n                    cell -= 1\n                }\n            }\n    \
    \    }\n    }\n    return count\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate\
    \ := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0},\
    \ []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__1\
    \ (0.00s)\n        tmp6u_hydi3_test.go:80: expected '%!s(int=5)', got '%!s(int=9)'\n\
    \    --- FAIL: TestMax_Fill/test_num__3 (0.00s)\n        tmp6u_hydi3_test.go:80:\
    \ expected '%!s(int=4)', got '%!s(int=8)'\n    --- FAIL: TestMax_Fill/test_num__4\
    \ (0.00s)\n        tmp6u_hydi3_test.go:80: expected '%!s(int=2)', got '%!s(int=8)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    var count int\n    for i\
    \ := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++ {\n  \
    \          if grid[i][j] == 1 {\n                count += capacity\n         \
    \   }\n        }\n    }\n    return count\n}\n\nfunc TestMax_Fill(t *testing.T)\
    \ {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__1\
    \ (0.00s)\n        tmps0wczdn7_test.go:58: expected '%!s(int=5)', got '%!s(int=18)'\n\
    \    --- FAIL: TestMax_Fill/test_num__3 (0.00s)\n        tmps0wczdn7_test.go:58:\
    \ expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestMax_Fill/test_num__4\
    \ (0.00s)\n        tmps0wczdn7_test.go:58: expected '%!s(int=2)', got '%!s(int=72)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement this function\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpe9ykz8wo_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpe9ykz8wo_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpe9ykz8wo_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpe9ykz8wo_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    if len(grid) == 0 {\n   \
    \     return 0\n    }\n    if len(grid[0]) == 0 {\n        return 0\n    }\n \
    \   if capacity <= 0 {\n        return 0\n    }\n    // fill the first row\n \
    \   count := 0\n    for i := 0; i < len(grid[0]); i++ {\n        if grid[0][i]\
    \ == 1 {\n            count++\n        }\n    }\n    // fill the rest of the rows\n\
    \    for i := 1; i < len(grid); i++ {\n        for j := 0; j < len(grid[i]); j++\
    \ {\n            if grid[i][j] == 1 {\n                if grid[i-1][j] == 0 {\n\
    \                    count++\n                }\n            }\n        }\n  \
    \  }\n    return count * capacity\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate\
    \ := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0},\
    \ []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmprbdqqeth_test.go:76: expected '%!s(int=6)', got '%!s(int=5)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmprbdqqeth_test.go:76:\
    \ expected '%!s(int=5)', got '%!s(int=12)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmprbdqqeth_test.go:76: expected '%!s(int=4)', got '%!s(int=8)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmprbdqqeth_test.go:76:\
    \ expected '%!s(int=2)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement the solution\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me!\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpd61i38eb_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpd61i38eb_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpd61i38eb_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpd61i38eb_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement the solution\n\
    \    return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp8bpvpjg5_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp8bpvpjg5_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    return 0\n}\n\nfunc TestMax_Fill(t\
    \ *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     {\
    \ actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1,\
    \ 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1,\
    \ 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpoz126dea_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpoz126dea_test.go:50:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmph8b7dmc8_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmph8b7dmc8_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement me\n \
    \   return 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0,\
    \ 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpdbgqh12k_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpdbgqh12k_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO: Implement\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp554tcyn1_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp554tcyn1_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // your code here\n    return\
    \ 0\n}\n\nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1,\
    \ 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0,\
    \ 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmpvf2ofkv0_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmpvf2ofkv0_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
- exit_code: 1
  program: "package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a rectangular grid of wells. Each row represents a single well,\n\
    // and each 1 in a row represents a single unit of water.\n// Each well has a\
    \ corresponding bucket that can be used to extract water from it, \n// and all\
    \ buckets have the same capacity.\n// Your task is to use the buckets to empty\
    \ the wells.\n// Output the number of times you need to lower the buckets.\n//\
    \ Example 1:\n// >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1)\n// 6\n// Example 2:\n// >>> max_fill([][]int{[]int{0, 0, 1, 1},\
    \ []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n// 5\n// Example\
    \ 3:\n// >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n// 0\n// Constraints:\n\
    // * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <=\
    \ grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\n\
    func max_fill(grid [][]int, capacity int) int {\n    // TODO\n    return 0\n}\n\
    \nfunc TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1,\
    \ 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0,\
    \ 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected:\
    \ 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5),\
    \ expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1,\
    \ 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1,\
    \ 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMax_Fill (0.00s)\n    --- FAIL: TestMax_Fill/test_num__0\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__1 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestMax_Fill/test_num__3\
    \ (0.00s)\n        tmp2r9_hye6_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestMax_Fill/test_num__4 (0.00s)\n        tmp2r9_hye6_test.go:51:\
    \ expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073152
