language: go_test.go
name: HumanEval_159_eat
results:
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    var result []int\n    if number + need > remaining {\n \
    \       result = append(result, remaining)\n        result = append(result, 0)\n\
    \    } else {\n        result = append(result, number + need)\n        result\
    \ = append(result, remaining - (number + need))\n    }\n    return result\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0d3mrvf5_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0d3mrvf5_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp0d3mrvf5_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp0d3mrvf5_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp0d3mrvf5_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0d3mrvf5_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining >= need {\n        return []int{number + need, remaining - need}\n\
    \    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    } else\
    \ {\n        return []int{number + need, remaining - (number + need)}\n    }\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpf75emxho_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpf75emxho_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpf75emxho_test.go:60: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpf75emxho_test.go:60: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpf75emxho_test.go:60: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpf75emxho_test.go:60:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if remaining < need {\n        result = append(result, number\
    \ + remaining)\n        result = append(result, 0)\n    } else {\n        result\
    \ = append(result, number + need)\n        result = append(result, remaining -\
    \ need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    } else\
    \ {\n        return []int{number + need, remaining - (number + need)}\n    }\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpf75emxho_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpf75emxho_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpf75emxho_test.go:60: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpf75emxho_test.go:60: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpf75emxho_test.go:60: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpf75emxho_test.go:60:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if remaining < need {\n        result = append(result, number\
    \ + remaining)\n        result = append(result, 0)\n    } else {\n        result\
    \ = append(result, number + need)\n        result = append(result, remaining -\
    \ need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    total\
    \ := number + need\n    if total > remaining {\n        return []int{remaining,\
    \ 0}\n    }\n    return []int{total, remaining - total}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpiwpe2xpr_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpiwpe2xpr_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpiwpe2xpr_test.go:60: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpiwpe2xpr_test.go:60: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpiwpe2xpr_test.go:60: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpiwpe2xpr_test.go:60:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number >= need {\n        return []int{number, remaining}\n    }\n    if number\
    \ + remaining >= need {\n        return []int{need, number + remaining - need}\n\
    \    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpm89jf0o0_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm89jf0o0_test.go:62:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpm89jf0o0_test.go:62: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpm89jf0o0_test.go:62: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    } else\
    \ {\n        return []int{number + need, remaining - need}\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    } else\
    \ {\n        return []int{number + need, remaining - need}\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - number - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmppy1gmtbs_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmppy1gmtbs_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmppy1gmtbs_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmppy1gmtbs_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need > remaining {\n        result = append(result,\
    \ remaining)\n        result = append(result, 0)\n    } else {\n        result\
    \ = append(result, number + need)\n        result = append(result, remaining -\
    \ (number + need))\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp70itoogq_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp70itoogq_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp70itoogq_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp70itoogq_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp70itoogq_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp70itoogq_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need > remaining {\n        result = append(result,\
    \ remaining)\n        result = append(result, 0)\n    } else {\n        result\
    \ = append(result, number + need)\n        result = append(result, remaining -\
    \ (number + need))\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp70itoogq_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp70itoogq_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp70itoogq_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp70itoogq_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp70itoogq_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp70itoogq_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - number - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmppy1gmtbs_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmppy1gmtbs_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmppy1gmtbs_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmppy1gmtbs_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if remaining <\
    \ need {\n        return []int{number + remaining, 0}\n    }\n    return []int{number\
    \ + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    } else\
    \ {\n        return []int{number + need, remaining - need}\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - number - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmppy1gmtbs_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmppy1gmtbs_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmppy1gmtbs_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmppy1gmtbs_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpil6_pt2y_test.go:57: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpil6_pt2y_test.go:57: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpaq9f7j4f_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpaq9f7j4f_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmpaq9f7j4f_test.go:59: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ need <= remaining {\n        return []int{number + need, remaining - need}\n\
    \    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - number - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmppy1gmtbs_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmppy1gmtbs_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmppy1gmtbs_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmppy1gmtbs_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining >= need {\n        return []int{number + need, remaining - need}\n\
    \    } else {\n        return []int{number + remaining, 0}\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - number - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmppy1gmtbs_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmppy1gmtbs_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmppy1gmtbs_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmppy1gmtbs_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - number - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmppy1gmtbs_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmppy1gmtbs_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmppy1gmtbs_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmppy1gmtbs_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmppy1gmtbs_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need <= remaining {\n        result = append(result,\
    \ number + need)\n        result = append(result, remaining - (number + need))\n\
    \    } else {\n        result = append(result, number + remaining)\n        result\
    \ = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0zqstqkx_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0zqstqkx_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmp0zqstqkx_test.go:64: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need > remaining {\n        result = append(result,\
    \ remaining)\n        result = append(result, 0)\n    } else {\n        result\
    \ = append(result, number + need)\n        result = append(result, remaining -\
    \ (number + need))\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp70itoogq_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp70itoogq_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp70itoogq_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp70itoogq_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp70itoogq_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp70itoogq_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + need > remaining {\n        result = append(result,\
    \ remaining)\n        result = append(result, 0)\n    } else {\n        result\
    \ = append(result, number + need)\n        result = append(result, remaining -\
    \ (number + need))\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp70itoogq_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp70itoogq_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp70itoogq_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp70itoogq_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp70itoogq_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp70itoogq_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    } else {\n        return []int{number + remaining, 0}\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps0tk8cqk_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps0tk8cqk_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__4 (0.00s)\n        tmps0tk8cqk_test.go:60: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    } else\
    \ {\n        return []int{number + need, remaining - need}\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074982
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + need > remaining {\n        return []int{remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - (number + need)}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1_b0awz0_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1_b0awz0_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1_b0awz0_test.go:59: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp1_b0awz0_test.go:59: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1_b0awz0_test.go:59:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074982
