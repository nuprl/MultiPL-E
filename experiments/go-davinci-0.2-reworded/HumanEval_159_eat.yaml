name: HumanEval_159_eat
language: go_test.go
prompt: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
  \ a hungry rabbit, and you already have eaten a certain number of carrots,\n// but\
  \ now you need to eat more carrots to complete the day's meals.\n// you should return\
  \ a list of [ total number of eaten carrots after your meals,\n// the number of\
  \ carrots left after your meals ]\n// if there are not enough remaining carrots,\
  \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n//\
  \ >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>>\
  \ eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n\
  // @number : integer\n// the number of carrots that you have eaten.\n// @need :\
  \ integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n\
  // the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <=\
  \ number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun\
  \ :)\nfunc eat(number int, need int, remaining int) []int {\n"
tests: "func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
  \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
  \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
  \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
  \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
  \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
  \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if remaining < need {\n        return []int{number + remaining,\
    \ 0}\n    }\n    return []int{number + need, remaining - need}\n}\n", "    if\
    \ number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n", " \
    \   if remaining < need {\n        return []int{number + remaining, 0}\n    }\n\
    \    return []int{number + need, remaining - need}\n}\n", "    if number + need\
    \ > remaining {\n        return []int{remaining, 0}\n    }\n    return []int{number\
    \ + need, remaining - (number + need)}\n}\n", "    if number + need <= remaining\
    \ {\n        return []int{number + need, remaining - (number + need)}\n    } else\
    \ {\n        return []int{number + remaining, 0}\n    }\n}\n", "    if number\
    \ + need <= remaining {\n        return []int{number + need, remaining - (number\
    \ + need)}\n    }\n    return []int{number + remaining, 0}\n}\n", "    // your\
    \ code here\n    var result []int\n    if number + need > remaining {\n      \
    \  result = append(result, remaining)\n        result = append(result, 0)\n  \
    \  } else {\n        result = append(result, number + need)\n        result =\
    \ append(result, remaining - (number + need))\n    }\n    return result\n}\n",
  "    if remaining < need {\n        return []int{number + remaining, 0}\n    }\n\
    \    return []int{number + need, remaining - need}\n}\n", "    if number + need\
    \ > remaining {\n        return []int{remaining, 0}\n    }\n    return []int{number\
    \ + need, remaining - (number + need)}\n}\n", "    if number + need > remaining\
    \ {\n        return []int{remaining, 0}\n    }\n    return []int{number + need,\
    \ remaining - (number + need)}\n}\n", "    if number + need > remaining {\n  \
    \      return []int{remaining, 0}\n    }\n    return []int{number + need, remaining\
    \ - (number + need)}\n}\n", "    if number + need > remaining {\n        return\
    \ []int{remaining, 0}\n    }\n    return []int{number + need, remaining - (number\
    \ + need)}\n}\n", "    if remaining >= need {\n        return []int{number + need,\
    \ remaining - need}\n    }\n    return []int{number + remaining, 0}\n}\n", " \
    \   if number + need <= remaining {\n        return []int{number + need, remaining\
    \ - (number + need)}\n    }\n    return []int{number + remaining, 0}\n}\n", " \
    \   if remaining < need {\n        return []int{number + remaining, 0}\n    }\n\
    \    return []int{number + need, remaining - need}\n}\n", "    if number + need\
    \ <= remaining {\n        return []int{number + need, remaining - (number + need)}\n\
    \    }\n    return []int{number + remaining, 0}\n}\n", "    if remaining < need\
    \ {\n        return []int{number + remaining, 0}\n    }\n    return []int{number\
    \ + need, remaining - need}\n}\n", "    if number + need > remaining {\n     \
    \   return []int{remaining, 0}\n    }\n    return []int{number + need, remaining\
    \ - (number + need)}\n}\n", "    if remaining < need {\n        return []int{number\
    \ + remaining, 0}\n    }\n    return []int{number + need, remaining - need}\n\
    }\n", "    if remaining < need {\n        return []int{number + remaining, 0}\n\
    \    }\n    return []int{number + need, remaining - need}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
