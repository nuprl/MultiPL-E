language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp218w7pfy_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index < planet2Index {\n\
    \        for i := planet1Index + 1; i < planet2Index; i++ {\n            result\
    \ = append(result, planets[i])\n        }\n    } else {\n        for i := planet1Index\
    \ - 1; i > planet2Index; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpvwtphqws_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpvwtphqws_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpvwtphqws_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index < planet2Index {\n      \
    \  return planets[planet1Index+1:planet2Index]\n    } else {\n        return planets[planet2Index+1:planet1Index]\n\
    \    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxok8_ih6_test.go:40:23: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    /tmp/tmpxok8_ih6_test.go:42:23: cannot use planets[planet2Index + 1:planet1Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, v := range planets {\n    \
    \    if v == planet1 {\n            start = i\n        }\n        if v == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97j342y2_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp218w7pfy_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    return planets[start+1:end]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamp8a3qm_test.go:38:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var p1, p2 int\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            p1 = i\n        }\n\
    \        if p == planet2 {\n            p2 = i\n        }\n    }\n    if p1 >\
    \ p2 {\n        p1, p2 = p2, p1\n    }\n    for i := p1+1; i < p2; i++ {\n   \
    \     res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp4sutwvw8_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start > end {\n        start,\
    \ end = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm2amqtum_test.go:38:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            index1 = i\n        }\n     \
    \   if planet == planet2 {\n            index2 = i\n        }\n    }\n    if index1\
    \ == index2 {\n        return []interface{}{}\n    }\n    if index1 > index2 {\n\
    \        index1, index2 = index2, index1\n    }\n    return planets[index1+1:index2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdmz6_fv_test.go:41:19: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result = []interface{}{}\n    var start, end int\n   \
    \ for i, planet := range planets {\n        if planet == planet1 {\n         \
    \   start = i\n        }\n        if planet == planet2 {\n            end = i\n\
    \        }\n    }\n    if start > end {\n        start, end = end, start\n   \
    \ }\n    for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp4uwk2gv0_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    return planets[start+1:end]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamp8a3qm_test.go:38:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start < end {\n        for i := start + 1; i < end; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    } else {\n        for i\
    \ := start - 1; i > end; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp4mnovpwa_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp4mnovpwa_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp4mnovpwa_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp218w7pfy_test.go:42:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index < planet2Index {\n\
    \        for i := planet1Index + 1; i < planet2Index; i++ {\n            result\
    \ = append(result, planets[i])\n        }\n    } else {\n        for i := planet1Index\
    \ - 1; i > planet2Index; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpvwtphqws_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpvwtphqws_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpvwtphqws_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index > planet2Index {\n\
    \        planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    for\
    \ i := planet1Index + 1; i < planet2Index; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp11vgx0d5_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp11vgx0d5_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index < planet2Index {\n\
    \        for i := planet1Index + 1; i < planet2Index; i++ {\n            result\
    \ = append(result, planets[i])\n        }\n    } else {\n        for i := planet1Index\
    \ - 1; i > planet2Index; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpvwtphqws_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpvwtphqws_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpvwtphqws_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnhv4kdax_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnhv4kdax_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpskfcbe5c_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpskfcbe5c_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpskfcbe5c_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpskfcbe5c_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      start = i\n        }\n        if planet == planet2 {\n            end =\
    \ i\n        }\n    }\n    if start > end {\n        start, end = end, start\n\
    \    }\n    for i := start + 1; i < end; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpt7cggpc2_test.go:65: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7o4cp_4n_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            i1 = i\n        }\n        if p == planet2 {\n \
    \           i2 = i\n        }\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n\
    \    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphzs0d8s9_test.go:38:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpebncm52__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpskfcbe5c_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpskfcbe5c_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpskfcbe5c_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpskfcbe5c_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpny8foqwg_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpqy0bhp91_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpk1czhv0i_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpk1czhv0i_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start <\
    \ end {\n        for i := start + 1; i < end; i++ {\n            result = append(result,\
    \ planets[i])\n        }\n    } else {\n        for i := start - 1; i > end; i--\
    \ {\n            result = append(result, planets[i])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp5pb68pgt_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp5pb68pgt_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp5pb68pgt_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    return planets[start+1:end]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamp8a3qm_test.go:38:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, v := range planets {\n        if v == planet1 {\n            start\
    \ = i\n        }\n        if v == planet2 {\n            end = i\n        }\n\
    \    }\n    if start > end {\n        start, end = end, start\n    }\n    for\
    \ i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpusgu61c8_test.go:65: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var ret []interface{}\n    var start, end int\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return ret\n    }\n    if\
    \ start > end {\n        start, end = end, start\n    }\n    for i := start +\
    \ 1; i < end; i++ {\n        ret = append(ret, planets[i])\n    }\n    return\
    \ ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpeos_mmik_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpeos_mmik_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            i1 = i\n        }\n        if p == planet2 {\n \
    \           i2 = i\n        }\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n\
    \    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphzs0d8s9_test.go:38:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    var result []interface{}\n    if planet1Index >\
    \ planet2Index {\n        for i := planet2Index; i < planet1Index; i++ {\n   \
    \         result = append(result, planets[i])\n        }\n    } else {\n     \
    \   for i := planet1Index; i < planet2Index; i++ {\n            result = append(result,\
    \ planets[i])\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpr83znwwo_test.go:70: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpr83znwwo_test.go:70:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpr83znwwo_test.go:70: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpr83znwwo_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter\
    \ Saturn Uranus]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpr83znwwo_test.go:70:\
    \ expected '[]', got '[Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    return planets[start+1:end]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamp8a3qm_test.go:38:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start int\n    var end int\n\
    \    for i, v := range planets {\n        if v == planet1 {\n            start\
    \ = i\n        }\n        if v == planet2 {\n            end = i\n        }\n\
    \    }\n    if start > end {\n        start, end = end, start\n    }\n    for\
    \ i := start + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n\
    \    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpezf9f8cf_test.go:65: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    var result []interface{}\n    for i, v\
    \ := range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return result\n    }\n    if p1 < p2 {\n        for\
    \ i := p1 + 1; i < p2; i++ {\n            result = append(result, planets[i])\n\
    \        }\n    } else {\n        for i := p2 + 1; i < p1; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    }\n    return result\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmptfne7ztu_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmptfne7ztu_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpny2toxg6_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var res []interface{}\n    var start, end int\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            start = i\n   \
    \     }\n        if p == planet2 {\n            end = i\n        }\n    }\n  \
    \  if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return\
    \ res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpqy0bhp91_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      start = i\n        }\n        if planet == planet2 {\n            end =\
    \ i\n        }\n    }\n    if start > end {\n        start, end = end, start\n\
    \    }\n    for i := start + 1; i < end; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpt7cggpc2_test.go:65: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start < end {\n        for i := start + 1; i < end; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    } else {\n        for i\
    \ := start - 1; i > end; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpq581s65s_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpq581s65s_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpq581s65s_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index < planet2Index {\n\
    \        for i := planet1Index + 1; i < planet2Index; i++ {\n            result\
    \ = append(result, planets[i])\n        }\n    } else {\n        for i := planet1Index\
    \ - 1; i > planet2Index; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpvwtphqws_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpvwtphqws_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpvwtphqws_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpebncm52__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnhv4kdax_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnhv4kdax_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpebncm52__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    var result []interface{}\n    for i, v\
    \ := range planets {\n        if v == planet1 {\n            p1 = i\n        }\n\
    \        if v == planet2 {\n            p2 = i\n        }\n    }\n    if p1 ==\
    \ 0 || p2 == 0 {\n        return result\n    }\n    if p1 < p2 {\n        for\
    \ i := p1 + 1; i < p2; i++ {\n            result = append(result, planets[i])\n\
    \        }\n    } else {\n        for i := p2 + 1; i < p1; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    }\n    return result\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmptfne7ztu_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmptfne7ztu_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnhv4kdax_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnhv4kdax_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ nil\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n    return planets[p1+1:p2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1hc21jlz_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7o4cp_4n_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnhv4kdax_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnhv4kdax_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpny2toxg6_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnhv4kdax_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnhv4kdax_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7o4cp_4n_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpny8foqwg_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end {\n\
    \        start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpebncm52__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            index1 = i\n        }\n     \
    \   if planet == planet2 {\n            index2 = i\n        }\n    }\n    if index1\
    \ == 0 || index2 == 0 {\n        return []interface{}{}\n    }\n    if index1\
    \ > index2 {\n        index1, index2 = index2, index1\n    }\n    return planets[index1+1:index2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqm67rk78_test.go:41:19: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      } else if planet == planet2 {\n            planet2Index = i\n        }\n\
    \    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return []interface{}{}\n\
    \    }\n    if planet1Index > planet2Index {\n        planet1Index, planet2Index\
    \ = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptzvv6q15_test.go:40:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnhv4kdax_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnhv4kdax_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7o4cp_4n_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    var result []interface{}\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpcmxqdx4y_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start int\n    var end int\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      start = i\n        }\n        if planet == planet2 {\n            end =\
    \ i\n        }\n    }\n    if start > end {\n        start, end = end, start\n\
    \    }\n    for i := start + 1; i < end; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpt7cggpc2_test.go:65: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmptdxa5e59_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmptdxa5e59_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmptdxa5e59_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmptdxa5e59_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpny2toxg6_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1_index, planet2_index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1_index = i\n        }\n        if planet == planet2 {\n        \
    \    planet2_index = i\n        }\n    }\n    if planet1_index == 0 || planet2_index\
    \ == 0 {\n        return result\n    }\n    if planet1_index > planet2_index {\n\
    \        for i := planet2_index; i <= planet1_index; i++ {\n            result\
    \ = append(result, planets[i])\n        }\n    } else {\n        for i := planet1_index;\
    \ i <= planet2_index; i++ {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpgyc2e634_test.go:70: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpgyc2e634_test.go:70:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpgyc2e634_test.go:70: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpgyc2e634_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter\
    \ Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpgyc2e634_test.go:70:\
    \ expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n   \
    \     tmpgyc2e634_test.go:70: expected '[]', got '[Earth Mars]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // TODO: implement\
    \ me\n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpvf_ijxz0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpvf_ijxz0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpvf_ijxz0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpvf_ijxz0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjngedkdf_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   var result []interface{}\n    for i := p1 + 1; i < p2; i++ {\n        result\
    \ = append(result, planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpm0y1u2na_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpm0y1u2na_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            index1 = i\n        }\n        if p ==\
    \ planet2 {\n            index2 = i\n        }\n    }\n    if index1 > index2\
    \ {\n        index1, index2 = index2, index1\n    }\n    return planets[index1+1:index2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp64xu3ocl_test.go:38:19: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfzpxvdi__test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var p1, p2 int\n    for i, p\
    \ := range planets {\n        if p == planet1 {\n            p1 = i\n        }\n\
    \        if p == planet2 {\n            p2 = i\n        }\n    }\n    if p1 >\
    \ p2 {\n        p1, p2 = p2, p1\n    }\n    for i := p1 + 1; i < p2; i++ {\n \
    \       result = append(result, planets[i])\n    }\n    return result\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpqxw_5jgs_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    var ret []interface{}\n    if p1 < p2 {\n      \
    \  for i := p1 + 1; i < p2; i++ {\n            ret = append(ret, planets[i])\n\
    \        }\n    } else {\n        for i := p2 + 1; i < p1; i++ {\n           \
    \ ret = append(ret, planets[i])\n        }\n    }\n    return ret\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpogw7499t_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpogw7499t_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var index1, index2 int\n   \
    \ for i, planet := range planets {\n        if planet == planet1 {\n         \
    \   index1 = i\n        }\n        if planet == planet2 {\n            index2\
    \ = i\n        }\n    }\n    if index1 == index2 {\n        return result\n  \
    \  }\n    if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n\
    \    for i := index1 + 1; i < index2; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmppnn75zrt_test.go:67: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjngedkdf_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index > planet2Index {\n\
    \        planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    for\
    \ i := planet1Index + 1; i < planet2Index; i++ {\n        result = append(result,\
    \ planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp2j5rlmp4_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpny2toxg6_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n       \
    \ return []interface{}{}\n    }\n    if planet1Index > planet2Index {\n      \
    \  planet1Index, planet2Index = planet2Index, planet1Index\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpny8foqwg_test.go:42:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc1j6fgsx_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmptdxa5e59_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmptdxa5e59_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmptdxa5e59_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmptdxa5e59_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   for i := start; i <= end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp6kf5tfpu_test.go:64: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp6kf5tfpu_test.go:64:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmp6kf5tfpu_test.go:64: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp6kf5tfpu_test.go:64:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4\
    \ (0.00s)\n        tmp6kf5tfpu_test.go:64: expected '[]', got '[Earth]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    start := 0\n    end := 0\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            start = i\n        }\n        if p ==\
    \ planet2 {\n            end = i\n        }\n    }\n    if start == 0 || end ==\
    \ 0 {\n        return nil\n    }\n    if start > end {\n        start, end = end,\
    \ start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2zdkvade_test.go:42:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    return planets[start+1:end]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamp8a3qm_test.go:38:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == 0 || end == 0 {\n        return result\n    }\n    if start <\
    \ end {\n        result = planets[start+1:end]\n    } else {\n        result =\
    \ planets[end+1:start]\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnhk_oyg6_test.go:40:25: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in assignment

    /tmp/tmpnhk_oyg6_test.go:42:25: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc1j6fgsx_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, p := range planets {\n    \
    \    if p == planet1 {\n            start = i\n        }\n        if p == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == 0 || end == 0 {\n\
    \        return []interface{}{}\n    }\n    if start < end {\n        return planets[start+1:end]\n\
    \    }\n    return planets[end+1:start]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmlcvuhdk_test.go:39:23: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    /tmp/tmpmlcvuhdk_test.go:41:19: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpny2toxg6_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            p1 = i\n        }\n        if planet\
    \ == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == 0 || p2 ==\
    \ 0 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2\
    \ = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc1j6fgsx_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var planet1Index, planet2Index\
    \ int\n    for i, planet := range planets {\n        if planet == planet1 {\n\
    \            planet1Index = i\n        }\n        if planet == planet2 {\n   \
    \         planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index < planet2Index {\n\
    \        for i := planet1Index + 1; i < planet2Index; i++ {\n            result\
    \ = append(result, planets[i])\n        }\n    } else {\n        for i := planet2Index\
    \ + 1; i < planet1Index; i++ {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpcx87_jbm_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpcx87_jbm_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmper_28khi_test.go:67: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmper_28khi_test.go:67: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpz6wplx3j_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            start = i\n        }\n        if\
    \ planet == planet2 {\n            end = i\n        }\n    }\n    if start ==\
    \ end {\n        return []interface{}{}\n    }\n    if start > end {\n       \
    \ start, end = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmaprreov_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var found1, found2 bool\n  \
    \  var i1, i2 int\n    for i, planet := range planets {\n        if planet ==\
    \ planet1 {\n            found1 = true\n            i1 = i\n        }\n      \
    \  if planet == planet2 {\n            found2 = true\n            i2 = i\n   \
    \     }\n    }\n    if !found1 || !found2 {\n        return result\n    }\n  \
    \  if i1 < i2 {\n        result = planets[i1+1:i2]\n    } else {\n        result\
    \ = planets[i2+1:i1]\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5to36wyo_test.go:43:25: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in assignment

    /tmp/tmp5to36wyo_test.go:45:25: cannot use planets[i2 + 1:i1] (value of type []string)
    as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        result = append(result, planets[i])\n    }\n  \
    \  return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjngedkdf_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var index1, index2 int\n   \
    \ for i, planet := range planets {\n        if planet == planet1 {\n         \
    \   index1 = i\n        }\n        if planet == planet2 {\n            index2\
    \ = i\n        }\n    }\n    if index1 > index2 {\n        index1, index2 = index2,\
    \ index1\n    }\n    for i := index1 + 1; i < index2; i++ {\n        result =\
    \ append(result, planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpjbv0nzgf_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Saturn\", \"Uranus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpkvknatzv_test.go:47: expected '[Venus]', got '[Saturn Uranus]'\n   \
    \ --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpkvknatzv_test.go:47: expected\
    \ '[Venus Earth Mars Jupiter Saturn]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpkvknatzv_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n\
    \        tmpkvknatzv_test.go:47: expected '[]', got '[Saturn Uranus]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpkvknatzv_test.go:47: expected '[]',\
    \ got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpkvknatzv_test.go:47:\
    \ expected '[]', got '[Saturn Uranus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start == 0 || end == 0 {\n        return result\n    }\n \
    \   if start < end {\n        for i := start + 1; i < end; i++ {\n           \
    \ result = append(result, planets[i])\n        }\n    } else {\n        for i\
    \ := start - 1; i > end; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp4mnovpwa_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp4mnovpwa_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp4mnovpwa_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n    }\n \
    \   return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_wwf12o_test.go:41:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnhv4kdax_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnhv4kdax_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, planet := range planets {\n        if planet == planet1 {\n            start\
    \ = i\n        }\n        if planet == planet2 {\n            end = i\n      \
    \  }\n    }\n    if start > end {\n        start, end = end, start\n    }\n  \
    \  for i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpuujsppva_test.go:64: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1Index = i\n  \
    \      }\n        if planet == planet2 {\n            planet2Index = i\n     \
    \   }\n    }\n    if planet1Index == 0 || planet2Index == 0 {\n        return\
    \ []interface{}{}\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    return planets[planet1Index+1:planet2Index]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqumq0sq_test.go:41:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n    var result []interface{}\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n        }\n        if planet == planet2 {\n         \
    \   planet2Index = i\n        }\n    }\n    if planet1Index == 0 || planet2Index\
    \ == 0 {\n        return result\n    }\n    if planet1Index < planet2Index {\n\
    \        for i := planet1Index + 1; i < planet2Index; i++ {\n            result\
    \ = append(result, planets[i])\n        }\n    } else {\n        for i := planet1Index\
    \ - 1; i > planet2Index; i-- {\n            result = append(result, planets[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpvwtphqws_test.go:70: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpvwtphqws_test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpvwtphqws_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Uranus Saturn Jupiter Mars\
    \ Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
