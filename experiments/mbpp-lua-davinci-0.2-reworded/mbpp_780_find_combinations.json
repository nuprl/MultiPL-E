{
  "name": "mbpp_780_find_combinations",
  "language": "lua",
  "prompt": "-- Write a function to find the combinations of sums with tables in the given table table. https://www.geeksforgeeks.org/luathon-combinations-of-sum-with-tables-in-table-table/\nlocal function find_combinations(test_list)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py",
  "prompt_terminology": "reworded",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_combinations\n    lu.assertEquals(candidate({{2, 4}, {6, 7}, {5, 1}, {6, 10}}), {{8, 11}, {7, 5}, {8, 14}, {11, 8}, {12, 17}, {11, 11}})\n    lu.assertEquals(candidate({{3, 5}, {7, 8}, {6, 2}, {7, 11}}), {{10, 13}, {9, 7}, {10, 16}, {13, 10}, {14, 19}, {13, 13}})\n    lu.assertEquals(candidate({{4, 6}, {8, 9}, {7, 3}, {8, 12}}), {{12, 15}, {11, 9}, {12, 18}, {15, 12}, {16, 21}, {15, 15}})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if sum < 0 or index < 1 then\n            return\n        end\n        find_combinations_rec(test_list, index - 1, sum, curr_list)\n        local new_list = table.copy(curr_list)\n        table.insert(new_list, test_list[index])\n        find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n    end\n    find_combinations_rec(test_list, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 10, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if sum < 0 or index < 1 then\n      return\n    end\n    find_combinations_rec(test_list, index - 1, sum, curr_list)\n    local new_list = {}\n    for i, v in ipairs(curr_list) do\n      new_list[i] = v\n    end\n    table.insert(new_list, test_list[index])\n    find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n  end\n  find_combinations_rec(test_list, #test_list, 8, {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, cur_list)\n        if sum == 0 then\n            table.insert(result, cur_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, cur_list)\n        else\n            find_combinations_rec(test_list, index - 1, sum, cur_list)\n            local new_list = {}\n            for _, v in ipairs(cur_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 8, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, sum, current_list)\n        local new_list = {}\n        for i = 1, #current_list do\n            table.insert(new_list, current_list[i])\n        end\n        table.insert(new_list, test_list[index])\n        find_combinations_helper(test_list, index + 1, sum - test_list[index], new_list)\n    end\n    find_combinations_helper(test_list, 1, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, partial_sum, partial_list)\n        local sum = 0\n        for i, v in ipairs(partial_list) do\n            sum = sum + v\n        end\n        if sum == partial_sum then\n            table.insert(result, partial_list)\n        end\n        if index == #test_list then\n            return\n        end\n        find_combinations_recursive(test_list, index + 1, partial_sum, partial_list)\n        table.insert(partial_list, test_list[index])\n        find_combinations_recursive(test_list, index + 1, partial_sum, partial_list)\n        table.remove(partial_list)\n    end\n    find_combinations_recursive(test_list, 1, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if sum < 0 or index < 1 then\n            return\n        end\n        find_combinations_recursive(test_list, index - 1, sum, curr_list)\n        local new_list = {}\n        for _, v in ipairs(curr_list) do\n            table.insert(new_list, v)\n        end\n        table.insert(new_list, test_list[index])\n        find_combinations_recursive(test_list, index - 1, sum - test_list[index], new_list)\n    end\n    find_combinations_recursive(test_list, #test_list, test_list[#test_list], {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_helper(test_list, index, current_sum, current_list)\n    if current_sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    find_combinations_helper(test_list, index - 1, current_sum, current_list)\n    if current_sum >= test_list[index] then\n      find_combinations_helper(test_list, index - 1, current_sum - test_list[index], {test_list[index], unpack(current_list)})\n    end\n  end\n  find_combinations_helper(test_list, #test_list, 10, {})\n  return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, start_index, current_sum, current_list)\n    if current_sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    for i = start_index, #test_list do\n      if test_list[i] <= current_sum then\n        find_combinations_rec(test_list, i, current_sum - test_list[i], {table.unpack(current_list), test_list[i]})\n      end\n    end\n  end\n  find_combinations_rec(test_list, 1, 10, {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] <= current_sum then\n            find_combinations_recursive(test_list, index - 1, current_sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n        find_combinations_recursive(test_list, index - 1, current_sum, current_list)\n    end\n    find_combinations_recursive(test_list, #test_list, #test_list, {})\n    return result\nend",
    "  local combinations = {}\n  local function find_combinations_recursive(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(combinations, current_list)\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    if sum < 0 then\n      return\n    end\n    find_combinations_recursive(test_list, index + 1, sum, current_list)\n    local new_list = {}\n    for _, v in ipairs(current_list) do\n      table.insert(new_list, v)\n    end\n    table.insert(new_list, test_list[index])\n    find_combinations_recursive(test_list, index + 1, sum - test_list[index], new_list)\n  end\n  find_combinations_recursive(test_list, 1, test_list[1], {})\n  return combinations\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list or sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, sum, current_list)\n        find_combinations_helper(test_list, index + 1, sum - test_list[index], {table.unpack(current_list), test_list[index]})\n    end\n    find_combinations_helper(test_list, 1, 4, {})\n    return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, curr_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, curr_list)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_rec(test_list, index-1, sum, curr_list)\n\t\telse\n\t\t\tfind_combinations_rec(test_list, index-1, sum, curr_list)\n\t\t\tlocal new_list = {}\n\t\t\tfor _, v in ipairs(curr_list) do\n\t\t\t\ttable.insert(new_list, v)\n\t\t\tend\n\t\t\ttable.insert(new_list, test_list[index])\n\t\t\tfind_combinations_rec(test_list, index-1, sum-test_list[index], new_list)\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, #test_list, 4, {})\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_rec(test_list, index - 1, sum, current_list)\n            local new_list = {}\n            for _, v in ipairs(current_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 5, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, sum, current_list)\n        if sum >= test_list[index] then\n            find_combinations_helper(test_list, index + 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n    end\n    find_combinations_helper(test_list, 1, 10, {})\n    return result\nend",
    "  local function find_combinations_helper(test_list, target_sum, current_sum, current_index, current_combination, result)\n    if current_sum == target_sum then\n      table.insert(result, current_combination)\n      return\n    end\n    if current_sum > target_sum then\n      return\n    end\n    for i = current_index, #test_list do\n      local new_combination = {}\n      for _, v in ipairs(current_combination) do\n        table.insert(new_combination, v)\n      end\n      table.insert(new_combination, test_list[i])\n      find_combinations_helper(test_list, target_sum, current_sum + test_list[i], i + 1, new_combination, result)\n    end\n  end\n  local result = {}\n  find_combinations_helper(test_list, 10, 0, 1, {}, result)\n  return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, path)\n        if sum == 0 then\n            table.insert(result, path)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        if test_list[index] <= sum then\n            find_combinations_helper(test_list, index + 1, sum - test_list[index], path .. \" \" .. test_list[index])\n        end\n        find_combinations_helper(test_list, index + 1, sum, path)\n    end\n    find_combinations_helper(test_list, 1, 10, \"\")\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            table.insert(current_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], current_list)\n            table.remove(current_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 10, {})\n    return result\nend",
    "  local function find_combinations_rec(test_list, index, sum, current_list)\n    if sum == 0 then\n      return {current_list}\n    end\n    if index == 0 then\n      return {}\n    end\n    if test_list[index] > sum then\n      return find_combinations_rec(test_list, index - 1, sum, current_list)\n    end\n    local result = {}\n    local result1 = find_combinations_rec(test_list, index - 1, sum, current_list)\n    local result2 = find_combinations_rec(test_list, index - 1, sum - test_list[index], current_list .. test_list[index] .. \" \")\n    for _, v in ipairs(result1) do\n      table.insert(result, v)\n    end\n    for _, v in ipairs(result2) do\n      table.insert(result, v)\n    end\n    return result\n  end\n  return find_combinations_rec(test_list, #test_list, test_list[1], \"\")\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, combination)\n    if sum == 0 then\n      table.insert(result, combination)\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    local current_number = test_list[index]\n    if current_number <= sum then\n      find_combinations_rec(test_list, index + 1, sum - current_number, combination .. \" \" .. current_number)\n    end\n    find_combinations_rec(test_list, index + 1, sum, combination)\n  end\n  find_combinations_rec(test_list, 1, 4, \"\")\n  return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 or current_sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index - 1, current_sum, current_list)\n        local new_list = table.copy(current_list)\n        table.insert(new_list, test_list[index])\n        find_combinations_helper(test_list, index - 1, current_sum - test_list[index], new_list)\n    end\n    find_combinations_helper(test_list, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if sum < 0 or index < 1 then\n            return\n        end\n        find_combinations_rec(test_list, index - 1, sum, current_list)\n        table.insert(current_list, test_list[index])\n        find_combinations_rec(test_list, index - 1, sum - test_list[index], current_list)\n        table.remove(current_list)\n    end\n    find_combinations_rec(test_list, #test_list, test_list[1], {})\n    return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, curr_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, curr_list)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, curr_list)\n\t\telse\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, curr_list)\n\t\t\tcurr_list[index] = true\n\t\t\tfind_combinations_rec(test_list, index - 1, sum - test_list[index], curr_list)\n\t\t\tcurr_list[index] = nil\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, #test_list, 10, {})\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, curr_list)\n        else\n            find_combinations_rec(test_list, index - 1, sum, curr_list)\n            local new_list = {}\n            for i, v in ipairs(curr_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 10, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_recursive(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    local current_element = test_list[index]\n    find_combinations_recursive(test_list, index + 1, sum, current_list)\n    find_combinations_recursive(test_list, index + 1, sum - current_element, {current_element, unpack(current_list)})\n  end\n  find_combinations_recursive(test_list, 1, 8, {})\n  return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, current_sum, current_list)\n\t\tif current_sum == 0 then\n\t\t\ttable.insert(result, current_list)\n\t\t\treturn\n\t\tend\n\t\tif index > #test_list or current_sum < 0 then\n\t\t\treturn\n\t\tend\n\t\tfind_combinations_rec(test_list, index + 1, current_sum, current_list)\n\t\tlocal new_list = table.copy(current_list)\n\t\ttable.insert(new_list, test_list[index])\n\t\tfind_combinations_rec(test_list, index + 1, current_sum - test_list[index], new_list)\n\tend\n\tfind_combinations_rec(test_list, 1, 5, {})\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, start, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        for i = start, #test_list do\n            if test_list[i] > sum then\n                break\n            end\n            find_combinations_helper(test_list, i, sum - test_list[i], {test_list[i], unpack(current_list)})\n        end\n    end\n    find_combinations_helper(test_list, 1, test_list[1], {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, sum, current_list)\n        find_combinations_helper(test_list, index + 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n    end\n    find_combinations_helper(test_list, 1, test_list[1], {})\n    return result\nend",
    "  local result = {}\n  for i = 1, #test_list do\n    for j = i + 1, #test_list do\n      local sum = test_list[i] + test_list[j]\n      if result[sum] then\n        result[sum] = result[sum] .. \", \" .. test_list[i] .. \", \" .. test_list[j]\n      else\n        result[sum] = test_list[i] .. \", \" .. test_list[j]\n      end\n    end\n  end\n  return result\nend",
    "    local combinations = {}\n    for i = 1, #test_list do\n        local sum = test_list[i]\n        local combination = {}\n        for j = 1, #test_list do\n            if i ~= j then\n                combination[#combination + 1] = test_list[j]\n            end\n        end\n        combinations[sum] = combination\n    end\n    return combinations\nend",
    "  local result = {}\n  local function find_combinations_recursive(test_list, index, sum, temp)\n    if sum == 0 then\n      table.insert(result, temp)\n      return\n    end\n    if sum < 0 then\n      return\n    end\n    for i = index, #test_list do\n      table.insert(temp, test_list[i])\n      find_combinations_recursive(test_list, i, sum - test_list[i], temp)\n      table.remove(temp)\n    end\n  end\n  find_combinations_recursive(test_list, 1, test_list[1], {})\n  return result\nend",
    "\tlocal function find_combinations_rec(test_list, start, end_index, sum, current_sum, current_list)\n\t\tif current_sum == sum then\n\t\t\tprint(table.concat(current_list, \" + \"))\n\t\t\treturn\n\t\tend\n\t\tif current_sum > sum then\n\t\t\treturn\n\t\tend\n\t\tfor i = start, end_index do\n\t\t\ttable.insert(current_list, test_list[i])\n\t\t\tfind_combinations_rec(test_list, i + 1, end_index, sum, current_sum + test_list[i], current_list)\n\t\t\ttable.remove(current_list)\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, 1, #test_list, 10, 0, {})\nend",
    "    local result = {}\n    local n = #test_list\n    local function find_combinations_rec(test_list, i, sum, result)\n        if sum == 0 then\n            table.insert(result, {})\n            return\n        end\n        if i == 0 then\n            return\n        end\n        if test_list[i] > sum then\n            find_combinations_rec(test_list, i - 1, sum, result)\n        else\n            local temp = {}\n            find_combinations_rec(test_list, i - 1, sum, temp)\n            for _, v in ipairs(temp) do\n                table.insert(result, v)\n            end\n            temp = {}\n            find_combinations_rec(test_list, i - 1, sum - test_list[i], temp)\n            for _, v in ipairs(temp) do\n                table.insert(v, test_list[i])\n                table.insert(result, v)\n            end\n        end\n    end\n    find_combinations_rec(test_list, n, test_list[n], result)\n    return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        find_combinations_recursive(test_list, index + 1, sum, current_list)\n        table.insert(current_list, test_list[index])\n        find_combinations_recursive(test_list, index + 1, sum - test_list[index], current_list)\n        table.remove(current_list)\n    end\n    find_combinations_recursive(test_list, 1, 5, {})\n    return result\nend",
    "    local combinations = {}\n    local function find_combinations_rec(test_list, index, sum, combination)\n        if sum == 0 then\n            table.insert(combinations, combination)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        find_combinations_rec(test_list, index + 1, sum, combination)\n        combination = combination or {}\n        table.insert(combination, test_list[index])\n        find_combinations_rec(test_list, index + 1, sum - test_list[index], combination)\n    end\n    find_combinations_rec(test_list, 1, 7)\n    return combinations\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, current_sum, current_list)\n\t\tif current_sum == 0 then\n\t\t\ttable.insert(result, current_list)\n\t\t\treturn\n\t\tend\n\t\tif index > #test_list then\n\t\t\treturn\n\t\tend\n\t\tif current_sum < 0 then\n\t\t\treturn\n\t\tend\n\t\tfind_combinations_rec(test_list, index + 1, current_sum - test_list[index], {table.unpack(current_list), test_list[index]})\n\t\tfind_combinations_rec(test_list, index + 1, current_sum, current_list)\n\tend\n\tfind_combinations_rec(test_list, 1, 10, {})\n\treturn result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    else\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n      local new_list = {}\n      for i, v in ipairs(curr_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend",
    "  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      print(table.concat(curr_list, \" \"))\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    else\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n      table.insert(curr_list, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], curr_list)\n      table.remove(curr_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\nend",
    "\tlocal combinations = {}\n\tlocal function find_combinations_recursive(test_list, index, sum, current_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(combinations, current_list)\n\t\t\treturn\n\t\tend\n\t\tif sum < 0 or index < 0 then\n\t\t\treturn\n\t\tend\n\t\tfind_combinations_recursive(test_list, index - 1, sum, current_list)\n\t\tfind_combinations_recursive(test_list, index - 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n\tend\n\tfind_combinations_recursive(test_list, #test_list, test_list[#test_list], {})\n\treturn combinations\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if current_sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index - 1, current_sum, current_list)\n        local new_list = {}\n        for _, v in ipairs(current_list) do\n            table.insert(new_list, v)\n        end\n        table.insert(new_list, test_list[index])\n        find_combinations_helper(test_list, index - 1, current_sum - test_list[index], new_list)\n    end\n    find_combinations_helper(test_list, #test_list, test_list[#test_list], {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, result, current)\n        if sum == 0 then\n            table.insert(result, current)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, result, current)\n        else\n            find_combinations_rec(test_list, index - 1, sum, result, current)\n            local new_current = {}\n            for i = 1, #current do\n                table.insert(new_current, current[i])\n            end\n            table.insert(new_current, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], result, new_current)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, test_list[#test_list], result, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, start_index, end_index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if sum < 0 or start_index > end_index then\n            return\n        end\n        find_combinations_helper(test_list, start_index + 1, end_index, sum, current_list)\n        local new_list = table.clone(current_list)\n        table.insert(new_list, test_list[start_index])\n        find_combinations_helper(test_list, start_index + 1, end_index, sum - test_list[start_index], new_list)\n    end\n    find_combinations_helper(test_list, 1, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        local curr_list_copy = {}\n        for _, v in ipairs(curr_list) do\n            table.insert(curr_list_copy, v)\n        end\n        find_combinations_rec(test_list, index + 1, sum, curr_list_copy)\n        table.insert(curr_list, test_list[index])\n        find_combinations_rec(test_list, index + 1, sum - test_list[index], curr_list)\n    end\n    find_combinations_rec(test_list, 1, 7, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_recursive(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_recursive(test_list, index - 1, sum, curr_list)\n    else\n      local new_list = table.copy(curr_list)\n      table.insert(new_list, test_list[index])\n      find_combinations_recursive(test_list, index - 1, sum - test_list[index], new_list)\n      find_combinations_recursive(test_list, index - 1, sum, curr_list)\n    end\n  end\n  find_combinations_recursive(test_list, #test_list, 10, {})\n  return result\nend",
    "\tlocal function find_combinations_helper(test_list, index, sum, current_list, result_list)\n\t\tif sum == 0 then\n\t\t\tresult_list[#result_list + 1] = current_list\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] <= sum then\n\t\t\tfind_combinations_helper(test_list, index - 1, sum - test_list[index], {test_list[index], unpack(current_list)}, result_list)\n\t\tend\n\t\tfind_combinations_helper(test_list, index - 1, sum, current_list, result_list)\n\tend\n\tlocal result_list = {}\n\tfind_combinations_helper(test_list, #test_list, test_list[1], {}, result_list)\n\treturn result_list\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_recursive(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_recursive(test_list, index - 1, sum, current_list)\n            find_combinations_recursive(test_list, index - 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n    end\n    find_combinations_recursive(test_list, #test_list, 10, {})\n    return result\nend",
    "    local function find_combinations_recursive(test_list, start_index, end_index, sum, current_sum, current_list)\n        if current_sum == sum then\n            print(table.concat(current_list, \" + \"))\n            return\n        end\n        if current_sum > sum then\n            return\n        end\n        for i = start_index, end_index do\n            table.insert(current_list, test_list[i])\n            find_combinations_recursive(test_list, i + 1, end_index, sum, current_sum + test_list[i], current_list)\n            table.remove(current_list)\n        end\n    end\n    find_combinations_recursive(test_list, 1, #test_list, 8, 0, {})\nend",
    "  local combinations = {}\n  local function find_combinations_recursive(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(combinations, current_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_recursive(test_list, index - 1, sum, current_list)\n    else\n      find_combinations_recursive(test_list, index - 1, sum, current_list)\n      local new_list = {}\n      for _, v in ipairs(current_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_recursive(test_list, index - 1, sum - test_list[index], new_list)\n    end\n  end\n  find_combinations_recursive(test_list, #test_list, 5, {})\n  return combinations\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        if current_sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, current_sum, current_list)\n        find_combinations_helper(test_list, index + 1, current_sum - test_list[index], {table.unpack(current_list), test_list[index]})\n    end\n    find_combinations_helper(test_list, 1, 5, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, curr_list)\n        else\n            find_combinations_rec(test_list, index - 1, sum, curr_list)\n            local new_list = {}\n            for i, v in ipairs(curr_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 8, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_helper(list, sum, index, partial)\n    local partial_sum = 0\n    for _, v in ipairs(partial) do\n      partial_sum = partial_sum + v\n    end\n    if partial_sum == sum then\n      table.insert(result, partial)\n    end\n    for i = index, #list do\n      local new_partial = {}\n      for _, v in ipairs(partial) do\n        table.insert(new_partial, v)\n      end\n      table.insert(new_partial, list[i])\n      find_combinations_helper(list, sum, i + 1, new_partial)\n    end\n  end\n  find_combinations_helper(test_list, 10, 1, {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            local new_list = {}\n            for i, v in ipairs(current_list) do\n                new_list[i] = v\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 8, {})\n    return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, result_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, result_list)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, result_list)\n\t\telse\n\t\t\tlocal new_result_list = table.clone(result_list)\n\t\t\ttable.insert(new_result_list, test_list[index])\n\t\t\tfind_combinations_rec(test_list, index - 1, sum - test_list[index], new_result_list)\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, result_list)\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, #test_list, 10, {})\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            local new_list = {}\n            for i, v in ipairs(current_list) do\n                new_list[i] = v\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, result_list)\n        if sum == 0 then\n            table.insert(result, result_list)\n            return\n        end\n        if index == 0 or sum < 0 then\n            return\n        end\n        local new_result_list = table.copy(result_list)\n        table.insert(new_result_list, test_list[index])\n        find_combinations_rec(test_list, index - 1, sum - test_list[index], new_result_list)\n        find_combinations_rec(test_list, index - 1, sum, result_list)\n    end\n    find_combinations_rec(test_list, #test_list, test_list[#test_list], {})\n    return result\nend",
    "\tlocal result = {}\n\tfor i = 1, #test_list do\n\t\tlocal sum = test_list[i]\n\t\tlocal temp = {}\n\t\tfor j = 1, #test_list do\n\t\t\tif i ~= j then\n\t\t\t\ttable.insert(temp, test_list[j])\n\t\t\tend\n\t\tend\n\t\tlocal temp_result = find_combinations(temp)\n\t\tfor k = 1, #temp_result do\n\t\t\ttable.insert(temp_result[k], sum)\n\t\t\ttable.insert(result, temp_result[k])\n\t\tend\n\t\ttable.insert(result, {sum})\n\tend\n\treturn result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, curr_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, curr_list)\n\t\t\treturn\n\t\tend\n\t\tif index > #test_list then\n\t\t\treturn\n\t\tend\n\t\tfor i = index, #test_list do\n\t\t\tif test_list[i] <= sum then\n\t\t\t\tfind_combinations_rec(test_list, i + 1, sum - test_list[i], {test_list[i], unpack(curr_list)})\n\t\t\tend\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, 1, test_list[1], {})\n\treturn result\nend",
    "\tlocal sum = 0\n\tlocal result = {}\n\tfor i, v in ipairs(test_list) do\n\t\tsum = sum + v\n\tend\n\tlocal half = sum / 2\n\tlocal dp = {}\n\tfor i = 0, sum do\n\t\tdp[i] = {}\n\t\tfor j = 0, #test_list do\n\t\t\tdp[i][j] = 0\n\t\tend\n\tend\n\tfor i = 0, #test_list do\n\t\tdp[0][i] = 1\n\tend\n\tfor i = 1, sum do\n\t\tfor j = 1, #test_list do\n\t\t\tdp[i][j] = dp[i][j - 1]\n\t\t\tif i >= test_list[j] then\n\t\t\t\tdp[i][j] = dp[i][j] + dp[i - test_list[j]][j - 1]\n\t\t\tend\n\t\tend\n\tend\n\tfor i = half, sum do\n\t\tif dp[i][#test_list] > 0 then\n\t\t\ttable.insert(result, i)\n\t\tend\n\tend\n\treturn result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, temp)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, temp)\n\t\t\treturn\n\t\tend\n\t\tfor i = index, #test_list do\n\t\t\tif test_list[i] <= sum then\n\t\t\t\tfind_combinations_rec(test_list, i, sum - test_list[i], temp .. \" \" .. test_list[i])\n\t\t\tend\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, 1, 5, \"\")\n\treturn result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, result_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, result_list)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 or sum < 0 then\n\t\t\treturn\n\t\tend\n\t\tfind_combinations_rec(test_list, index - 1, sum, result_list)\n\t\tlocal new_result_list = {}\n\t\tfor _, v in ipairs(result_list) do\n\t\t\ttable.insert(new_result_list, v)\n\t\tend\n\t\ttable.insert(new_result_list, test_list[index])\n\t\tfind_combinations_rec(test_list, index - 1, sum - test_list[index], new_result_list)\n\tend\n\tfind_combinations_rec(test_list, #test_list, test_list[1], {})\n\treturn result\nend",
    "    local combinations = {}\n    local function find_combinations_recursive(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(combinations, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] <= sum then\n            find_combinations_recursive(test_list, index - 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n        find_combinations_recursive(test_list, index - 1, sum, current_list)\n    end\n    find_combinations_recursive(test_list, #test_list, 5, {})\n    return combinations\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            local new_list = {}\n            for _, v in ipairs(current_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 10, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, path)\n    if sum == 0 then\n      table.insert(result, path)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, path)\n    else\n      find_combinations_rec(test_list, index - 1, sum, path)\n      local new_path = {}\n      for i, v in ipairs(path) do\n        table.insert(new_path, v)\n      end\n      table.insert(new_path, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_path)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, current_sum, current_list, result)\n    if current_sum == 0 then\n      table.insert(result, table.concat(current_list, \" + \"))\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] <= current_sum then\n      table.insert(current_list, test_list[index])\n      find_combinations_rec(test_list, index - 1, current_sum - test_list[index], current_list, result)\n      table.remove(current_list)\n    end\n    find_combinations_rec(test_list, index - 1, current_sum, current_list, result)\n  end\n  find_combinations_rec(test_list, #test_list, 5, {}, result)\n  return result\nend",
    "  local function find_combinations_helper(test_list, index, sum, partial)\n    local partial_sum = 0\n    for i = 1, #partial do\n      partial_sum = partial_sum + partial[i]\n    end\n    if partial_sum == sum then\n      print(table.concat(partial, \" + \"))\n    end\n    for i = index, #test_list do\n      local remaining = sum - partial_sum\n      if remaining < test_list[i] then\n        break\n      end\n      partial[#partial + 1] = test_list[i]\n      find_combinations_helper(test_list, i + 1, sum, partial)\n      partial[#partial] = nil\n    end\n  end\n  find_combinations_helper(test_list, 1, 10, {})\nend",
    "    local combinations = {}\n    local function find_combinations_rec(test_list, index, sum, combination)\n        if sum == 0 then\n            table.insert(combinations, combination)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, combination)\n        else\n            find_combinations_rec(test_list, index - 1, sum, combination)\n            combination = combination or {}\n            table.insert(combination, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], combination)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 8, {})\n    return combinations\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, current_sum, current_list)\n    if index > #test_list then\n      return\n    end\n    if current_sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if current_sum < 0 then\n      return\n    end\n    find_combinations_rec(test_list, index + 1, current_sum, current_list)\n    find_combinations_rec(test_list, index + 1, current_sum - test_list[index], {test_list[index], unpack(current_list)})\n  end\n  find_combinations_rec(test_list, 1, test_list[1], {})\n  return result\nend",
    "    local result = {}\n    local temp = {}\n    local function find_combinations_recursive(test_list, temp, result, start, finish, sum)\n        if sum == 0 then\n            table.insert(result, table.concat(temp, \" + \"))\n            return\n        end\n        for i = start, finish do\n            if sum >= test_list[i] then\n                table.insert(temp, test_list[i])\n                find_combinations_recursive(test_list, temp, result, i, finish, sum - test_list[i])\n                table.remove(temp)\n            end\n        end\n    end\n    find_combinations_recursive(test_list, temp, result, 1, #test_list, 10)\n    return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, temp)\n        if sum == 0 then\n            table.insert(result, temp)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        find_combinations_recursive(test_list, index + 1, sum, temp)\n        local new_temp = {}\n        for _, v in ipairs(temp) do\n            table.insert(new_temp, v)\n        end\n        table.insert(new_temp, test_list[index])\n        find_combinations_recursive(test_list, index + 1, sum - test_list[index], new_temp)\n    end\n    find_combinations_recursive(test_list, 1, 10, {})\n    return result\nend",
    "  local result_list = {}\n  local result_list_index = 1\n  local test_list_length = #test_list\n  local test_list_index = 1\n  local test_list_sub_index = 1\n  local test_list_sub_index_max = test_list_length - 1\n  local test_list_sub_index_max_max = test_list_length - 2\n  local test_list_sub_sub_index = 1\n  local test_list_sub_sub_index_max = test_list_length - 2\n  local test_list_sub_sub_sub_index = 1\n  local test_list_sub_sub_sub_index_max = test_list_length - 3\n  local test_list_sub_sub_sub_sub_index = 1\n  local test_list_sub_sub_sub_sub_index_max = test_list_length - 4\n  local test_list_sub_sub_sub_sub_sub_index = 1\n  local test_list_sub_sub_sub_sub_sub_index_max = test_list_length - 5\n  local test_list_sub_sub_sub_sub_sub_sub_index = 1\n  local test_list_sub_sub_sub_sub_sub_sub_index_max = test_list_length - 6\n  local test_list_sub_sub_sub_sub_sub_sub_sub_index = 1\n  local test_list_sub_sub_sub_sub_sub_sub_sub_index_max = test_list_length - 7\n  local test_list_sub_sub_sub_sub_sub_sub_sub_sub_index = 1\n  local test_list_sub_sub_sub_sub_sub_sub_sub_sub_index_max = test_list_length - 8\n  local test_list_sub_sub_sub_sub_sub_sub_sub_sub_sub_index = 1\n  local test_list_sub_sub_sub_sub_sub_sub_sub_sub_sub_index_max = test_list_length - 9\n  local test_list_sub_sub_sub_sub_sub_",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] <= current_sum then\n            find_combinations_rec(test_list, index - 1, current_sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n        find_combinations_rec(test_list, index - 1, current_sum, current_list)\n    end\n    find_combinations_rec(test_list, #test_list, 5, {})\n    return result\nend",
    "    local result = {}\n    local len = #test_list\n    local function find_combinations_rec(test_list, index, sum, result, curr)\n        if index > len then\n            return\n        end\n        if sum == 0 then\n            table.insert(result, curr)\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        local new_curr = {}\n        for i = 1, #curr do\n            new_curr[i] = curr[i]\n        end\n        new_curr[#new_curr + 1] = test_list[index]\n        find_combinations_rec(test_list, index + 1, sum - test_list[index], result, new_curr)\n        find_combinations_rec(test_list, index + 1, sum, result, curr)\n    end\n    find_combinations_rec(test_list, 1, test_list[1], result, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, path)\n    if sum == 0 then\n      table.insert(result, path)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, path)\n    else\n      find_combinations_rec(test_list, index - 1, sum, path)\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], path .. \" \" .. test_list[index])\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 6, \"\")\n  return result\nend",
    "    local result = {}\n    for i = 1, #test_list do\n        for j = i + 1, #test_list do\n            for k = j + 1, #test_list do\n                if test_list[i] + test_list[j] + test_list[k] == 0 then\n                    table.insert(result, {test_list[i], test_list[j], test_list[k]})\n                end\n            end\n        end\n    end\n    return result\nend",
    "    local sum = 0\n    local result = {}\n    for i = 1, #test_list do\n        sum = sum + test_list[i]\n    end\n    local function find_combinations_rec(test_list, result, sum, curr_sum, curr_list, i)\n        if curr_sum == sum then\n            table.insert(result, curr_list)\n            return\n        end\n        if i > #test_list then\n            return\n        end\n        find_combinations_rec(test_list, result, sum, curr_sum, curr_list, i + 1)\n        table.insert(curr_list, test_list[i])\n        find_combinations_rec(test_list, result, sum, curr_sum + test_list[i], curr_list, i + 1)\n        table.remove(curr_list)\n    end\n    find_combinations_rec(test_list, result, sum, 0, {}, 1)\n    return result\nend",
    "    local result = {}\n    for i = 1, #test_list do\n        for j = i + 1, #test_list do\n            if test_list[i] + test_list[j] == test_list[i] * test_list[j] then\n                table.insert(result, {test_list[i], test_list[j]})\n            end\n        end\n    end\n    return result\nend",
    "  local combinations = {}\n  local function find_combinations_rec(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(combinations, current_list)\n      return\n    end\n    if sum < 0 or index < 1 then\n      return\n    end\n    find_combinations_rec(test_list, index - 1, sum, current_list)\n    local new_list = {}\n    for i, v in ipairs(current_list) do\n      table.insert(new_list, v)\n    end\n    table.insert(new_list, test_list[index])\n    find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n  end\n  find_combinations_rec(test_list, #test_list, test_list[#test_list], {})\n  return combinations\nend",
    "    local combinations = {}\n    local function find_combinations_recursive(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(combinations, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] <= sum then\n            find_combinations_recursive(test_list, index - 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n        find_combinations_recursive(test_list, index - 1, sum, current_list)\n    end\n    find_combinations_recursive(test_list, #test_list, 10, {})\n    return combinations\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if sum < 0 or index < 1 then\n            return\n        end\n        find_combinations_rec(test_list, index - 1, sum, current_list)\n        local new_list = {}\n        for _, v in ipairs(current_list) do\n            table.insert(new_list, v)\n        end\n        table.insert(new_list, test_list[index])\n        find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n    end\n    find_combinations_rec(test_list, #test_list, test_list[1], {})\n    return result\nend",
    "    local result = {}\n    for i = 1, #test_list do\n        for j = i + 1, #test_list do\n            for k = j + 1, #test_list do\n                if test_list[i] + test_list[j] + test_list[k] == 0 then\n                    table.insert(result, {test_list[i], test_list[j], test_list[k]})\n                end\n            end\n        end\n    end\n    return result\nend",
    "    local combinations = {}\n    local sum = 0\n    for i = 1, #test_list do\n        sum = sum + test_list[i]\n    end\n    local half_sum = sum / 2\n    local table_list = {}\n    for i = 1, #test_list do\n        table_list[i] = {test_list[i]}\n    end\n    local i = 1\n    while i <= #table_list do\n        local j = i + 1\n        while j <= #table_list do\n            local sum_i = 0\n            local sum_j = 0\n            for k = 1, #table_list[i] do\n                sum_i = sum_i + table_list[i][k]\n            end\n            for k = 1, #table_list[j] do\n                sum_j = sum_j + table_list[j][k]\n            end\n            if sum_i + sum_j == half_sum then\n                local combination = {}\n                for k = 1, #table_list[i] do\n                    combination[k] = table_list[i][k]\n                end\n                for k = 1, #table_list[j] do\n                    combination[#combination + 1] = table_list[j][k]\n                end\n                combinations[#combinations + 1] = combination\n            end\n            j = j + 1\n        end\n        i = i + 1\n    end\n    return combinations\nend",
    "  local function find_combinations_rec(test_list, index, sum, result)\n    if sum == 0 then\n      table.insert(result, {})\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, result)\n    else\n      local result_1 = {}\n      find_combinations_rec(test_list, index - 1, sum, result_1)\n      local result_2 = {}\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], result_2)\n      for _, v in ipairs(result_2) do\n        table.insert(v, test_list[index])\n      end\n      for _, v in ipairs(result_2) do\n        table.insert(result_1, v)\n      end\n      for _, v in ipairs(result_1) do\n        table.insert(result, v)\n      end\n    end\n  end\n  local result = {}\n  find_combinations_rec(test_list, #test_list, test_list[#test_list], result)\n  return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, path)\n        if sum == 0 then\n            table.insert(result, path)\n            return\n        end\n        if sum < 0 or index < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index - 1, sum, path)\n        table.insert(path, test_list[index])\n        find_combinations_helper(test_list, index - 1, sum - test_list[index], path)\n        table.remove(path)\n    end\n    find_combinations_helper(test_list, #test_list, test_list[1], {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_recursive(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    for i = index, #test_list do\n      if test_list[i] <= sum then\n        find_combinations_recursive(test_list, i + 1, sum - test_list[i], {test_list[i], unpack(current_list)})\n      end\n    end\n  end\n  find_combinations_recursive(test_list, 1, 5, {})\n  return result\nend",
    "    local results = {}\n    local function find_combinations_helper(test_list, target, partial)\n        local s = 0\n        for i,v in ipairs(partial) do\n            s = s + v\n        end\n        if s == target then\n            table.insert(results, partial)\n        end\n        if s >= target then\n            return\n        end\n        for i = #test_list, 1, -1 do\n            local n = test_list[i]\n            table.remove(test_list, i)\n            find_combinations_helper(test_list, target, partial)\n            table.insert(test_list, i, n)\n        end\n    end\n    find_combinations_helper(test_list, 10, {})\n    return results\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, temp)\n        if sum == 0 then\n            table.insert(result, temp)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_recursive(test_list, index - 1, sum, temp)\n        else\n            local temp2 = table.copy(temp)\n            table.insert(temp2, test_list[index])\n            find_combinations_recursive(test_list, index - 1, sum - test_list[index], temp2)\n            find_combinations_recursive(test_list, index - 1, sum, temp)\n        end\n    end\n    find_combinations_recursive(test_list, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    for i = 1, #test_list do\n        for j = i + 1, #test_list do\n            for k = j + 1, #test_list do\n                if test_list[i] + test_list[j] + test_list[k] == 0 then\n                    table.insert(result, {test_list[i], test_list[j], test_list[k]})\n                end\n            end\n        end\n    end\n    return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_helper(test_list, index, sum, temp)\n\t\tif sum < 0 then\n\t\t\treturn\n\t\tend\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, temp)\n\t\t\treturn\n\t\tend\n\t\tfor i = index, #test_list do\n\t\t\ttable.insert(temp, test_list[i])\n\t\t\tfind_combinations_helper(test_list, i, sum - test_list[i], temp)\n\t\t\ttable.remove(temp)\n\t\tend\n\tend\n\tfind_combinations_helper(test_list, 1, 10, {})\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, temp)\n        if sum == 0 then\n            table.insert(result, temp)\n            return\n        end\n        for i = index, #test_list do\n            if test_list[i] <= sum then\n                table.insert(temp, test_list[i])\n                find_combinations_recursive(test_list, i, sum - test_list[i], temp)\n                table.remove(temp)\n            end\n        end\n    end\n    find_combinations_recursive(test_list, 1, 5, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, curr_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, curr_list)\n            local new_list = {}\n            for _, v in ipairs(curr_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 8, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_recursive(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_recursive(test_list, index - 1, sum, current_list)\n    else\n      find_combinations_recursive(test_list, index - 1, sum, current_list)\n      local new_list = {}\n      for _,v in ipairs(current_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_recursive(test_list, index - 1, sum - test_list[index], new_list)\n    end\n  end\n  find_combinations_recursive(test_list, #test_list, 8, {})\n  return result\nend",
    "    local result = {}\n    local len = #test_list\n    for i = 1, len do\n        for j = i + 1, len do\n            for k = j + 1, len do\n                if test_list[i] + test_list[j] + test_list[k] == 0 then\n                    local temp = {test_list[i], test_list[j], test_list[k]}\n                    table.sort(temp)\n                    result[#result + 1] = temp\n                end\n            end\n        end\n    end\n    return result\nend",
    "    local function find_combinations_helper(test_list, index, sum, curr_list)\n        if sum == 0 then\n            print(table.concat(curr_list, \" + \"))\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, curr_list)\n        else\n            local new_list = {}\n            for i = 1, #curr_list do\n                new_list[i] = curr_list[i]\n            end\n            new_list[#new_list + 1] = test_list[index]\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n            find_combinations_helper(test_list, index - 1, sum, curr_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 7, {})\nend",
    "    local result = {}\n    local function helper(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if index > #test_list or sum < 0 then\n            return\n        end\n        helper(test_list, index + 1, sum, curr_list)\n        helper(test_list, index + 1, sum - test_list[index], {test_list[index], unpack(curr_list)})\n    end\n    helper(test_list, 1, 10, {})\n    return result\nend",
    "  local result = {}\n  local n = #test_list\n  local function recurse(i, sum, t)\n    if i == n then\n      if sum == 0 then\n        table.insert(result, t)\n      end\n      return\n    end\n    recurse(i + 1, sum, t)\n    recurse(i + 1, sum - test_list[i], {test_list[i], unpack(t)})\n  end\n  recurse(1, test_list[1], {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, temp_list)\n        if sum == 0 then\n            table.insert(result, temp_list)\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        for i = index, #test_list do\n            if sum - test_list[i] >= 0 then\n                table.insert(temp_list, test_list[i])\n                find_combinations_rec(test_list, i, sum - test_list[i], temp_list)\n                table.remove(temp_list)\n            end\n        end\n    end\n    find_combinations_rec(test_list, 1, test_list[1], {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, target, partial)\n        local s = 0\n        for i, v in ipairs(partial) do\n            s = s + v\n        end\n        if s == target then\n            table.insert(result, partial)\n        end\n        if s >= target then\n            return\n        end\n        for i = #test_list, 1, -1 do\n            local n = test_list[i]\n            table.remove(test_list, i)\n            find_combinations_helper(test_list, target, partial)\n            table.insert(test_list, i, n)\n        end\n    end\n    find_combinations_helper(test_list, 10, {})\n    return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_helper(test_list, index, sum, curr_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, curr_list)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_helper(test_list, index - 1, sum, curr_list)\n\t\telse\n\t\t\tlocal new_list = table.copy(curr_list)\n\t\t\ttable.insert(new_list, test_list[index])\n\t\t\tfind_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n\t\t\tfind_combinations_helper(test_list, index - 1, sum, curr_list)\n\t\tend\n\tend\n\tfind_combinations_helper(test_list, #test_list, 5, {})\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        local curr_num = test_list[index]\n        if sum >= curr_num then\n            find_combinations_rec(test_list, index - 1, sum - curr_num, curr_list .. \" \" .. curr_num)\n        end\n        find_combinations_rec(test_list, index - 1, sum, curr_list)\n    end\n    find_combinations_rec(test_list, #test_list, 5, \"\")\n    return result\nend",
    "    local result = {}\n    for i = 1, #test_list do\n        for j = i + 1, #test_list do\n            for k = j + 1, #test_list do\n                if test_list[i] + test_list[j] + test_list[k] == 0 then\n                    table.insert(result, {test_list[i], test_list[j], test_list[k]})\n                end\n            end\n        end\n    end\n    return result\nend",
    "  local result = {}\n  for i = 1, #test_list do\n    local sum = test_list[i]\n    local temp = {}\n    for j = 1, #test_list do\n      if j ~= i then\n        table.insert(temp, test_list[j])\n      end\n    end\n    local temp_result = find_combinations(temp)\n    for k = 1, #temp_result do\n      table.insert(temp_result[k], sum)\n      table.insert(result, temp_result[k])\n    end\n    table.insert(result, {sum})\n  end\n  return result\nend",
    "  local result = {}\n  local function find_combinations_helper(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_helper(test_list, index - 1, sum, curr_list)\n    else\n      find_combinations_helper(test_list, index - 1, sum, curr_list)\n      local new_list = {}\n      for i, v in ipairs(curr_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n    end\n  end\n  find_combinations_helper(test_list, #test_list, 5, {})\n  return result\nend",
    "  local function find_combinations_rec(test_list, index, sum, current_list, result_list)\n    if sum == 0 then\n      table.insert(result_list, current_list)\n      return\n    end",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, sum, current_list)\n        find_combinations_helper(test_list, index + 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n    end\n    find_combinations_helper(test_list, 1, 8, {})\n    return result\nend",
    "    local function find_combinations_rec(test_list, index, sum, current_list, result_list)\n        if sum == 0 then\n            table.insert(result_list, current_list)\n            return\n        end",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list or sum < 0 then\n            return\n        end\n        find_combinations_rec(test_list, index + 1, sum, current_list)\n        find_combinations_rec(test_list, index + 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n    end\n    find_combinations_rec(test_list, 1, test_list[1], {})\n    return result\nend",
    "  local result = {}\n  for i = 1, #test_list do\n    for j = i + 1, #test_list do\n      local sum = test_list[i] + test_list[j]\n      result[sum] = result[sum] or {}\n      table.insert(result[sum], {test_list[i], test_list[j]})\n    end\n  end\n  return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, current_sum, current_list)\n\t\tif current_sum == 0 then\n\t\t\ttable.insert(result, current_list)\n\t\t\treturn\n\t\tend\n\t\tif index > #test_list or current_sum < 0 then\n\t\t\treturn\n\t\tend\n\t\tfor i = index, #test_list do\n\t\t\tlocal new_current_list = table.copy(current_list)\n\t\t\ttable.insert(new_current_list, test_list[i])\n\t\t\tfind_combinations_rec(test_list, i + 1, current_sum - test_list[i], new_current_list)\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, 1, 8, {})\n\treturn result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, curr_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, table.copy(curr_list))\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, curr_list)\n\t\telse\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, curr_list)\n\t\t\ttable.insert(curr_list, test_list[index])\n\t\t\tfind_combinations_rec(test_list, index - 1, sum - test_list[index], curr_list)\n\t\t\ttable.remove(curr_list)\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, #test_list, 5, {})\n\treturn result\nend",
    "  local function find_combinations_rec(test_list, index, sum, current_list)\n    if sum == 0 then\n      print(table.concat(current_list, \" + \"))\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] <= sum then\n      current_list[#current_list + 1] = test_list[index]\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], current_list)\n      current_list[#current_list] = nil\n    end\n    find_combinations_rec(test_list, index - 1, sum, current_list)\n  end\n  find_combinations_rec(test_list, #test_list, test_list[1], {})\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        local current_number = test_list[index]\n        if current_number <= sum then\n            find_combinations_helper(test_list, index - 1, sum - current_number, {current_number, unpack(current_list)})\n        end\n        find_combinations_helper(test_list, index - 1, sum, current_list)\n    end\n    find_combinations_helper(test_list, #test_list, 10, {})\n    return result\nend",
    "  local function find_combinations_helper(test_list, target, index, partial)\n    if target == 0 then\n      print(table.concat(partial, \" + \"))\n      return\n    end",
    "    local result = {}\n    local n = #test_list\n    for i = 1, n do\n        for j = i + 1, n do\n            for k = j + 1, n do\n                local sum = test_list[i] + test_list[j] + test_list[k]\n                if result[sum] == nil then\n                    result[sum] = {}\n                end\n                table.insert(result[sum], {test_list[i], test_list[j], test_list[k]})\n            end\n        end\n    end\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n        elseif index > 0 then\n            if current_sum >= test_list[index] then\n                find_combinations_rec(test_list, index - 1, current_sum - test_list[index], {table.unpack(current_list), test_list[index]})\n            end\n            find_combinations_rec(test_list, index - 1, current_sum, current_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    for i = 1, #test_list do\n        for j = i + 1, #test_list do\n            local sum = test_list[i] + test_list[j]\n            result[sum] = result[sum] or {}\n            table.insert(result[sum], {test_list[i], test_list[j]})\n        end\n    end\n    return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] <= current_sum then\n            find_combinations_recursive(test_list, index - 1, current_sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n        find_combinations_recursive(test_list, index - 1, current_sum, current_list)\n    end\n    find_combinations_recursive(test_list, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list or sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, sum, current_list)\n        table.insert(current_list, test_list[index])\n        find_combinations_helper(test_list, index + 1, sum - test_list[index], current_list)\n        table.remove(current_list)\n    end\n    find_combinations_helper(test_list, 1, 10, {})\n    return result\nend",
    "    local result = {}\n    for i = 1, #test_list do\n        for j = i + 1, #test_list do\n            for k = j + 1, #test_list do\n                if test_list[i] + test_list[j] + test_list[k] == 0 then\n                    table.insert(result, {test_list[i], test_list[j], test_list[k]})\n                end\n            end\n        end\n    end\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 10, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, current_sum, current_list)\n    if current_sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if current_sum < 0 then\n      return\n    end\n    find_combinations_rec(test_list, index - 1, current_sum, current_list)\n    local new_list = {}\n    for _, v in ipairs(current_list) do\n      table.insert(new_list, v)\n    end\n    table.insert(new_list, test_list[index])\n    find_combinations_rec(test_list, index - 1, current_sum - test_list[index], new_list)\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        if current_sum < 0 then\n            return\n        end\n        find_combinations_rec(test_list, index + 1, current_sum, current_list)\n        local new_list = {}\n        for i = 1, #current_list do\n            table.insert(new_list, current_list[i])\n        end\n        table.insert(new_list, test_list[index])\n        find_combinations_rec(test_list, index + 1, current_sum - test_list[index], new_list)\n    end\n    find_combinations_rec(test_list, 1, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, start, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        for i = start, #test_list do\n            if test_list[i] <= sum then\n                find_combinations_rec(test_list, i, sum - test_list[i], {table.unpack(current_list), test_list[i]})\n            end\n        end\n    end\n    find_combinations_rec(test_list, 1, test_list[1], {})\n    return result\nend",
    "    local result = {}\n    local sum = 0\n    for i = 1, #test_list do\n        sum = sum + test_list[i]\n    end\n    local function find_combinations_rec(test_list, index, current_sum, current_list)\n        if current_sum == sum then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        find_combinations_rec(test_list, index + 1, current_sum, current_list)\n        find_combinations_rec(test_list, index + 1, current_sum + test_list[index], current_list .. \" \" .. test_list[index])\n    end\n    find_combinations_rec(test_list, 1, 0, \"\")\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_rec(test_list, index - 1, sum, current_list)\n            local new_list = table.copy(current_list)\n            table.insert(new_list, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    local function recurse(remain, prefix)\n        if remain == 0 then\n            table.insert(result, prefix)\n            return\n        end\n        for i = 1, #test_list do\n            if test_list[i] <= remain then\n                recurse(remain - test_list[i], prefix .. test_list[i] .. \" \")\n            end\n        end\n    end\n    recurse(test_list[1], \"\")\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, temp_list)\n    if sum == 0 then\n      table.insert(result, temp_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, temp_list)\n    else\n      find_combinations_rec(test_list, index - 1, sum, temp_list)\n      temp_list[index] = test_list[index]\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], temp_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend",
    "  local function find_combinations_helper(test_list, sum, index, current_list, result)\n    if sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if sum < 0 or index < 1 then\n      return\n    end\n    find_combinations_helper(test_list, sum, index - 1, current_list, result)\n    local new_list = table.copy(current_list)\n    table.insert(new_list, test_list[index])\n    find_combinations_helper(test_list, sum - test_list[index], index - 1, new_list, result)\n  end\n  local result = {}\n  find_combinations_helper(test_list, 8, #test_list, {}, result)\n  return result\nend",
    "    local result = {}\n    local n = #test_list\n    local function find_combinations_recursive(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] <= sum then\n            find_combinations_recursive(test_list, index - 1, sum - test_list[index], current_list + {test_list[index]})\n        end\n        find_combinations_recursive(test_list, index - 1, sum, current_list)\n    end\n    find_combinations_recursive(test_list, n, sum, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    local curr_list_copy = {}\n    for i, v in ipairs(curr_list) do\n      table.insert(curr_list_copy, v)\n    end\n    find_combinations_rec(test_list, index + 1, sum, curr_list_copy)\n    table.insert(curr_list, test_list[index])\n    find_combinations_rec(test_list, index + 1, sum - test_list[index], curr_list)\n  end\n  find_combinations_rec(test_list, 1, 5, {})\n  return result\nend",
    "  local function find_combinations_rec(test_list, index, sum, result)\n    if sum == 0 then\n      print(table.concat(result, \" + \"))\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if sum < 0 then\n      return\n    end\n    find_combinations_rec(test_list, index - 1, sum, result)\n    table.insert(result, test_list[index])\n    find_combinations_rec(test_list, index - 1, sum - test_list[index], result)\n    table.remove(result)\n  end\n  find_combinations_rec(test_list, #test_list, 5, {})\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if sum < 0 or index == 0 then\n            return\n        end\n        find_combinations_rec(test_list, index - 1, sum, curr_list)\n        curr_list[index] = curr_list[index] + 1\n        find_combinations_rec(test_list, index, sum - test_list[index], curr_list)\n        curr_list[index] = curr_list[index] - 1\n    end\n    find_combinations_rec(test_list, #test_list, 5, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    else\n      local new_list = {}\n      for i, v in ipairs(curr_list) do\n        new_list[i] = v\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 5, {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        find_combinations_recursive(test_list, index + 1, sum, current_list)\n        local new_list = {}\n        for _, v in ipairs(current_list) do\n            table.insert(new_list, v)\n        end\n        table.insert(new_list, test_list[index])\n        find_combinations_recursive(test_list, index + 1, sum - test_list[index], new_list)\n    end\n    find_combinations_recursive(test_list, 1, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        local current_number = test_list[index]\n        if current_number <= sum then\n            find_combinations_helper(test_list, index + 1, sum - current_number, current_list .. \" \" .. current_number)\n        end\n        find_combinations_helper(test_list, index + 1, sum, current_list)\n    end\n    find_combinations_helper(test_list, 1, 6, \"\")\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list or sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, sum, current_list)\n        find_combinations_helper(test_list, index + 1, sum - test_list[index], {table.unpack(current_list), test_list[index]})\n    end\n    find_combinations_helper(test_list, 1, test_list[1], {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > current_sum then\n            find_combinations_recursive(test_list, index - 1, current_sum, current_list)\n        else\n            local new_list = table.copy(current_list)\n            table.insert(new_list, test_list[index])\n            find_combinations_recursive(test_list, index - 1, current_sum - test_list[index], new_list)\n            find_combinations_recursive(test_list, index - 1, current_sum, current_list)\n        end\n    end\n    find_combinations_recursive(test_list, #test_list, 5, {})\n    return result\nend",
    "    local combinations = {}\n    local function find_combinations_recursive(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(combinations, current_list)\n            return\n        end",
    "  local result = {}\n  local function find_combinations_helper(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    find_combinations_helper(test_list, index + 1, sum, current_list)\n    local new_list = {}\n    for i = 1, #current_list do\n      table.insert(new_list, current_list[i])\n    end\n    table.insert(new_list, test_list[index])\n    find_combinations_helper(test_list, index + 1, sum - test_list[index], new_list)\n  end\n  find_combinations_helper(test_list, 1, 10, {})\n  return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, temp)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, temp)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, temp)\n\t\telse\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, temp)\n\t\t\ttemp[index] = test_list[index]\n\t\t\tfind_combinations_rec(test_list, index - 1, sum - test_list[index], temp)\n\t\t\ttemp[index] = nil\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, #test_list, test_list[1], {})\n\treturn result\nend",
    "  local function find_combinations_helper(test_list, index, sum, current_list)\n    if sum == 0 then\n      return {current_list}\n    elseif sum < 0 or index < 1 then\n      return {}\n    else\n      local with_current_element = find_combinations_helper(test_list, index - 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n      local without_current_element = find_combinations_helper(test_list, index - 1, sum, current_list)\n      return {unpack(with_current_element), unpack(without_current_element)}\n    end\n  end\n  return find_combinations_helper(test_list, #test_list, 5, {})\nend",
    "  local result = {}\n  local n = #test_list\n  for i = 1, n do\n    for j = i + 1, n do\n      for k = j + 1, n do\n        if test_list[i] + test_list[j] + test_list[k] == 0 then\n          table.insert(result, {test_list[i], test_list[j], test_list[k]})\n        end\n      end\n    end\n  end\n  return result\nend",
    "\tlocal function find_combinations_rec(test_list, index, sum, cur_list, result)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, cur_list)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tlocal cur_num = test_list[index]\n\t\tif cur_num > sum then\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, cur_list, result)\n\t\telse\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, cur_list, result)\n\t\t\tlocal new_list = {}\n\t\t\tfor _, v in ipairs(cur_list) do\n\t\t\t\ttable.insert(new_list, v)\n\t\t\tend\n\t\t\ttable.insert(new_list, cur_num)\n\t\t\tfind_combinations_rec(test_list, index - 1, sum - cur_num, new_list, result)\n\t\tend\n\tend\n\tlocal result = {}\n\tfind_combinations_rec(test_list, #test_list, test_list[#test_list], {}, result)\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            local new_list = table.copy(current_list)\n            table.insert(new_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, #test_list, {})\n    return result\nend",
    "  local function find_combinations_helper(test_list, index, sum, current_list)\n    if sum == 0 then\n      print(table.concat(current_list, \" + \"))\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_helper(test_list, index - 1, sum, current_list)\n    else\n      find_combinations_helper(test_list, index - 1, sum, current_list)\n      table.insert(current_list, test_list[index])\n      find_combinations_helper(test_list, index - 1, sum - test_list[index], current_list)\n      table.remove(current_list)\n    end\n  end\n  find_combinations_helper(test_list, #test_list, 8, {})\nend",
    "  local function find_combinations_rec(test_list, sum, index, current_sum, current_list)\n    if current_sum == sum then\n      print(table.concat(current_list, \" + \"))\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    if current_sum > sum then\n      return\n    end\n    current_list[#current_list + 1] = test_list[index]\n    find_combinations_rec(test_list, sum, index + 1, current_sum + test_list[index], current_list)\n    current_list[#current_list] = nil\n    find_combinations_rec(test_list, sum, index + 1, current_sum, current_list)\n  end\n  find_combinations_rec(test_list, 10, 1, 0, {})\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, temp)\n        if sum == 0 then\n            result[#result + 1] = temp\n            return\n        end\n        if sum < 0 or index < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index - 1, sum, temp)\n        temp[#temp + 1] = test_list[index]\n        find_combinations_helper(test_list, index - 1, sum - test_list[index], temp)\n        temp[#temp] = nil\n    end\n    find_combinations_helper(test_list, #test_list, test_list[#test_list], {})\n    return result\nend",
    "    local result = {}\n    local n = #test_list\n    local function find_combinations_recursive(test_list, index, sum, temp)\n        if sum == 0 then\n            table.insert(result, temp)\n            return\n        end\n        if index == n then\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        local temp2 = table.copy(temp)\n        table.insert(temp2, test_list[index])\n        find_combinations_recursive(test_list, index + 1, sum - test_list[index], temp2)\n        find_combinations_recursive(test_list, index + 1, sum, temp)\n    end\n    find_combinations_recursive(test_list, 1, test_list[1], {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    else\n      local new_list = {}\n      for i, v in ipairs(curr_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_helper(test_list, index, sum, current_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, current_list)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_helper(test_list, index - 1, sum, current_list)\n\t\telse\n\t\t\tfind_combinations_helper(test_list, index - 1, sum, current_list)\n\t\t\tlocal new_list = table.copy(current_list)\n\t\t\ttable.insert(new_list, test_list[index])\n\t\t\tfind_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n\t\tend\n\tend\n\tfind_combinations_helper(test_list, #test_list, 5, {})\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, curr_list)\n        if sum < 0 then\n            return\n        end\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        for i = index, #test_list do\n            local new_list = {}\n            for _, v in ipairs(curr_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[i])\n            find_combinations_recursive(test_list, i + 1, sum - test_list[i], new_list)\n        end\n    end\n    find_combinations_recursive(test_list, 1, 4, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    else\n      local new_list = {}\n      for i, v in ipairs(curr_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, result_list)\n        if sum == 0 then\n            table.insert(result, result_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, result_list)\n        else\n            local new_result_list = {}\n            for i = 1, #result_list do\n                new_result_list[i] = result_list[i]\n            end\n            table.insert(new_result_list, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], new_result_list)\n            find_combinations_rec(test_list, index - 1, sum, result_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 5, {})\n    return result\nend",
    "    local combinations = {}\n    local len = #test_list\n    for i = 1, len do\n        for j = i + 1, len do\n            local sum = test_list[i] + test_list[j]\n            combinations[sum] = combinations[sum] or {}\n            table.insert(combinations[sum], {test_list[i], test_list[j]})\n        end\n    end\n    return combinations\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_recursive(test_list, index, sum, temp)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, temp)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_recursive(test_list, index - 1, sum, temp)\n\t\telse\n\t\t\tfind_combinations_recursive(test_list, index - 1, sum, temp)\n\t\t\ttemp[index] = test_list[index]\n\t\t\tfind_combinations_recursive(test_list, index - 1, sum - test_list[index], temp)\n\t\tend\n\tend\n\tfind_combinations_recursive(test_list, #test_list, 5, {})\n\treturn result\nend",
    "  local result = {}\n  local function find_combinations_helper(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    for i = index, #test_list do\n      if test_list[i] <= sum then\n        find_combinations_helper(test_list, i, sum - test_list[i], {test_list[i], unpack(current_list)})\n      end\n    end\n  end\n  find_combinations_helper(test_list, 1, 6, {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            local new_list = {}\n            for i = 1, #current_list do\n                table.insert(new_list, current_list[i])\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 10, {})\n    return result\nend",
    "  local function find_combinations_rec(test_list, index, sum, current_list)\n    if sum == 0 then\n      print(table.concat(current_list, \" \"))\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, current_list)\n    else\n      local new_list = table.copy(current_list)\n      new_list[#new_list + 1] = test_list[index]\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n      find_combinations_rec(test_list, index - 1, sum, current_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            local new_list = {}\n            for _, v in ipairs(current_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 8, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] <= current_sum then\n            find_combinations_recursive(test_list, index - 1, current_sum, current_list)\n            table.insert(current_list, test_list[index])\n            find_combinations_recursive(test_list, index - 1, current_sum - test_list[index], current_list)\n            table.remove(current_list)\n        else\n            find_combinations_recursive(test_list, index - 1, current_sum, current_list)\n        end\n    end\n    find_combinations_recursive(test_list, #test_list, 10, {})\n    return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, curr_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, curr_list)\n\t\t\treturn\n\t\tend\n\t\tif sum < 0 or index < 1 then\n\t\t\treturn\n\t\tend\n\t\tfind_combinations_rec(test_list, index - 1, sum, curr_list)\n\t\tlocal new_list = table.copy(curr_list)\n\t\ttable.insert(new_list, test_list[index])\n\t\tfind_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n\tend\n\tfind_combinations_rec(test_list, #test_list, 5, {})\n\treturn result\nend",
    "  local combinations = {}\n  local function find_combinations_rec(test_list, index, sum, combination)\n    if sum == 0 then\n      combinations[#combinations + 1] = combination\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    if sum < 0 then\n      return\n    end\n    find_combinations_rec(test_list, index + 1, sum, combination)\n    combination[#combination + 1] = test_list[index]\n    find_combinations_rec(test_list, index + 1, sum - test_list[index], combination)\n    combination[#combination] = nil\n  end\n  find_combinations_rec(test_list, 1, test_list[1], {})\n  return combinations\nend",
    "    local result = {}\n    local function recurse(remaining, prefix)\n        if remaining == 0 then\n            table.insert(result, prefix)\n            return\n        end\n        for i = 1, #test_list do\n            if test_list[i] <= remaining then\n                recurse(remaining - test_list[i], prefix .. \" \" .. test_list[i])\n            end\n        end\n    end\n    recurse(test_list[1], \"\")\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, temp)\n    if sum == 0 then\n      table.insert(result, temp)\n      return\n    end\n    if index > #test_list then\n      return\n    end\n    local current_value = test_list[index]\n    if current_value <= sum then\n      find_combinations_rec(test_list, index + 1, sum - current_value, temp .. current_value .. ' ')\n    end\n    find_combinations_rec(test_list, index + 1, sum, temp)\n  end\n  find_combinations_rec(test_list, 1, 5, '')\n  return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, path)\n        if sum == 0 then\n            table.insert(result, path)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        for i = index, #test_list do\n            if sum - test_list[i] >= 0 then\n                find_combinations_helper(test_list, i + 1, sum - test_list[i], path .. \" \" .. test_list[i])\n            end\n        end\n    end\n    find_combinations_helper(test_list, 1, 8, \"\")\n    return result\nend",
    "  local result = {}\n  local function find_combinations_recursive(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_recursive(test_list, index - 1, sum, current_list)\n    else\n      local new_list = table.copy(current_list)\n      table.insert(new_list, test_list[index])\n      find_combinations_recursive(test_list, index - 1, sum - test_list[index], new_list)\n      find_combinations_recursive(test_list, index - 1, sum, current_list)\n    end\n  end\n  find_combinations_recursive(test_list, #test_list, 10, {})\n  return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, path)\n    if sum == 0 then\n      table.insert(result, path)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, path)\n    else\n      find_combinations_rec(test_list, index - 1, sum, path)\n      local new_path = {}\n      for _, v in ipairs(path) do\n        table.insert(new_path, v)\n      end\n      table.insert(new_path, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_path)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if sum < 0 or index < 1 then\n            return\n        end\n        find_combinations_recursive(test_list, index - 1, sum, current_list)\n        local new_list = table.copy(current_list)\n        table.insert(new_list, test_list[index])\n        find_combinations_recursive(test_list, index - 1, sum - test_list[index], new_list)\n    end\n    find_combinations_recursive(test_list, #test_list, 8, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, path)\n    if sum == 0 then\n      table.insert(result, path)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, path)\n    else\n      find_combinations_rec(test_list, index - 1, sum, path)\n      local new_path = {}\n      for _, v in ipairs(path) do\n        table.insert(new_path, v)\n      end\n      table.insert(new_path, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_path)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 5, {})\n  return result\nend",
    "  local result = {}\n  local function find_combinations_helper(test_list, index, sum, current_list)\n    if sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if sum < 0 or index < 1 then\n      return\n    end\n    find_combinations_helper(test_list, index - 1, sum, current_list)\n    table.insert(current_list, test_list[index])\n    find_combinations_helper(test_list, index - 1, sum - test_list[index], current_list)\n    table.remove(current_list)\n  end\n  find_combinations_helper(test_list, #test_list, 8, {})\n  return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, table)\n    if sum == 0 then\n      table.insert(result, table)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, table)\n    else\n      local new_table = table.copy(table)\n      table.insert(new_table, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum, table)\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_table)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend",
    "  local combinations = {}\n  local function find_combinations_internal(test_list, index, sum, combination)\n    if sum == 0 then\n      combinations[#combinations + 1] = combination\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_internal(test_list, index - 1, sum, combination)\n    else\n      find_combinations_internal(test_list, index - 1, sum, combination)\n      combination[#combination + 1] = test_list[index]\n      find_combinations_internal(test_list, index - 1, sum - test_list[index], combination)\n      combination[#combination] = nil\n    end\n  end\n  find_combinations_internal(test_list, #test_list, 10, {})\n  return combinations\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, current_sum, current_list)\n        if current_sum == 0 then\n            table.insert(result, current_list)\n        elseif current_sum < 0 then\n            return\n        else\n            for i = index, #test_list do\n                local new_current_list = {}\n                for _, v in ipairs(current_list) do\n                    table.insert(new_current_list, v)\n                end\n                table.insert(new_current_list, test_list[i])\n                find_combinations_recursive(test_list, i, current_sum - test_list[i], new_current_list)\n            end\n        end\n    end\n    find_combinations_recursive(test_list, 1, 12, {})\n    return result\nend",
    "  local function find_combinations_rec(test_list, index, sum, current_list)\n    if sum == 0 then\n      print(table.concat(current_list, \" + \"))\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, current_list)\n    else\n      current_list[#current_list + 1] = test_list[index]\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], current_list)\n      current_list[#current_list] = nil\n      find_combinations_rec(test_list, index - 1, sum, current_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 8, {})\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, index, sum, temp)\n        if sum == 0 then\n            table.insert(result, temp)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] <= sum then\n            find_combinations_recursive(test_list, index - 1, sum - test_list[index], temp .. test_list[index] .. \" \")\n        end\n        find_combinations_recursive(test_list, index - 1, sum, temp)\n    end\n    find_combinations_recursive(test_list, #test_list, 8, \"\")\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_rec(test_list, index - 1, sum, current_list)\n            local new_list = {}\n            for _, v in ipairs(current_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, test_list[#test_list], {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_helper(test_list, index - 1, sum, current_list)\n            local new_list = {}\n            for i, v in ipairs(current_list) do\n                table.insert(new_list, v)\n            end\n            table.insert(new_list, test_list[index])\n            find_combinations_helper(test_list, index - 1, sum - test_list[index], new_list)\n        end\n    end\n    find_combinations_helper(test_list, #test_list, 8, {})\n    return result\nend",
    "    local combinations = {}\n    local function find_combinations_recursive(test_list, index, sum, combination)\n        if sum == 0 then\n            table.insert(combinations, combination)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_recursive(test_list, index - 1, sum, combination)\n        else\n            find_combinations_recursive(test_list, index - 1, sum, combination)\n            combination = combination .. \" \" .. test_list[index]\n            find_combinations_recursive(test_list, index - 1, sum - test_list[index], combination)\n        end\n    end\n    find_combinations_recursive(test_list, #test_list, 8, \"\")\n    return combinations\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        find_combinations_rec(test_list, index + 1, sum, current_list)\n        local new_list = table.copy(current_list)\n        table.insert(new_list, test_list[index])\n        find_combinations_rec(test_list, index + 1, sum - test_list[index], new_list)\n    end\n    find_combinations_rec(test_list, 1, 10, {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_helper(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    local curr_num = test_list[index]\n    local new_list = table.copy(curr_list)\n    table.insert(new_list, curr_num)\n    find_combinations_helper(test_list, index - 1, sum - curr_num, new_list)\n    find_combinations_helper(test_list, index - 1, sum, curr_list)\n  end\n  find_combinations_helper(test_list, #test_list, 5, {})\n  return result\nend",
    "    local function find_combinations_rec(test_list, index, sum, curr_list, result)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if sum < 0 or index == 0 then\n            return\n        end\n        find_combinations_rec(test_list, index - 1, sum, curr_list, result)\n        local new_list = {}\n        for _, v in ipairs(curr_list) do\n            table.insert(new_list, v)\n        end\n        table.insert(new_list, test_list[index])\n        find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list, result)\n    end\n    local result = {}\n    find_combinations_rec(test_list, #test_list, test_list[1], {}, result)\n    return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_recursive(test_list, index, sum, current_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, current_list)\n\t\t\treturn\n\t\tend\n\t\tif index > #test_list then\n\t\t\treturn\n\t\tend\n\t\tif sum < 0 then\n\t\t\treturn\n\t\tend\n\t\tfind_combinations_recursive(test_list, index + 1, sum, current_list)\n\t\tfind_combinations_recursive(test_list, index + 1, sum - test_list[index], {test_list[index], unpack(current_list)})\n\tend\n\tfind_combinations_recursive(test_list, 1, test_list[1], {})\n\treturn result\nend",
    "  local combinations = {}\n  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(combinations, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    else\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n      local new_list = {}\n      for _, v in ipairs(curr_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 5, {})\n  return combinations\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        local curr_val = test_list[index]\n        if curr_val <= sum then\n            find_combinations_rec(test_list, index - 1, sum - curr_val, {curr_val, unpack(curr_list)})\n        end\n        find_combinations_rec(test_list, index - 1, sum, curr_list)\n    end\n    find_combinations_rec(test_list, #test_list, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, temp)\n        if sum == 0 then\n            table.insert(result, temp)\n            return\n        end\n        for i = index, #test_list do\n            if test_list[i] <= sum then\n                find_combinations_helper(test_list, i, sum - test_list[i], temp .. test_list[i] .. \" \")\n            end\n        end\n    end\n    find_combinations_helper(test_list, 1, 10, \"\")\n    return result\nend",
    "\tlocal combinations = {}\n\tlocal function find_combinations_helper(test_list, index, sum, combination)\n\t\tif sum == 0 then\n\t\t\ttable.insert(combinations, combination)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_helper(test_list, index - 1, sum, combination)\n\t\telse\n\t\t\tfind_combinations_helper(test_list, index - 1, sum, combination)\n\t\t\tcombination[index] = (combination[index] or 0) + 1\n\t\t\tfind_combinations_helper(test_list, index, sum - test_list[index], combination)\n\t\t\tcombination[index] = combination[index] - 1\n\t\tend\n\tend\n\tfind_combinations_helper(test_list, #test_list, 5, {})\n\treturn combinations\nend",
    "    local result = {}\n    local function find_combinations_recursive(test_list, sum, index, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        for i = index, #test_list do\n            find_combinations_recursive(test_list, sum - test_list[i], i, {test_list[i], unpack(current_list)})\n        end\n    end\n    find_combinations_recursive(test_list, 7, 1, {})\n    return result\nend",
    "\tlocal result = {}\n\tlocal function find_combinations_rec(test_list, index, sum, curr_list)\n\t\tif sum == 0 then\n\t\t\ttable.insert(result, curr_list)\n\t\t\treturn\n\t\tend\n\t\tif index == 0 then\n\t\t\treturn\n\t\tend\n\t\tif test_list[index] > sum then\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, curr_list)\n\t\telse\n\t\t\tfind_combinations_rec(test_list, index - 1, sum, curr_list)\n\t\t\tlocal new_list = table.copy(curr_list)\n\t\t\ttable.insert(new_list, test_list[index])\n\t\t\tfind_combinations_rec(test_list, index - 1, sum - test_list[index], new_list)\n\t\tend\n\tend\n\tfind_combinations_rec(test_list, #test_list, 5, {})\n\treturn result\nend",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, curr_list)\n        if sum == 0 then\n            table.insert(result, curr_list)\n            return\n        end\n        if index > #test_list then\n            return\n        end\n        if sum < 0 then\n            return\n        end\n        find_combinations_helper(test_list, index + 1, sum, curr_list)\n        local new_list = {}\n        for i = 1, #curr_list do\n            table.insert(new_list, curr_list[i])\n        end\n        table.insert(new_list, test_list[index])\n        find_combinations_helper(test_list, index + 1, sum - test_list[index], new_list)\n    end\n    find_combinations_helper(test_list, 1, 10, {})\n    return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, path)\n        if sum == 0 then\n            table.insert(result, path)\n            return\n        end\n        if sum < 0 or index < 1 then\n            return\n        end\n        find_combinations_rec(test_list, index - 1, sum, path)\n        table.insert(path, test_list[index])\n        find_combinations_rec(test_list, index - 1, sum - test_list[index], path)\n        table.remove(path)\n    end\n    find_combinations_rec(test_list, #test_list, test_list[1], {})\n    return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, result_list)\n    if sum == 0 then\n      table.insert(result, result_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] <= sum then\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], result_list .. \" \" .. test_list[index])\n    end\n    find_combinations_rec(test_list, index - 1, sum, result_list)\n  end\n  find_combinations_rec(test_list, #test_list, 8, \"\")\n  return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, path)\n        if sum == 0 then\n            table.insert(result, path)\n            return\n        end\n        if sum < 0 or index < 1 then\n            return\n        end\n        find_combinations_rec(test_list, index - 1, sum, path)\n        table.insert(path, test_list[index])\n        find_combinations_rec(test_list, index - 1, sum - test_list[index], path)\n        table.remove(path)\n    end\n    find_combinations_rec(test_list, #test_list, test_list[1], {})\n    return result\nend",
    "    local combinations = {}\n    local function find_combinations_rec(test_list, index, sum, combination)\n        if sum == 0 then\n            table.insert(combinations, combination)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, combination)\n        else\n            find_combinations_rec(test_list, index - 1, sum, combination)\n            combination = table.copy(combination)\n            table.insert(combination, test_list[index])\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], combination)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, test_list[#test_list], {})\n    return combinations\nend",
    "  local result_list = {}\n  local result_list_index = 1\n  local test_list_length = #test_list\n  local test_list_index = 1\n  while test_list_index <= test_list_length do\n    local test_list_index_value = test_list[test_list_index]\n    local test_list_index_value_length = #test_list_index_value\n    local test_list_index_value_index = 1\n    while test_list_index_value_index <= test_list_index_value_length do\n      local test_list_index_value_index_value = test_list_index_value[test_list_index_value_index]\n      local test_list_index_value_index_value_length = #test_list_index_value_index_value\n      local test_list_index_value_index_value_index = 1\n      while test_list_index_value_index_value_index <= test_list_index_value_index_value_length do\n        local test_list_index_value_index_value_index_value = test_list_index_value_index_value[test_list_index_value_index_value_index]\n        local test_list_index_value_index_value_index_value_length = #test_list_index_value_index_value_index_value\n        local test_list_index_value_index_value_index_value_index = 1\n        while test_list_index_value_index_value_index_value_index <= test_list_index_value_index_value_index_value_length do\n          local test_list_index_value_index_value_index_value_index_value = test_list_index_value_index_value_index_value[test_list_index_value_index_value_index_value_index]\n          local test_list_index_value_index_value_index_value_index_value_length = #test_list_index_value_index_value_index_value_index_value\n          local test_list_index_value_index_value_index_value_index_",
    "  local result = {}\n  local function find_combinations_helper(test_list, index, current_sum, current_list)\n    if current_sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > current_sum then\n      find_combinations_helper(test_list, index - 1, current_sum, current_list)\n    else\n      find_combinations_helper(test_list, index - 1, current_sum, current_list)\n      local new_list = {}\n      for _, v in ipairs(current_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_helper(test_list, index - 1, current_sum - test_list[index], new_list)\n    end\n  end\n  find_combinations_helper(test_list, #test_list, 8, {})\n  return result\nend",
    "  local result = {}\n  local function find_combinations_recursive(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if sum < 0 or index < 1 then\n      return\n    end\n    find_combinations_recursive(test_list, index - 1, sum, curr_list)\n    local new_list = {}\n    for i = 1, #curr_list do\n      table.insert(new_list, curr_list[i])\n    end\n    table.insert(new_list, test_list[index])\n    find_combinations_recursive(test_list, index - 1, sum - test_list[index], new_list)\n  end\n  find_combinations_recursive(test_list, #test_list, test_list[#test_list], {})\n  return result\nend",
    "    local result = {}\n    local function find_combinations_rec(test_list, index, sum, current_list)\n        if sum == 0 then\n            table.insert(result, current_list)\n            return\n        end\n        if index == 0 then\n            return\n        end\n        if test_list[index] > sum then\n            find_combinations_rec(test_list, index - 1, sum, current_list)\n        else\n            find_combinations_rec(test_list, index - 1, sum, current_list)\n            current_list[index] = test_list[index]\n            find_combinations_rec(test_list, index - 1, sum - test_list[index], current_list)\n        end\n    end\n    find_combinations_rec(test_list, #test_list, 5, {})\n    return result\nend",
    "  local function find_combinations_helper(test_list, index, sum, current_list, result_list)\n    if sum == 0 then\n      table.insert(result_list, current_list)\n      return\n    end",
    "    local result = {}\n    local function find_combinations_helper(test_list, index, sum, list)\n        if sum == 0 then\n            table.insert(result, list)\n            return\n        end",
    "  local result = {}\n  local function find_combinations_recursive(test_list, index, current_sum, current_list)\n    if current_sum == 0 then\n      table.insert(result, current_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > current_sum then\n      find_combinations_recursive(test_list, index - 1, current_sum, current_list)\n    else\n      find_combinations_recursive(test_list, index - 1, current_sum, current_list)\n      local new_list = {}\n      for _, v in ipairs(current_list) do\n        table.insert(new_list, v)\n      end\n      table.insert(new_list, test_list[index])\n      find_combinations_recursive(test_list, index - 1, current_sum - test_list[index], new_list)\n    end\n  end\n  find_combinations_recursive(test_list, #test_list, 6, {})\n  return result\nend",
    "  local result = {}\n  local function find_combinations_rec(test_list, index, sum, curr_list)\n    if sum == 0 then\n      table.insert(result, curr_list)\n      return\n    end\n    if index == 0 then\n      return\n    end\n    if test_list[index] > sum then\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    else\n      local new_curr_list = table.copy(curr_list)\n      table.insert(new_curr_list, test_list[index])\n      find_combinations_rec(test_list, index - 1, sum - test_list[index], new_curr_list)\n      find_combinations_rec(test_list, index - 1, sum, curr_list)\n    end\n  end\n  find_combinations_rec(test_list, #test_list, 10, {})\n  return result\nend"
  ]
}