{
  "name": "mbpp_9_find_Rotations",
  "language": "lua",
  "prompt": "-- Write a luathon function to find the minimum number of rotations (greater than 0) required to get the same string.\nlocal function find_Rotations(str)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_9_find_Rotations.py",
  "prompt_terminology": "reworded",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_Rotations\n    lu.assertEquals(candidate('aaaa'), 1)\n    lu.assertEquals(candidate('ab'), 2)\n    lu.assertEquals(candidate('abc'), 3)\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local len = #str\n  local min = len\n  for i = 1, len do\n    local s = str:sub(i, len) .. str:sub(1, i - 1)\n    if s < str then\n      min = math.min(min, i)\n    end\n  end\n  return min\nend",
    "  local len = string.len(str)\n  local min_rotations = len\n  local str_concat = str .. str\n  for i=1, len do\n    if string.sub(str_concat, i, i+len-1) == str then\n      min_rotations = math.min(min_rotations, i-1)\n    end\n  end\n  return min_rotations\nend",
    "    local str_len = #str\n    local min_rotations = str_len\n    local min_rotations_index = 0\n    local min_rotations_str = str\n    for i = 1, str_len do\n        local new_str = string.sub(str, i) .. string.sub(str, 1, i - 1)\n        if new_str < min_rotations_str then\n            min_rotations_str = new_str\n            min_rotations_index = i\n        end\n    end\n    return min_rotations_index\nend",
    "  local len = #str\n  local min = len\n  local min_index = 0\n  for i = 1, len do\n    local str1 = string.sub(str, i, len)\n    local str2 = string.sub(str, 1, i - 1)\n    local str3 = str1 .. str2\n    local str4 = string.reverse(str3)\n    local str5 = string.sub(str4, 1, len)\n    local str6 = string.sub(str4, len + 1, 2 * len)\n    local str7 = str5 .. str6\n    local str8 = string.reverse(str7)\n    local str9 = string.sub(str8, 1, len)\n    local str10 = string.sub(str8, len + 1, 2 * len)\n    if str9 == str10 then\n      if min > i then\n        min = i\n        min_index = i\n      end\n    end\n  end\n  return min_index\nend",
    "  local str_len = string.len(str)\n  local str_min = str\n  local str_min_len = str_len\n  for i = 1, str_len do\n    local str_rotated = string.sub(str, i, str_len) .. string.sub(str, 1, i - 1)\n    if string.len(str_rotated) < str_min_len then\n      str_min = str_rotated\n      str_min_len = string.len(str_rotated)\n    end\n  end\n  return str_min\nend",
    "\tlocal str_len = #str\n\tlocal min_rotations = str_len\n\tfor i = 1, str_len do\n\t\tlocal str_rotated = string.sub(str, i, str_len) .. string.sub(str, 1, i - 1)\n\t\tif str_rotated == str then\n\t\t\tmin_rotations = 0\n\t\t\tbreak\n\t\tend\n\t\tif str_rotated < str then\n\t\t\tmin_rotations = math.min(min_rotations, i)\n\t\tend\n\tend\n\treturn min_rotations\nend",
    "    local len = #str\n    local min = len\n    local min_index = 0\n    for i = 1, len do\n        local str_i = str:sub(i, len) .. str:sub(1, i - 1)\n        if str_i < min then\n            min = str_i\n            min_index = i\n        end\n    end\n    return min_index\nend",
    "\tlocal str_len = #str\n\tlocal min_rotations = 0\n\tlocal min_str = str\n\tfor i = 1, str_len do\n\t\tlocal temp_str = str:sub(i) .. str:sub(1, i - 1)\n\t\tif temp_str < min_str then\n\t\t\tmin_str = temp_str\n\t\t\tmin_rotations = i\n\t\tend\n\tend\n\treturn min_rotations\nend",
    "  local len = #str\n  local min_rotations = len\n  for i = 1, len do\n    local s = string.sub(str, i, len) .. string.sub(str, 1, i - 1)\n    if s == str then\n      min_rotations = 0\n      break\n    end\n    local rotations = 0\n    for j = 1, len do\n      if string.sub(s, j, j) == string.sub(str, 1, 1) then\n        rotations = rotations + 1\n        local s1 = string.sub(s, j, len) .. string.sub(s, 1, j - 1)\n        if s1 == str then\n          if min_rotations > rotations then\n            min_rotations = rotations\n          end\n          break\n        end\n      end\n    end\n  end\n  return min_rotations\nend",
    "    local len = string.len(str)\n    local min = len\n    local i = 1\n    while i <= len do\n        if str:sub(i, len) == str:sub(1, len - i + 1) then\n            min = i - 1\n            break\n        end\n        i = i + 1\n    end\n    return min\nend",
    "    local str_len = #str\n    local str_concat = str .. str\n    local min_rotations = str_len\n    for i = 1, str_len do\n        if str_concat:sub(i, i + str_len - 1) < str then\n            min_rotations = i - 1\n        end\n    end\n    return min_rotations\nend",
    "\tlocal len = #str\n\tlocal min_rotations = len\n\tlocal str_concat = str..str\n\tfor i = 1, len do\n\t\tif str_concat:sub(i, i + len - 1) < str then\n\t\t\tmin_rotations = min_rotations - 1\n\t\tend\n\tend\n\treturn min_rotations\nend",
    "    local str_len = #str\n    local str_concat = str..str\n    local min_rotations = str_len\n    for i = 1, str_len do\n        if str_concat:sub(i, i + str_len - 1) == str then\n            min_rotations = math.min(min_rotations, i - 1)\n        end\n    end\n    return min_rotations\nend",
    "  local len = #str\n  local str2 = str .. str\n  local i = 1\n  while i <= len do\n    if str2:sub(i, i + len - 1) == str then\n      return i - 1\n    end\n    i = i + 1\n  end\n  return 0\nend",
    "  local len = #str\n  local min_rotations = len\n  for i = 1, len do\n    local rotations = 0\n    for j = 1, len do\n      if str:sub(i, i) ~= str:sub(j, j) then\n        rotations = rotations + 1\n      end\n    end\n    if rotations < min_rotations then\n      min_rotations = rotations\n    end\n  end\n  return min_rotations\nend",
    "\tlocal min_rotations = 0\n\tlocal str_len = string.len(str)\n\tfor i = 1, str_len do\n\t\tlocal temp_str = string.sub(str, i, str_len) .. string.sub(str, 1, i - 1)\n\t\tif temp_str == str then\n\t\t\tmin_rotations = i\n\t\t\tbreak\n\t\tend\n\tend\n\treturn min_rotations\nend",
    "  local len = string.len(str)\n  local min_rotations = len\n  local str_concat = str .. str\n  for i = 1, len do\n    local substr = string.sub(str_concat, i, i + len - 1)\n    if substr == str then\n      min_rotations = i - 1\n      break\n    end\n  end\n  return min_rotations\nend",
    "  local len = #str\n  local min_rotations = len\n  local str_concat = str .. str\n  for i = 1, len do\n    local rotations = 0\n    local j = i\n    while j <= len do\n      if str_concat:sub(i, j) ~= str_concat:sub(j + 1, j + len) then\n        break\n      end\n      rotations = rotations + 1\n      j = j + 1\n    end\n    if rotations == len then\n      return 1\n    end\n    if rotations < min_rotations then\n      min_rotations = rotations\n    end\n  end\n  return min_rotations + 1\nend",
    "    local len = #str\n    local count = 0\n    local i = 1\n    while i <= len do\n        if str:sub(i,i) == str:sub(1,1) then\n            i = i + 1\n        else\n            count = count + 1\n            i = i + 1\n        end\n    end\n    return count\nend",
    "\tlocal str_len = string.len(str)\n\tlocal str_min = str\n\tfor i = 1, str_len do\n\t\tlocal str_temp = string.sub(str, i, str_len) .. string.sub(str, 1, i - 1)\n\t\tif str_temp < str_min then\n\t\t\tstr_min = str_temp\n\t\tend\n\tend\n\treturn str_min\nend"
  ]
}