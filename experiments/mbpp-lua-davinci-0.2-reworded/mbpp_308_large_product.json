{
  "name": "mbpp_308_large_product",
  "language": "lua",
  "prompt": "-- Write a function to find the specified number of largest products from two given tables, selecting one factor from each table.\nlocal function large_product(nums1, nums2, N)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = large_product\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}, {3, 6, 8, 9, 10, 6}, 3), {60, 54, 50})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}, {3, 6, 8, 9, 10, 6}, 4), {60, 54, 50, 48})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}, {3, 6, 8, 9, 10, 6}, 5), {60, 54, 50, 48, 45})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local function compare(a, b)\n    return a[1] * a[2] > b[1] * b[2]\n  end\n  local function merge(nums1, nums2)\n    local i, j = 1, 1\n    local res = {}\n    while i <= #nums1 and j <= #nums2 do\n      if compare(nums1[i], nums2[j]) then\n        res[#res + 1] = nums1[i]\n        i = i + 1\n      else\n        res[#res + 1] = nums2[j]\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      res[#res + 1] = nums1[i]\n      i = i + 1\n    end\n    while j <= #nums2 do\n      res[#res + 1] = nums2[j]\n      j = j + 1\n    end\n    return res\n  end\n  local function helper(nums1, nums2)\n    if #nums1 == 0 or #nums2 == 0 then return {} end\n    if #nums1 == 1 then\n      local res = {}\n      for i = 1, #nums2 do\n        res[#res + 1] = {nums1[1], nums2[i]}\n      end\n      return res\n    end\n    local mid = math.floor(#nums1 / 2)\n    local left = helper(nums1:sub(1, mid), nums2)\n    local right = helper(nums1:sub(mid + 1), nums2)\n    return merge(left, right)\n  end\n  local res = helper(nums1, nums2)\n  local res_n = {}\n  for i = 1, N do\n    res_n[#res_n + 1] = res[i]\n  end\n  return res_n\nend",
    "\tlocal n1, n2 = #nums1, #nums2\n\tlocal i, j = 1, 1\n\tlocal max_nums1, max_nums2 = {}, {}\n\tlocal max_nums1_len, max_nums2_len = 0, 0\n\tlocal max_nums1_i, max_nums2_i = 0, 0\n\tlocal max_nums1_j, max_nums2_j = 0, 0\n\tlocal max_nums1_val, max_nums2_val = 0, 0\n\tlocal max_nums1_val_i, max_nums2_val_i = 0, 0\n\tlocal max_nums1_val_j, max_nums2_val_j = 0, 0\n\tlocal max_nums1_val_prev, max_nums2_val_prev = 0, 0\n\tlocal max_nums1_val_prev_i, max_nums2_val_prev_i = 0, 0\n\tlocal max_nums1_val_prev_j, max_nums2_val_prev_j = 0, 0\n\tlocal max_nums1_val_prev_prev, max_nums2_val_prev_prev = 0, 0\n\tlocal max_nums1_val_prev_prev_i, max_nums2_val_prev_prev_i = 0, 0\n\tlocal max_nums1_val_prev_prev_j, max_nums2_val_prev_prev_j = 0, 0\n\tlocal max_nums1_val_prev_prev_prev, max_nums2_val_prev_prev_prev = 0, 0\n\tlocal max_nums1_val_prev_prev_prev_i, max_nums2_val_prev_prev_prev_i = 0, 0\n\tlocal max_nums1_val_prev_prev_prev_j, max_nums2_val_prev_prev_prev_j = 0, 0\n\tlocal max_nums1_val_prev_prev_prev_prev, max_nums2_val_prev_prev_prev",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend",
    "    local N = N or 1\n    local products = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            local product = nums1[i] * nums2[j]\n            if #products < N then\n                table.insert(products, product)\n            else\n                local min_product = math.min(unpack(products))\n                if product > min_product then\n                    for k = 1, #products do\n                        if products[k] == min_product then\n                            products[k] = product\n                            break\n                        end\n                    end\n                end\n            end\n        end\n    end\n    return products\nend",
    "  local max_products = {}\n  local max_product = 0\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      local product = nums1[i] * nums2[j]\n      if product > max_product then\n        max_product = product\n        max_products[#max_products + 1] = {nums1[i], nums2[j]}\n      end\n    end\n  end\n  return max_products\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[1], products[2], products[3]\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      local product = nums1[i] * nums2[j]\n      if #products < N then\n        table.insert(products, product)\n      elseif product > products[1] then\n        table.remove(products, 1)\n        table.insert(products, product)\n      end\n    end\n  end\n  return products\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(products, nums1[i] * nums2[j])\n    end\n  end\n  table.sort(products)\n  local result = {}\n  for i = #products - N + 1, #products do\n    table.insert(result, products[i])\n  end\n  return result\nend",
    "\tlocal products = {}\n\tfor i = 1, #nums1 do\n\t\tfor j = 1, #nums2 do\n\t\t\ttable.insert(products, nums1[i] * nums2[j])\n\t\tend\n\tend\n\ttable.sort(products, function(a, b) return a > b end)\n\tlocal result = {}\n\tfor i = 1, N do\n\t\ttable.insert(result, products[i])\n\tend\n\treturn result\nend",
    "  local function compare(a, b)\n    return a[1] * a[2] > b[1] * b[2]\n  end\n  local function merge(a, b)\n    local c = {}\n    local i, j = 1, 1\n    while i <= #a and j <= #b do\n      if compare(a[i], b[j]) then\n        c[#c + 1] = a[i]\n        i = i + 1\n      else\n        c[#c + 1] = b[j]\n        j = j + 1\n      end\n    end\n    while i <= #a do\n      c[#c + 1] = a[i]\n      i = i + 1\n    end\n    while j <= #b do\n      c[#c + 1] = b[j]\n      j = j + 1\n    end\n    return c\n  end\n  local function merge_sort(a)\n    if #a <= 1 then return a end\n    local m = math.floor(#a / 2)\n    local b = merge_sort(a:sub(1, m))\n    local c = merge_sort(a:sub(m + 1))\n    return merge(b, c)\n  end\n  local function large_product_helper(nums1, nums2)\n    local a = {}\n    for i = 1, #nums1 do\n      for j = 1, #nums2 do\n        a[#a + 1] = {nums1[i], nums2[j]}\n      end\n    end\n    return merge_sort(a)\n  end\n  local a = large_product_helper(nums1, nums2)\n  local b = large_product_helper(nums2, nums1)\n  local c = merge(a, b)\n  return c:sub(1, N)\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      local product = nums1[i] * nums2[j]\n      if #products < N then\n        table.insert(products, product)\n      elseif product > products[1] then\n        table.remove(products, 1)\n        table.insert(products, product)\n      end\n    end\n  end\n  return products\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend",
    "    local products = {}\n    for _, num1 in ipairs(nums1) do\n        for _, num2 in ipairs(nums2) do\n            table.insert(products, num1 * num2)\n        end\n    end\n    table.sort(products, function(a, b) return a > b end)\n    return products[N]\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(products, nums1[i] * nums2[j])\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  local result = {}\n  for i = 1, N do\n    table.insert(result, products[i])\n  end\n  return result\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products)\n  local result = {}\n  for i = #products - N + 1, #products do\n    result[#result + 1] = products[i]\n  end\n  return result\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(products, nums1[i] * nums2[j])\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      products[#products + 1] = nums1[i] * nums2[j]\n    end\n  end\n  table.sort(products)\n  local result = {}\n  for i = #products - N + 1, #products do\n    result[#result + 1] = products[i]\n  end\n  return result\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      local product = nums1[i] * nums2[j]\n      if #products < N or product > products[#products] then\n        table.insert(products, product)\n        table.sort(products)\n        if #products > N then\n          table.remove(products)\n        end\n      end\n    end\n  end\n  return products\nend",
    "  local products = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(products, nums1[i] * nums2[j])\n    end\n  end\n  table.sort(products, function(a, b) return a > b end)\n  return products[N]\nend"
  ]
}