{
  "name": "mbpp_4_heap_queue_largest",
  "language": "lua",
  "prompt": "-- Write a function to find the n largest integers from a given table of numbers, returned in descending order.\nlocal function heap_queue_largest(nums, n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "reworded",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = heap_queue_largest\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), {85, 75, 65})\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), {85, 75})\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), {85, 75, 65, 58, 35})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local heap = Heap:new()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "\tlocal heap = {}\n\tfor i = 1, n do\n\t\theap[i] = nums[i]\n\tend\n\theap_make(heap)\n\tfor i = n + 1, #nums do\n\t\tif nums[i] > heap[1] then\n\t\t\theap[1] = nums[i]\n\t\t\theap_sift_down(heap, 1)\n\t\tend\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\tresult[i] = heap_pop(heap)\n\tend\n\treturn result\nend",
    "    local heap = {}\n    local size = 0\n    local function heap_push(x)\n        size = size + 1\n        heap[size] = x\n        local i = size\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p] < heap[i] then\n                heap[i], heap[p] = heap[p], heap[i]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local x = heap[1]\n        heap[1] = heap[size]\n        heap[size] = nil\n        size = size - 1\n        local i = 1\n        while i * 2 <= size do\n            local l = i * 2\n            local r = i * 2 + 1\n            local j = l\n            if r <= size and heap[r] > heap[l] then\n                j = r\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return x\n    end\n    for _, x in ipairs(nums) do\n        heap_push(x)\n        if size > n then\n            heap_pop()\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop()\n    end\n    return result\nend",
    "\tlocal heap = {}\n\tlocal function heap_insert(heap, num)\n\t\ttable.insert(heap, num)\n\t\tlocal i = #heap\n\t\twhile i > 1 do\n\t\t\tlocal j = math.floor(i/2)\n\t\t\tif heap[j] < heap[i] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tlocal function heap_pop(heap)\n\t\tlocal ret = heap[1]\n\t\theap[1] = heap[#heap]\n\t\ttable.remove(heap, #heap)\n\t\tlocal i = 1\n\t\twhile i < #heap do\n\t\t\tlocal j = i*2\n\t\t\tif j < #heap and heap[j] < heap[j+1] then\n\t\t\t\tj = j+1\n\t\t\tend\n\t\t\tif heap[i] < heap[j] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn ret\n\tend\n\tfor _, num in ipairs(nums) do\n\t\tif #heap < n then\n\t\t\theap_insert(heap, num)\n\t\telseif num > heap[1] then\n\t\t\theap_pop(heap)\n\t\t\theap_insert(heap, num)\n\t\tend\n\tend\n\tlocal ret = {}\n\twhile #heap > 0 do\n\t\ttable.insert(ret, heap_pop(heap))\n\tend\n\treturn ret\nend",
    "    local heap = {}\n    for i, num in ipairs(nums) do\n        if i <= n then\n            heap[i] = num\n            heap_sift_up(heap, i)\n        else\n            if num > heap[1] then\n                heap[1] = num\n                heap_sift_down(heap, 1, n)\n            end\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local largest = {}\n  for i = 1, n do\n    largest[i] = heap_pop(heap)\n  end\n  return largest\nend",
    "\tlocal heap = {}\n\tfor _, num in ipairs(nums) do\n\t\tif #heap < n then\n\t\t\ttable.insert(heap, num)\n\t\t\theap_sift_up(heap, #heap)\n\t\telseif num > heap[1] then\n\t\t\theap[1] = num\n\t\t\theap_sift_down(heap, 1)\n\t\tend\n\tend\n\treturn heap\nend",
    "  local heap = {}\n  local heap_size = 0\n  local function heap_insert(num)\n    heap_size = heap_size + 1\n    heap[heap_size] = num\n    local i = heap_size\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_remove()\n    local ret = heap[1]\n    heap[1] = heap[heap_size]\n    heap[heap_size] = nil\n    heap_size = heap_size - 1\n    local i = 1\n    while i * 2 <= heap_size do\n      local left = i * 2\n      local right = i * 2 + 1\n      local largest = i\n      if heap[left] > heap[largest] then\n        largest = left\n      end\n      if right <= heap_size and heap[right] > heap[largest] then\n        largest = right\n      end\n      if largest ~= i then\n        heap[i], heap[largest] = heap[largest], heap[i]\n        i = largest\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_insert(num)\n  end\n  local ret = {}\n  for i = 1, n do\n    ret[i] = heap_remove()\n  end\n  return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    return heap_sort(heap)\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            table.insert(heap, num)\n            heap_heapify_up(heap, #heap)\n        elseif num > heap[1] then\n            heap[1] = num\n            heap_heapify_down(heap, 1)\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for i = 1, #nums do\n    heap[i] = nums[i]\n  end\n  heap_queue_heapify(heap)\n  for i = #nums, n + 1, -1 do\n    heap_queue_pop(heap)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_queue_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            end\n            if right > #heap then\n                if heap[i] < heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            end\n            if heap[i] < heap[left] or heap[i] < heap[right] then\n                if heap[left] > heap[right] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                    i = left\n                else\n                    heap[i], heap[right] = heap[right], heap[i]\n                    i = right\n                end\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for i, num in ipairs(nums) do\n    heap[i] = num\n  end\n  heap_build_max(heap)\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_extract_max(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local heap_size = 0",
    "    local heap = {}\n    local heap_size = 0\n    local function heap_push(num)\n        heap_size = heap_size + 1\n        heap[heap_size] = num\n        local i = heap_size\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local ret = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size = heap_size - 1\n        local i = 1\n        while i * 2 <= heap_size do\n            local child = i * 2\n            if child + 1 <= heap_size and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(num)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop()\n    end\n    return ret\nend"
  ]
}