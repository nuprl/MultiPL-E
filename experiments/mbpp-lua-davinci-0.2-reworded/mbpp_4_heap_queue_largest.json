{
  "name": "mbpp_4_heap_queue_largest",
  "language": "lua",
  "prompt": "-- Write a function to find the n largest integers from a given table of numbers, returned in descending order.\nlocal function heap_queue_largest(nums, n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "reworded",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = heap_queue_largest\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), {85, 75, 65})\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), {85, 75})\n    lu.assertEquals(candidate({25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), {85, 75, 65, 58, 35})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local heap = Heap:new()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "\tlocal heap = {}\n\tfor i = 1, n do\n\t\theap[i] = nums[i]\n\tend\n\theap_make(heap)\n\tfor i = n + 1, #nums do\n\t\tif nums[i] > heap[1] then\n\t\t\theap[1] = nums[i]\n\t\t\theap_sift_down(heap, 1)\n\t\tend\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\tresult[i] = heap_pop(heap)\n\tend\n\treturn result\nend",
    "    local heap = {}\n    local size = 0\n    local function heap_push(x)\n        size = size + 1\n        heap[size] = x\n        local i = size\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p] < heap[i] then\n                heap[i], heap[p] = heap[p], heap[i]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local x = heap[1]\n        heap[1] = heap[size]\n        heap[size] = nil\n        size = size - 1\n        local i = 1\n        while i * 2 <= size do\n            local l = i * 2\n            local r = i * 2 + 1\n            local j = l\n            if r <= size and heap[r] > heap[l] then\n                j = r\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return x\n    end\n    for _, x in ipairs(nums) do\n        heap_push(x)\n        if size > n then\n            heap_pop()\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop()\n    end\n    return result\nend",
    "\tlocal heap = {}\n\tlocal function heap_insert(heap, num)\n\t\ttable.insert(heap, num)\n\t\tlocal i = #heap\n\t\twhile i > 1 do\n\t\t\tlocal j = math.floor(i/2)\n\t\t\tif heap[j] < heap[i] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tlocal function heap_pop(heap)\n\t\tlocal ret = heap[1]\n\t\theap[1] = heap[#heap]\n\t\ttable.remove(heap, #heap)\n\t\tlocal i = 1\n\t\twhile i < #heap do\n\t\t\tlocal j = i*2\n\t\t\tif j < #heap and heap[j] < heap[j+1] then\n\t\t\t\tj = j+1\n\t\t\tend\n\t\t\tif heap[i] < heap[j] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn ret\n\tend\n\tfor _, num in ipairs(nums) do\n\t\tif #heap < n then\n\t\t\theap_insert(heap, num)\n\t\telseif num > heap[1] then\n\t\t\theap_pop(heap)\n\t\t\theap_insert(heap, num)\n\t\tend\n\tend\n\tlocal ret = {}\n\twhile #heap > 0 do\n\t\ttable.insert(ret, heap_pop(heap))\n\tend\n\treturn ret\nend",
    "    local heap = {}\n    for i, num in ipairs(nums) do\n        if i <= n then\n            heap[i] = num\n            heap_sift_up(heap, i)\n        else\n            if num > heap[1] then\n                heap[1] = num\n                heap_sift_down(heap, 1, n)\n            end\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local largest = {}\n  for i = 1, n do\n    largest[i] = heap_pop(heap)\n  end\n  return largest\nend",
    "\tlocal heap = {}\n\tfor _, num in ipairs(nums) do\n\t\tif #heap < n then\n\t\t\ttable.insert(heap, num)\n\t\t\theap_sift_up(heap, #heap)\n\t\telseif num > heap[1] then\n\t\t\theap[1] = num\n\t\t\theap_sift_down(heap, 1)\n\t\tend\n\tend\n\treturn heap\nend",
    "  local heap = {}\n  local heap_size = 0\n  local function heap_insert(num)\n    heap_size = heap_size + 1\n    heap[heap_size] = num\n    local i = heap_size\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_remove()\n    local ret = heap[1]\n    heap[1] = heap[heap_size]\n    heap[heap_size] = nil\n    heap_size = heap_size - 1\n    local i = 1\n    while i * 2 <= heap_size do\n      local left = i * 2\n      local right = i * 2 + 1\n      local largest = i\n      if heap[left] > heap[largest] then\n        largest = left\n      end\n      if right <= heap_size and heap[right] > heap[largest] then\n        largest = right\n      end\n      if largest ~= i then\n        heap[i], heap[largest] = heap[largest], heap[i]\n        i = largest\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_insert(num)\n  end\n  local ret = {}\n  for i = 1, n do\n    ret[i] = heap_remove()\n  end\n  return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    return heap_sort(heap)\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            table.insert(heap, num)\n            heap_heapify_up(heap, #heap)\n        elseif num > heap[1] then\n            heap[1] = num\n            heap_heapify_down(heap, 1)\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for i = 1, #nums do\n    heap[i] = nums[i]\n  end\n  heap_queue_heapify(heap)\n  for i = #nums, n + 1, -1 do\n    heap_queue_pop(heap)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_queue_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            end\n            if right > #heap then\n                if heap[i] < heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            end\n            if heap[i] < heap[left] or heap[i] < heap[right] then\n                if heap[left] > heap[right] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                    i = left\n                else\n                    heap[i], heap[right] = heap[right], heap[i]\n                    i = right\n                end\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for i, num in ipairs(nums) do\n    heap[i] = num\n  end\n  heap_build_max(heap)\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_extract_max(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local heap_size = 0",
    "    local heap = {}\n    local heap_size = 0\n    local function heap_push(num)\n        heap_size = heap_size + 1\n        heap[heap_size] = num\n        local i = heap_size\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local ret = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size = heap_size - 1\n        local i = 1\n        while i * 2 <= heap_size do\n            local child = i * 2\n            if child + 1 <= heap_size and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(num)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop()\n    end\n    return ret\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    heap[#heap + 1] = num\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[i] < heap[left] then\n          heap[i], heap[left] = heap[left], heap[i]\n        end\n        break\n      else\n        if heap[left] > heap[right] then\n          if heap[i] < heap[left] then\n            heap[i], heap[left] = heap[left], heap[i]\n            i = left\n          else\n            break\n          end\n        else\n          if heap[i] < heap[right] then\n            heap[i], heap[right] = heap[right], heap[i]\n            i = right\n          else\n            break\n          end\n        end\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    ret[i] = heap_pop(heap)\n  end\n  return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_push(heap, item)\n    heap[#heap + 1] = item\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local item = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      local max = left\n      if right <= #heap and heap[right] > heap[left] then\n        max = right\n      end\n      if heap[max] > heap[i] then\n        heap[max], heap[i] = heap[i], heap[max]\n        i = max\n      else\n        break\n      end\n    end\n    return item\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for _ = 1, n do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  local heap_size = 0\n  local function heap_insert(num)\n    heap_size = heap_size + 1\n    heap[heap_size] = num\n    local i = heap_size\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    local ret = heap[1]\n    heap[1] = heap[heap_size]\n    heap_size = heap_size - 1\n    local i = 1\n    while i * 2 <= heap_size do\n      local left = i * 2\n      local right = i * 2 + 1\n      local largest = i\n      if heap[left] > heap[largest] then\n        largest = left\n      end\n      if right <= heap_size and heap[right] > heap[largest] then\n        largest = right\n      end\n      if largest ~= i then\n        heap[i], heap[largest] = heap[largest], heap[i]\n        i = largest\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_insert(num)\n  end\n  local ret = {}\n  for i = 1, n do\n    ret[i] = heap_pop()\n  end\n  return ret\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[i] < heap[left] then\n          heap[i], heap[left] = heap[left], heap[i]\n        end\n        break\n      else\n        local max = heap[left] > heap[right] and left or right\n        if heap[i] < heap[max] then\n          heap[i], heap[max] = heap[max], heap[i]\n          i = max\n        else\n          break\n        end\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_insert(heap, num)\n    elseif num > heap[1] then\n      heap_pop(heap)\n      heap_insert(heap, num)\n    end\n  end\n  local ret = {}\n  while #heap > 0 do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heap_build_max_heap(heap)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heap_max_heapify(heap, 1)\n    end\n  end\n  return heap\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "\tlocal heap = {}\n\tfor _, num in ipairs(nums) do\n\t\ttable.insert(heap, num)\n\t\theap_sift_up(heap, #heap)\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\ttable.insert(result, heap_pop(heap))\n\tend\n\treturn result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for i = 1, #nums do\n        heap_push(heap, nums[i])\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        result[#result + 1] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[left] > heap[i] then\n                    heap[left], heap[i] = heap[i], heap[left]\n                end\n                break\n            else\n                if heap[left] > heap[right] then\n                    if heap[left] > heap[i] then\n                        heap[left], heap[i] = heap[i], heap[left]\n                        i = left\n                    else\n                        break\n                    end\n                else\n                    if heap[right] > heap[i] then\n                        heap[right], heap[i] = heap[i], heap[right]\n                        i = right\n                    else\n                        break\n                    end\n                end\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        table.insert(ret, 1, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, v in ipairs(nums) do\n    heap_push(heap, v)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_insert(heap, num)\n    elseif num > heap[1] then\n      heap_replace(heap, num)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_extract(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    local heap_size = 0",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    heap[#heap + 1] = num\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[i] < heap[left] then\n          heap[i], heap[left] = heap[left], heap[i]\n        end\n        break\n      else\n        if heap[left] > heap[right] then\n          if heap[i] < heap[left] then\n            heap[i], heap[left] = heap[left], heap[i]\n            i = left\n          else\n            break\n          end\n        else\n          if heap[i] < heap[right] then\n            heap[i], heap[right] = heap[right], heap[i]\n            i = right\n          else\n            break\n          end\n        end\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local ret = {}\n  for _ = 1, n do\n    ret[#ret + 1] = heap_pop(heap)\n  end\n  return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        table.insert(heap, num)\n        heap_up(heap, #heap)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap[1]\n        heap[1] = heap[#heap]\n        heap_down(heap, 1, #heap - 1)\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for _ = 1, n do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_extract_max(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i] > heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local j = i * 2\n      if j < #heap and heap[j] < heap[j + 1] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for i = 1, #nums do\n    if i <= n then\n      heap_push(heap, nums[i])\n    else\n      if nums[i] > heap[1] then\n        heap_pop(heap)\n        heap_push(heap, nums[i])\n      end\n    end\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[max] > heap[i] then\n                heap[max], heap[i] = heap[i], heap[max]\n                i = max\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      local largest = left\n      if right <= #heap and heap[right] > heap[left] then\n        largest = right\n      end\n      if heap[i] < heap[largest] then\n        heap[i], heap[largest] = heap[largest], heap[i]\n        i = largest\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heapify(heap, n)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heapify(heap, n, 1)\n    end\n  end\n  local res = {}\n  for i = 1, n do\n    res[i] = heap[1]\n    heap[1] = heap[n - i + 1]\n    heapify(heap, n - i, 1)\n  end\n  return res\nend",
    "\tlocal heap = Heap.new(function(a, b) return a > b end)\n\tfor _, num in ipairs(nums) do\n\t\theap:push(num)\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\tresult[i] = heap:pop()\n\tend\n\treturn result\nend",
    "  local heap = {}\n  local function push(x)\n    local i = #heap + 1\n    heap[i] = x\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local x = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return x\n  end\n  for i = 1, n do\n    push(nums[i])\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      pop()\n      push(nums[i])\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = pop()\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    heap[#heap + 1] = num\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      local largest = i\n      if left <= #heap and heap[left] > heap[largest] then\n        largest = left\n      end\n      if right <= #heap and heap[right] > heap[largest] then\n        largest = right\n      end\n      if largest ~= i then\n        heap[largest], heap[i] = heap[i], heap[largest]\n        i = largest\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    ret[i] = heap_pop(heap)\n  end\n  return ret\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for i = 1, #nums do\n        heap_insert(heap, nums[i])\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    local last = table.remove(heap)\n    if #heap > 0 then\n      heap[1] = last\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j + 1 <= #heap and heap[j + 1] > heap[j] then\n          j = j + 1\n        end\n        if heap[i] < heap[j] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_queue_build(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heap_queue_heapify(heap, 1, n)\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap[1]\n        heap[1] = heap[n]\n        n = n - 1\n        heap_queue_heapify(heap, 1, n)\n    end\n    return ret\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heap_queue_heapify(heap, n)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heap_queue_sift_down(heap, 1, n)\n    end\n  end\n  heap_queue_sort(heap, n)\n  return heap\nend",
    "  local heap = {}\n  local function heap_insert(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap, #heap)\n    local i = 1\n    while i < #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[i] < heap[left] then\n          heap[i], heap[left] = heap[left], heap[i]\n        end\n        break\n      else\n        local max = heap[left]\n        local max_i = left\n        if heap[right] > max then\n          max = heap[right]\n          max_i = right\n        end\n        if heap[i] < max then\n          heap[i], heap[max_i] = heap[max_i], heap[i]\n          i = max_i\n        else\n          break\n        end\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i] > heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local val = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[j] > heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return val\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    ret[i] = heap_pop(heap)\n  end\n  return ret\nend",
    "  local heap = {}\n  local function sift_up(i)\n    local parent = math.floor(i / 2)\n    if parent > 0 and heap[parent] < heap[i] then\n      heap[parent], heap[i] = heap[i], heap[parent]\n      sift_up(parent)\n    end\n  end\n  local function sift_down(i)\n    local left = i * 2\n    local right = i * 2 + 1\n    local largest = i\n    if left <= #heap and heap[left] > heap[largest] then\n      largest = left\n    end\n    if right <= #heap and heap[right] > heap[largest] then\n      largest = right\n    end\n    if largest ~= i then\n      heap[i], heap[largest] = heap[largest], heap[i]\n      sift_down(largest)\n    end\n  end\n  local function insert(num)\n    heap[#heap + 1] = num\n    sift_up(#heap)\n  end\n  local function extract()\n    local max = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    sift_down(1)\n    return max\n  end\n  for _, num in ipairs(nums) do\n    insert(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = extract()\n  end\n  return result\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heap_build_max(heap)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heap_max_heapify(heap, 1)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_extract_max(heap)\n  end\n  return result\nend",
    "\tlocal heap = {}\n\tlocal function heap_push(heap, num)\n\t\ttable.insert(heap, num)\n\t\tlocal i = #heap\n\t\twhile i > 1 do\n\t\t\tlocal j = math.floor(i / 2)\n\t\t\tif heap[j] < heap[i] then\n\t\t\t\theap[j], heap[i] = heap[i], heap[j]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tlocal function heap_pop(heap)\n\t\tlocal num = heap[1]\n\t\theap[1] = heap[#heap]\n\t\theap[#heap] = nil\n\t\tlocal i = 1\n\t\twhile i * 2 <= #heap do\n\t\t\tlocal j = i * 2\n\t\t\tif j < #heap and heap[j] < heap[j + 1] then\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\t\tif heap[i] < heap[j] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn num\n\tend\n\tfor _, num in ipairs(nums) do\n\t\theap_push(heap, num)\n\t\tif #heap > n then\n\t\t\theap_pop(heap)\n\t\tend\n\tend\n\tlocal result = {}\n\twhile #heap > 0 do\n\t\ttable.insert(result, 1, heap_pop(heap))\n\tend\n\treturn result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        table.insert(heap, num)\n        if #heap > n then\n            table.remove(heap, 1)\n        end\n        heap_sift_down(heap, 1, #heap)\n    end\n    return heap\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p] < heap[i] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local c = i * 2\n            if c + 1 <= #heap and heap[c + 1] > heap[c] then\n                c = c + 1\n            end\n            if heap[i] < heap[c] then\n                heap[i], heap[c] = heap[c], heap[i]\n                i = c\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, n do\n        heap_push(heap, nums[i])\n    end\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap_pop(heap)\n            heap_push(heap, nums[i])\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "\tlocal heap = Heap()\n\tfor _, num in ipairs(nums) do\n\t\theap:push(num)\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\tresult[i] = heap:pop()\n\tend\n\treturn result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    local size = 0\n    local function heap_push(num)\n        size = size + 1\n        heap[size] = num\n        local i = size\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local num = heap[1]\n        heap[1] = heap[size]\n        heap[size] = nil\n        size = size - 1\n        local i = 1\n        while i * 2 <= size do\n            local child = i * 2\n            if child + 1 <= size and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return num\n    end\n    for _, num in ipairs(nums) do\n        heap_push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop()\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_push(heap, value)\n        table.insert(heap, value)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local value = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = left + 1\n            local largest = i\n            if left <= #heap and heap[left] > heap[largest] then\n                largest = left\n            end\n            if right <= #heap and heap[right] > heap[largest] then\n                largest = right\n            end\n            if largest ~= i then\n                heap[largest], heap[i] = heap[i], heap[largest]\n                i = largest\n            else\n                break\n            end\n        end\n        return value\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, 1, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        table.insert(heap, num)\n        heap_sift_up(heap, #heap)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {nums[1]}\n  for i = 2, #nums do\n    heap_insert(heap, nums[i])\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = Heap.new(function(a, b) return a > b end)\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "\tlocal heap = {}\n\tfor _, num in ipairs(nums) do\n\t\ttable.insert(heap, num)\n\t\theap_sift_up(heap, #heap)\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\tlocal num = table.remove(heap, 1)\n\t\ttable.insert(result, num)\n\t\theap_sift_down(heap, 1)\n\tend\n\treturn result\nend",
    "    local heap = {}\n    for i, num in ipairs(nums) do\n        if #heap < n then\n            heap[#heap + 1] = num\n            heap_sift_up(heap, #heap)\n        elseif num > heap[1] then\n            heap[1] = num\n            heap_sift_down(heap, 1)\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_queue_heapify(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap_queue_replace(heap, n, nums[i])\n        end\n    end\n    return heap_queue_sort(heap, n)\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    return heap_sort(heap)\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[i] < heap[max] then\n                heap[i], heap[max] = heap[max], heap[i]\n                i = max\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  local heap_size = 0\n  local function heap_push(val)\n    heap_size = heap_size + 1\n    heap[heap_size] = val\n    local i = heap_size\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] < heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    if heap_size == 0 then\n      return nil\n    end\n    local val = heap[1]\n    heap[1] = heap[heap_size]\n    heap_size = heap_size - 1\n    local i = 1\n    while i <= heap_size do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left <= heap_size and heap[left] > heap[i] then\n        if right <= heap_size and heap[right] > heap[left] then\n          heap[right], heap[i] = heap[i], heap[right]\n          i = right\n        else\n          heap[left], heap[i] = heap[i], heap[left]\n          i = left\n        end\n      elseif right <= heap_size and heap[right] > heap[i] then\n        heap[right], heap[i] = heap[i], heap[right]\n        i = right\n      else\n        break\n      end\n    end\n    return val\n  end\n  for _, num in ipairs(nums) do\n    heap_push(num)\n  end\n  local result = {}\n  for _ = 1, n do\n    local val = heap_pop()\n    if val == nil then\n      break\n    end\n    table.insert(result, val)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_insert(heap, num)\n    elseif num > heap[1] then\n      heap_replace(heap, num)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "  local heap = {}\n  local function heap_insert(n)\n    table.insert(heap, n)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    local n = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[j] > heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return n\n  end\n  for _, n in ipairs(nums) do\n    heap_insert(n)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, heap_pop())\n  end\n  return ret\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heap_queue_heapify(heap, n)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heap_queue_sift_down(heap, 1, n)\n    end\n  end\n  heap_queue_sort(heap, n)\n  return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = Heap(nums, function(a, b) return a > b end)\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heap_queue_heapify(heap)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heap_queue_sift_down(heap, 1)\n    end\n  end\n  for i = n, 1, -1 do\n    heap[1], heap[i] = heap[i], heap[1]\n    heap_queue_sift_down(heap, 1, i - 1)\n  end\n  return heap\nend",
    "  local heap = {}\n  local heap_size = 0",
    "  local heap = {}\n  local heap_size = 0",
    "    local heap = Heap:new(function(a, b) return a > b end)\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            table.insert(heap, num)\n            heap_sift_up(heap)\n        elseif heap[1] < num then\n            heap[1] = num\n            heap_sift_down(heap)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        local i = #heap + 1\n        heap[i] = num\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local largest = i\n            if left <= #heap and heap[left] > heap[largest] then\n                largest = left\n            end\n            if right <= #heap and heap[right] > heap[largest] then\n                largest = right\n            end\n            if largest ~= i then\n                heap[largest], heap[i] = heap[i], heap[largest]\n                i = largest\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop(heap)\n    end\n    return ret\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        local i = #heap + 1\n        heap[i] = num\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local n = #heap\n        local result = heap[1]\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while i < n do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = i\n            if left <= n and heap[left] > heap[max] then\n                max = left\n            end\n            if right <= n and heap[right] > heap[max] then\n                max = right\n            end\n            if max ~= i then\n                heap[i], heap[max] = heap[max], heap[i]\n                i = max\n            else\n                break\n            end\n        end\n        return result\n    end\n    for i = 1, n do\n        heap_insert(heap, nums[i])\n    end\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap_pop(heap)\n            heap_insert(heap, nums[i])\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, 1, heap_pop(heap))\n    end\n    return result\nend",
    "\tlocal heap = {}\n\tfor i, v in ipairs(nums) do\n\t\tif #heap < n then\n\t\t\ttable.insert(heap, v)\n\t\t\theap_sift_up(heap, #heap)\n\t\telseif v > heap[1] then\n\t\t\theap[1] = v\n\t\t\theap_sift_down(heap, 1, #heap)\n\t\tend\n\tend\n\tlocal ret = {}\n\tfor i = 1, n do\n\t\ttable.insert(ret, heap[1])\n\t\theap[1] = heap[#heap]\n\t\ttable.remove(heap)\n\t\theap_sift_down(heap, 1, #heap)\n\tend\n\treturn ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    table.insert(heap, num)\n    heap_sift_up(heap, #heap)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heapify(heap)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heapify(heap, 1)\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heapify(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heapify(heap, n, 1)\n        end\n    end\n    return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local largest = {}\n  for i = 1, n do\n    largest[i] = heap_pop(heap)\n  end\n  return largest\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    local heap_size = 0\n    local function heap_push(num)\n        heap_size = heap_size + 1\n        heap[heap_size] = num\n        local i = heap_size\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop()\n        local ret = heap[1]\n        heap[1] = heap[heap_size]\n        heap[heap_size] = nil\n        heap_size = heap_size - 1\n        local i = 1\n        while i * 2 <= heap_size do\n            local child = i * 2\n            if child + 1 <= heap_size and heap[child + 1] > heap[child] then\n                child = child + 1\n            end\n            if heap[i] < heap[child] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, #nums do\n        if heap_size < n then\n            heap_push(nums[i])\n        elseif nums[i] > heap[1] then\n            heap_pop()\n            heap_push(nums[i])\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop()\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    for i, num in ipairs(nums) do\n        heap[i] = num\n    end\n    heap_queue_heapify(heap)\n    for i = #heap, #heap - n + 1, -1 do\n        heap_queue_pop(heap)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_queue_pop(heap)\n    end\n    return result\nend",
    "\tlocal heap = {}\n\tlocal function push(x)\n\t\theap[#heap+1] = x\n\t\tlocal i = #heap\n\t\twhile i > 1 do\n\t\t\tlocal j = math.floor(i/2)\n\t\t\tif heap[j] < heap[i] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tlocal function pop()\n\t\tlocal ret = heap[1]\n\t\theap[1] = heap[#heap]\n\t\theap[#heap] = nil\n\t\tlocal i = 1\n\t\twhile i < #heap do\n\t\t\tlocal j = i*2\n\t\t\tif j < #heap and heap[j] < heap[j+1] then\n\t\t\t\tj = j+1\n\t\t\tend\n\t\t\tif heap[i] < heap[j] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn ret\n\tend\n\tfor i = 1, n do\n\t\tpush(nums[i])\n\tend\n\tfor i = n+1, #nums do\n\t\tif nums[i] > heap[1] then\n\t\t\tpop()\n\t\t\tpush(nums[i])\n\t\tend\n\tend\n\tlocal ret = {}\n\tfor i = 1, n do\n\t\tret[i] = pop()\n\tend\n\treturn ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local res = {}\n    while #heap > 0 do\n        table.insert(res, heap_pop(heap))\n    end\n    return res\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local ret = {}\n  while #heap > 0 do\n    table.insert(ret, 1, heap_pop(heap))\n  end\n  return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = Heap()\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap:pop()\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    for i = 1, #nums do\n        heap_insert(heap, nums[i])\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_extract_max(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_insert(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    local function sift_up(i)\n        local parent = math.floor(i / 2)\n        if parent > 0 and heap[i] > heap[parent] then\n            heap[i], heap[parent] = heap[parent], heap[i]\n            sift_up(parent)\n        end\n    end\n    local function sift_down(i)\n        local left = i * 2\n        local right = i * 2 + 1\n        local largest = i\n        if left <= #heap and heap[left] > heap[largest] then\n            largest = left\n        end\n        if right <= #heap and heap[right] > heap[largest] then\n            largest = right\n        end\n        if largest ~= i then\n            heap[i], heap[largest] = heap[largest], heap[i]\n            sift_down(largest)\n        end\n    end\n    for _, num in ipairs(nums) do\n        heap[#heap + 1] = num\n        sift_up(#heap)\n    end\n    for i = #heap, #heap - n + 1, -1 do\n        heap[1], heap[i] = heap[i], heap[1]\n        sift_down(1)\n    end\n    return heap\nend",
    "  local heap = Heap:new()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    return heap_sort(heap)\nend",
    "    local heap = {}\n    for i, v in ipairs(nums) do\n        if #heap < n then\n            table.insert(heap, v)\n            heap_sift_up(heap, #heap)\n        elseif v > heap[1] then\n            heap[1] = v\n            heap_sift_down(heap, 1, #heap)\n        end\n    end\n    return heap\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, num)\n        elseif num > heap[1] then\n            heap_replace(heap, num)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] > heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local left = i * 2\n      local right = i * 2 + 1\n      local largest = left\n      if right <= #heap and heap[right] > heap[left] then\n        largest = right\n      end\n      if heap[i] < heap[largest] then\n        heap[i], heap[largest] = heap[largest], heap[i]\n        i = largest\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local hq = HeapQueue.new(n)\n  for _, num in ipairs(nums) do\n    hq:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = hq:pop()\n  end\n  return result\nend",
    "  local heap = {}\n  local function sift_up(i)\n    local parent = math.floor(i / 2)\n    if parent < 1 then return end\n    if heap[parent] < heap[i] then\n      heap[parent], heap[i] = heap[i], heap[parent]\n      sift_up(parent)\n    end\n  end\n  local function sift_down(i)\n    local left, right = i * 2, i * 2 + 1\n    if right <= #heap then\n      if heap[left] > heap[right] then\n        if heap[left] > heap[i] then\n          heap[left], heap[i] = heap[i], heap[left]\n          sift_down(left)\n        end\n      else\n        if heap[right] > heap[i] then\n          heap[right], heap[i] = heap[i], heap[right]\n          sift_down(right)\n        end\n      end\n    elseif left <= #heap and heap[left] > heap[i] then\n      heap[left], heap[i] = heap[i], heap[left]\n      sift_down(left)\n    end\n  end\n  for i = 1, n do\n    heap[i] = nums[i]\n    sift_up(i)\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      sift_down(1)\n    end\n  end\n  for i = #heap, 2, -1 do\n    heap[1], heap[i] = heap[i], heap[1]\n    sift_down(1)\n  end\n  return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_insert(heap, num)\n        else\n            if num > heap[1] then\n                heap_replace(heap, num)\n            end\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            table.insert(heap, num)\n            heap_sift_up(heap, #heap)\n        elseif num > heap[1] then\n            heap[1] = num\n            heap_sift_down(heap, 1, #heap)\n        end\n    end\n    local result = {}\n    for i = #heap, 1, -1 do\n        table.insert(result, heap[1])\n        heap[1] = heap[i]\n        heap_sift_down(heap, 1, i - 1)\n    end\n    return result\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i] > heap[parent] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = left\n            if right <= #heap and heap[right] > heap[left] then\n                max = right\n            end\n            if heap[i] < heap[max] then\n                heap[i], heap[max] = heap[max], heap[i]\n                i = max\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "    local heap = {}\n    local function heap_insert(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local max = i\n            if left <= #heap and heap[left] > heap[max] then\n                max = left\n            end\n            if right <= #heap and heap[right] > heap[max] then\n                max = right\n            end\n            if max ~= i then\n                heap[max], heap[i] = heap[i], heap[max]\n                i = max\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_remove(heap)\n    end\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_remove(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_queue_heapify(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heap_queue_sift_down(heap, 1, n)\n        end\n    end\n    for i = n, 2, -1 do\n        heap[1], heap[i] = heap[i], heap[1]\n        heap_queue_sift_down(heap, 1, i - 1)\n    end\n    return heap\nend",
    "  local heap = {}\n  local function sift_up(i)\n    local parent = math.floor(i / 2)\n    if parent > 0 and heap[i] > heap[parent] then\n      heap[i], heap[parent] = heap[parent], heap[i]\n      sift_up(parent)\n    end\n  end\n  local function sift_down(i)\n    local left = i * 2\n    local right = left + 1\n    local largest = i\n    if left <= #heap and heap[left] > heap[largest] then\n      largest = left\n    end\n    if right <= #heap and heap[right] > heap[largest] then\n      largest = right\n    end\n    if largest ~= i then\n      heap[i], heap[largest] = heap[largest], heap[i]\n      sift_down(largest)\n    end\n  end\n  for _, num in ipairs(nums) do\n    table.insert(heap, num)\n    sift_up(#heap)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap[1]\n    heap[1] = heap[#heap]\n    table.remove(heap)\n    sift_down(1)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_extract_max(heap)\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_queue_build(heap)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap_queue_replace(heap, nums[i])\n        end\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_queue_pop(heap)\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        if #heap < n then\n            heap_insert(heap, num)\n        else\n            if num > heap[1] then\n                heap_replace(heap, num)\n            end\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      heap_insert(heap, num)\n    elseif num > heap[1] then\n      heap_replace(heap, num)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    result[#result + 1] = heap_pop(heap)\n  end\n  return result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    if #heap < n then\n      table.insert(heap, num)\n      heap_sift_up(heap, #heap)\n    elseif num > heap[1] then\n      heap[1] = num\n      heap_sift_down(heap, 1)\n    end\n  end\n  return heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    table.insert(heap, num)\n    heap_sift_up(heap, #heap)\n  end",
    "    local heap = {}\n    local function push(num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap, #heap)\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[i] < heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            else\n                if heap[left] > heap[right] then\n                    if heap[i] < heap[left] then\n                        heap[i], heap[left] = heap[left], heap[i]\n                        i = left\n                    else\n                        break\n                    end\n                else\n                    if heap[i] < heap[right] then\n                        heap[i], heap[right] = heap[right], heap[i]\n                        i = right\n                    else\n                        break\n                    end\n                end\n            end\n        end\n        return ret\n    end\n    for i = 1, #nums do\n        push(nums[i])\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, pop())\n    end\n    return ret\nend",
    "\tlocal heap = {}\n\tfor _, num in ipairs(nums) do\n\t\ttable.insert(heap, num)\n\t\theap_sift_up(heap, #heap)\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\tresult[i] = heap_pop(heap)\n\tend\n\treturn result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_queue_push(heap, num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap_queue_pop(heap)\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    result[i] = heap:pop()\n  end\n  return result\nend",
    "\tlocal heap = {}\n\tlocal function heap_insert(v)\n\t\ttable.insert(heap, v)\n\t\tlocal i = #heap\n\t\twhile i > 1 do\n\t\t\tlocal j = math.floor(i / 2)\n\t\t\tif heap[j] < heap[i] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tlocal function heap_pop()\n\t\tlocal v = heap[1]\n\t\theap[1] = heap[#heap]\n\t\ttable.remove(heap)\n\t\tlocal i = 1\n\t\twhile i < #heap do\n\t\t\tlocal j = i * 2\n\t\t\tif j + 1 <= #heap and heap[j + 1] > heap[j] then\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\t\tif heap[i] < heap[j] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn v\n\tend\n\tfor i = 1, #nums do\n\t\tif i <= n then\n\t\t\theap_insert(nums[i])\n\t\telseif nums[i] > heap[1] then\n\t\t\theap_pop()\n\t\t\theap_insert(nums[i])\n\t\tend\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\ttable.insert(result, 1, heap_pop())\n\tend\n\treturn result\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local res = {}\n    while #heap > 0 do\n        table.insert(res, heap_pop(heap))\n    end\n    return res\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_make(heap)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heap_sift_down(heap, 1)\n        end\n    end\n    return heap\nend",
    "  local heap = Heap.new(function(a, b) return a > b end)\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "\tlocal heap = {}\n\tfor i, num in ipairs(nums) do\n\t\tif i <= n then\n\t\t\theap[i] = num\n\t\telse\n\t\t\tif num > heap[1] then\n\t\t\t\theap[1] = num\n\t\t\tend\n\t\tend\n\t\tif i > 1 then\n\t\t\theap_sift_down(heap, 1, i)\n\t\tend\n\tend\n\tfor i = n, 2, -1 do\n\t\theap_swap(heap, 1, i)\n\t\theap_sift_down(heap, 1, i - 1)\n\tend\n\treturn heap\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n  end\n  local ret = {}\n  for i = 1, n do\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "\tlocal heap = {}\n\tlocal function heap_push(heap, num)\n\t\ttable.insert(heap, num)\n\t\tlocal i = #heap\n\t\twhile i > 1 do\n\t\t\tlocal j = math.floor(i / 2)\n\t\t\tif heap[j] < heap[i] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tlocal function heap_pop(heap)\n\t\tlocal ret = heap[1]\n\t\tlocal i = 1\n\t\twhile i * 2 <= #heap do\n\t\t\tlocal j = i * 2\n\t\t\tif j + 1 <= #heap and heap[j + 1] > heap[j] then\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\t\tif heap[i] < heap[j] then\n\t\t\t\theap[i], heap[j] = heap[j], heap[i]\n\t\t\t\ti = j\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\ttable.remove(heap)\n\t\treturn ret\n\tend\n\tfor _, num in ipairs(nums) do\n\t\tif #heap < n then\n\t\t\theap_push(heap, num)\n\t\telseif num > heap[1] then\n\t\t\theap_pop(heap)\n\t\t\theap_push(heap, num)\n\t\tend\n\tend\n\tlocal ret = {}\n\tfor i = 1, n do\n\t\ttable.insert(ret, heap_pop(heap))\n\tend\n\treturn ret\nend",
    "  local heap = {}\n  local function heap_insert(v)\n    table.insert(heap, v)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    local v = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return v\n  end\n  for _, v in ipairs(nums) do\n    heap_insert(v)\n  end\n  local res = {}\n  for i = 1, n do\n    table.insert(res, heap_pop())\n  end\n  return res\nend",
    "    local heap = Heap.new(nums, function(a, b) return a > b end)\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap:pop())\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "  local heap = {}\n  local function heap_insert(n)\n    table.insert(heap, n)\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p] < heap[i] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    local r = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local l, r = i * 2, i * 2 + 1\n      if l > #heap then\n        break\n      elseif r > #heap then\n        if heap[i] < heap[l] then\n          heap[i], heap[l] = heap[l], heap[i]\n        end\n        break\n      else\n        if heap[l] > heap[r] then\n          if heap[i] < heap[l] then\n            heap[i], heap[l] = heap[l], heap[i]\n            i = l\n          else\n            break\n          end\n        else\n          if heap[i] < heap[r] then\n            heap[i], heap[r] = heap[r], heap[i]\n            i = r\n          else\n            break\n          end\n        end\n      end\n    end\n    return r\n  end\n  for i = 1, #nums do\n    if i <= n then\n      heap_insert(nums[i])\n    else\n      if nums[i] > heap[1] then\n        heap_pop()\n        heap_insert(nums[i])\n      end\n    end\n  end\n  local r = {}\n  while #heap > 0 do\n    table.insert(r, 1, heap_pop())\n  end\n  return r\nend",
    "    local heap = {}\n    for i, v in ipairs(nums) do\n        if #heap < n then\n            heap_push(heap, v)\n        elseif v > heap[1] then\n            heap_replace(heap, v)\n        end\n    end\n    local result = {}\n    for i = 1, n do\n        result[i] = heap_pop(heap)\n    end\n    return result\nend",
    "    local heap = {}\n    for i = 1, n do\n        heap[i] = nums[i]\n    end\n    heap_build(heap, n)\n    for i = n + 1, #nums do\n        if nums[i] > heap[1] then\n            heap[1] = nums[i]\n            heap_sift_down(heap, 1, n)\n        end\n    end\n    heap_sort(heap, n)\n    return heap\nend",
    "  local heap = {}\n  local function heap_push(heap, num)\n    table.insert(heap, num)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for _, num in ipairs(nums) do\n    heap_push(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local ret = {}\n  while #heap > 0 do\n    table.insert(ret, 1, heap_pop(heap))\n  end\n  return ret\nend",
    "\tlocal heap = {}\n\tfor _, num in ipairs(nums) do\n\t\tif #heap < n then\n\t\t\ttable.insert(heap, num)\n\t\t\theap_sift_up(heap, #heap)\n\t\telseif num > heap[1] then\n\t\t\theap[1] = num\n\t\t\theap_sift_down(heap, 1)\n\t\tend\n\tend\n\tlocal result = {}\n\tfor i = 1, n do\n\t\ttable.insert(result, heap[1])\n\t\theap[1] = heap[#heap]\n\t\ttable.remove(heap)\n\t\theap_sift_down(heap, 1)\n\tend\n\treturn result\nend",
    "    local heap = {}\n    local function heap_push(heap, num)\n        heap[#heap + 1] = num\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] < heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = left + 1\n            if left > #heap then\n                break\n            elseif right > #heap then\n                if heap[i] < heap[left] then\n                    heap[i], heap[left] = heap[left], heap[i]\n                end\n                break\n            else\n                local max = heap[left]\n                local max_i = left\n                if heap[right] > max then\n                    max = heap[right]\n                    max_i = right\n                end\n                if heap[i] < max then\n                    heap[i], heap[max_i] = heap[max_i], heap[i]\n                    i = max_i\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n    end\n    local ret = {}\n    for i = 1, n do\n        ret[i] = heap_pop(heap)\n    end\n    return ret\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        table.insert(heap, num)\n        heap_sift_up(heap, #heap)\n    end\n    local result = {}\n    for i = 1, n do\n        local max = heap_pop(heap)\n        table.insert(result, max)\n    end\n    return result\nend",
    "    local heap = Heap.new(function(a, b) return a > b end)\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap:pop())\n    end\n    return result\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_insert(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end\n    local result = {}\n    while #heap > 0 do\n        table.insert(result, heap_pop(heap))\n    end\n    return result\nend",
    "    local heap = Heap.new(function(a, b) return a > b end)\n    for _, num in ipairs(nums) do\n        heap:push(num)\n    end\n    local result = {}\n    for i = 1, n do\n        table.insert(result, heap:pop())\n    end\n    return result\nend",
    "  local heap = {}\n  local heap_size = 0\n  local function heap_insert(num)\n    heap_size = heap_size + 1\n    heap[heap_size] = num\n    local i = heap_size\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j] < heap[i] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop()\n    local ret = heap[1]\n    heap[1] = heap[heap_size]\n    heap_size = heap_size - 1\n    local i = 1\n    while i * 2 <= heap_size do\n      local j = i * 2\n      if j + 1 <= heap_size and heap[j + 1] > heap[j] then\n        j = j + 1\n      end\n      if heap[i] < heap[j] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  for i = 1, n do\n    heap_insert(nums[i])\n  end\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap_pop()\n      heap_insert(nums[i])\n    end\n  end\n  local ret = {}\n  for i = 1, n do\n    ret[i] = heap_pop()\n  end\n  return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n  end",
    "    local heap = {}\n    local function heap_push(heap, num)\n        table.insert(heap, num)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i/2)\n            if heap[i] > heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local j = i*2\n            if j+1 <= #heap and heap[j+1] > heap[j] then\n                j = j+1\n            end\n            if heap[i] < heap[j] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, #nums do\n        heap_push(heap, nums[i])\n    end\n    local ret = {}\n    for i = 1, n do\n        table.insert(ret, heap_pop(heap))\n    end\n    return ret\nend",
    "  local heap = {}\n  for _, num in ipairs(nums) do\n    heap_insert(heap, num)\n    if #heap > n then\n      heap_pop(heap)\n    end\n  end\n  local result = {}\n  while #heap > 0 do\n    table.insert(result, heap_pop(heap))\n  end\n  return result\nend",
    "  local heap = {}\n  for i = 1, n do\n    heap[i] = nums[i]\n  end\n  heap_build_max(heap)\n  for i = n + 1, #nums do\n    if nums[i] > heap[1] then\n      heap[1] = nums[i]\n      heap_max_heapify(heap, 1)\n    end\n  end\n  return heap_sort_desc(heap)\nend",
    "    local heap = {}\n    for _, num in ipairs(nums) do\n        heap_push(heap, num)\n        if #heap > n then\n            heap_pop(heap)\n        end\n    end",
    "  local heap = Heap:new()\n  for _, num in ipairs(nums) do\n    heap:push(num)\n  end\n  local result = {}\n  for i = 1, n do\n    table.insert(result, heap:pop())\n  end\n  return result\nend"
  ]
}