{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "lua",
  "prompt": "-- Write a function to find k number of smallest pairs which consist of one element from the first table and one element from the second table.\nlocal function k_smallest_pairs(nums1, nums2, k)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = k_smallest_pairs\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 2), {{1, 2}, {1, 4}})\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 1), {{1, 2}})\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 7), {{1, 2}, {1, 4}, {3, 2}, {1, 6}, {3, 4}, {3, 6}, {7, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  local function pop()\n    if #heap == 0 then\n      return nil\n    end\n    local top = heap[1]\n    local last = heap[#heap]\n    heap[1] = last\n    heap[#heap] = nil\n    local i, j = last[2], last[3]\n    local function sift_down(i)\n      while true do\n        local min_index = i\n        local left = i * 2\n        local right = i * 2 + 1\n        if left <= #heap and heap[left][1] < heap[min_index][1] then\n          min_index = left\n        end\n        if right <= #heap and heap[right][1] < heap[min_index][1] then\n          min_index = right\n        end\n        if min_index == i then\n          break\n        end\n        heap[i], heap[min_index] = heap[min_index], heap[i]\n        i = min_index\n      end\n    end\n    sift_down(1)\n    return top\n  end\n  local function sift_up(i)\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent][1] <= heap[i][1] then\n        break\n      end\n      heap[parent], heap[i] = heap[i], heap[parent]\n      i = parent\n    end\n  end\n  push(1, 1)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local top = pop()\n    result[#result + 1] = {top[2], top[3]}\n    push(top[2] + 1, top[3])\n    push(top[2], top[3] + 1)\n    k = k - 1\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local result = {}\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n    end\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][3] > heap[i][3] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local result = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while true do\n      local j = i * 2\n      if j > #heap then\n        break\n      elseif j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n        j = j + 1\n      end\n      if heap[i][3] > heap[j][3] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return result\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  while #heap > 0 do\n    local pair = pop()\n    table.insert(result, {nums1[pair[1]], nums2[pair[2]]})\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    local function pop()\n        if #heap > 0 then\n            local ret = heap[1]\n            local last = heap[#heap]\n            heap[1] = last\n            heap[#heap] = nil\n            local i, j = 1, 1\n            while true do\n                local l = 2 * i\n                local r = 2 * i + 1\n                if l > #heap then\n                    break\n                end\n                if r <= #heap and heap[r][1] < heap[l][1] then\n                    l = r\n                end\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            end\n            return ret\n        end\n    end\n    local function top()\n        return heap[1]\n    end\n    local function empty()\n        return #heap == 0\n    end\n    push(1, 1)\n    local ret = {}\n    while not empty() and #ret < k do\n        local _, i, j = unpack(pop())\n        ret[#ret + 1] = {nums1[i], nums2[j]}\n        push(i, j + 1)\n        if j == 1 then\n            push(i + 1, 1)\n        end\n    end\n    return ret\nend",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] > heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local len1, len2 = #nums1, #nums2\n  if len1 == 0 or len2 == 0 then return {} end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][3] > sum then\n          heap[i], heap[parent] = heap[parent], heap[i]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local left, right = i * 2, i * 2 + 1\n        local min_child = left\n        if right <= #heap and heap[right][3] < heap[left][3] then\n          min_child = right\n        end\n        if heap[min_child][3] < heap[i][3] then\n          heap[i], heap[min_child] = heap[min_child], heap[i]\n          i = min_child\n        else\n          break\n        end\n      end\n    end\n  end\n  push(1, 1)\n  local res = {}\n  while #heap > 0 do\n    local i, j, sum = table.unpack(table.remove(heap, 1))\n    table.insert(res, {nums1[i], nums2[j]})\n    if j < len2 then\n      push(i, j + 1)\n    end\n  end\n  return res\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap+1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  local function pop()\n    local top = heap[1]\n    local last = heap[#heap]\n    heap[1] = last\n    heap[#heap] = nil\n    local i, j = last[2], last[3]\n    push(i, j+1)\n    push(i+1, j)\n    local k = 1\n    while k < #heap do\n      local l, r = k*2, k*2+1\n      if r <= #heap then\n        if heap[l][1] < heap[r][1] then\n          if heap[k][1] > heap[l][1] then\n            heap[k], heap[l] = heap[l], heap[k]\n            k = l\n          else\n            break\n          end\n        else\n          if heap[k][1] > heap[r][1] then\n            heap[k], heap[r] = heap[r], heap[k]\n            k = r\n          else\n            break\n          end\n        end\n      elseif l <= #heap then\n        if heap[k][1] > heap[l][1] then\n          heap[k], heap[l] = heap[l], heap[k]\n          k = l\n        else\n          break\n        end\n      else\n        break\n      end\n    end\n    return top\n  end\n  local function top()\n    return heap[1]\n  end\n  local function empty()\n    return #heap == 0\n  end\n  push(1, 1)\n  local result = {}\n  while k > 0 and not empty() do\n    local top = pop()\n    result[#result+1] = {nums1[top[2]], nums2[top[3]]}\n    k = k - 1\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local res = {}\n  local function add_pair(i, j)\n    if i > #nums1 or j > #nums2 then return end\n    table.insert(res, {nums1[i], nums2[j]})\n  end\n  local i, j = 1, 1\n  while #res < k do\n    add_pair(i, j)\n    if j == #nums2 then\n      i = i + 1\n      j = 1\n    else\n      j = j + 1\n    end\n  end\n  return res\nend",
    "  local function merge(nums1, nums2)\n    local i, j = 1, 1\n    local res = {}\n    while i <= #nums1 and j <= #nums2 do\n      if nums1[i] < nums2[j] then\n        table.insert(res, nums1[i])\n        i = i + 1\n      else\n        table.insert(res, nums2[j])\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      table.insert(res, nums1[i])\n      i = i + 1\n    end\n    while j <= #nums2 do\n      table.insert(res, nums2[j])\n      j = j + 1\n    end\n    return res\n  end",
    "    local result = {}\n    local heap = {}",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    return res\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > sum then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                local min = l\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    min = r\n                end\n                if heap[i][3] > heap[min][3] then\n                    heap[i], heap[min] = heap[min], heap[i]\n                    i = min\n                else\n                    break\n                end\n            end\n        end\n    end\n    push(1, 1)\n    local result = {}\n    while #heap > 0 do\n        local i, j, sum = table.unpack(table.remove(heap, 1))\n        table.insert(result, {nums1[i], nums2[j]})\n        if j < len2 then\n            push(i, j + 1)\n        end\n        if j == 1 and i < len1 then\n            push(i + 1, 1)\n        end\n    end\n    return result\nend",
    "  local function heap_pop(heap)\n    local ret = heap[1]\n    local last = table.remove(heap)\n    if #heap > 0 then\n      heap[1] = last\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j < #heap and heap[j][1] > heap[j + 1][1] then\n          j = j + 1\n        end\n        if last[1] <= heap[j][1] then\n          break\n        end\n        heap[i] = heap[j]\n        i = j\n      end\n      heap[i] = last\n    end\n    return ret\n  end",
    "  local res = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then\n    return res\n  end\n  local function push(n1, n2)\n    local sum = n1 + n2\n    local i = 1\n    while i <= #res and res[i][1] < sum do\n      i = i + 1\n    end\n    table.insert(res, i, {sum, n1, n2})\n    if #res > k then\n      table.remove(res)\n    end\n  end\n  for i = 1, math.min(k, len1) do\n    push(nums1[i], nums2[1])\n  end\n  for i = 2, len2 do\n    for j = 1, #res do\n      if res[j][2] < nums1[1] then\n        break\n      end\n      push(res[j][2], nums2[i])\n    end\n  end\n  return res\nend",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local function merge(nums1, nums2)\n        local i, j, m, n = 1, 1, #nums1, #nums2\n        local res = {}\n        while i <= m and j <= n do\n            if nums1[i] < nums2[j] then\n                table.insert(res, {nums1[i], nums2[j]})\n                i = i + 1\n            else\n                table.insert(res, {nums1[i], nums2[j]})\n                j = j + 1\n            end\n        end\n        while i <= m do\n            table.insert(res, {nums1[i], nums2[j]})\n            i = i + 1\n        end\n        while j <= n do\n            table.insert(res, {nums1[i], nums2[j]})\n            j = j + 1\n        end\n        return res\n    end\n    local res = merge(nums1, nums2)\n    local function quick_sort(res, l, r)\n        if l >= r then return end\n        local i, j, pivot = l, r, res[l].sum\n        while i < j do\n            while i < j and res[j].sum >= pivot do j = j - 1 end\n            if i < j then res[i].sum, res[j].sum = res[j].sum, res[i].sum end\n            while i < j and res[i].sum <= pivot do i = i + 1 end\n            if i < j then res[i].sum, res[j].sum = res[j].sum, res[i].sum end\n        end\n        quick_sort(res, l, i - 1)\n        quick_sort(res, i + 1, r)\n    end\n    quick_sort(res, 1, #res)\n    local res = {}\n    for i = 1, k do\n        table.insert(res, res[i])\n    end\n    return res\nend",
    "  local len1, len2 = #nums1, #nums2\n  if len1 == 0 or len2 == 0 then return {} end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > sum then\n          heap[i], heap[p] = heap[p], heap[i]\n          i = p\n        else\n          break\n        end\n      end\n    elseif heap[1][3] > sum then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = i * 2 + 1\n        local min_i = l\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          min_i = r\n        end\n        if heap[i][3] > heap[min_i][3] then\n          heap[i], heap[min_i] = heap[min_i], heap[i]\n          i = min_i\n        else\n          break\n        end\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      local r = i * 2 + 1\n      local min_i = l\n      if r <= #heap and heap[r][3] < heap[l][3] then\n        min_i = r\n      end\n      if heap[i][3] > heap[min_i][3] then\n        heap[i], heap[min_i] = heap[min_i], heap[i]\n        i = min_i\n      else\n        break\n     ",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend"
  ]
}