{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "lua",
  "prompt": "-- Write a function to find k number of smallest pairs which consist of one element from the first table and one element from the second table.\nlocal function k_smallest_pairs(nums1, nums2, k)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = k_smallest_pairs\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 2), {{1, 2}, {1, 4}})\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 1), {{1, 2}})\n    lu.assertEquals(candidate({1, 3, 7}, {2, 4, 6}, 7), {{1, 2}, {1, 4}, {3, 2}, {1, 6}, {3, 4}, {3, 6}, {7, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
  "stop_tokens": [
    "\nlocal",
    "\nfunction",
    "\n--",
    "\n\n"
  ],
  "completions": [
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  local function pop()\n    if #heap == 0 then\n      return nil\n    end\n    local top = heap[1]\n    local last = heap[#heap]\n    heap[1] = last\n    heap[#heap] = nil\n    local i, j = last[2], last[3]\n    local function sift_down(i)\n      while true do\n        local min_index = i\n        local left = i * 2\n        local right = i * 2 + 1\n        if left <= #heap and heap[left][1] < heap[min_index][1] then\n          min_index = left\n        end\n        if right <= #heap and heap[right][1] < heap[min_index][1] then\n          min_index = right\n        end\n        if min_index == i then\n          break\n        end\n        heap[i], heap[min_index] = heap[min_index], heap[i]\n        i = min_index\n      end\n    end\n    sift_down(1)\n    return top\n  end\n  local function sift_up(i)\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent][1] <= heap[i][1] then\n        break\n      end\n      heap[parent], heap[i] = heap[i], heap[parent]\n      i = parent\n    end\n  end\n  push(1, 1)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local top = pop()\n    result[#result + 1] = {top[2], top[3]}\n    push(top[2] + 1, top[3])\n    push(top[2], top[3] + 1)\n    k = k - 1\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local result = {}\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n    end\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][3] > heap[i][3] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function pop()\n    local result = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while true do\n      local j = i * 2\n      if j > #heap then\n        break\n      elseif j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n        j = j + 1\n      end\n      if heap[i][3] > heap[j][3] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return result\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  while #heap > 0 do\n    local pair = pop()\n    table.insert(result, {nums1[pair[1]], nums2[pair[2]]})\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    local function pop()\n        if #heap > 0 then\n            local ret = heap[1]\n            local last = heap[#heap]\n            heap[1] = last\n            heap[#heap] = nil\n            local i, j = 1, 1\n            while true do\n                local l = 2 * i\n                local r = 2 * i + 1\n                if l > #heap then\n                    break\n                end\n                if r <= #heap and heap[r][1] < heap[l][1] then\n                    l = r\n                end\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            end\n            return ret\n        end\n    end\n    local function top()\n        return heap[1]\n    end\n    local function empty()\n        return #heap == 0\n    end\n    push(1, 1)\n    local ret = {}\n    while not empty() and #ret < k do\n        local _, i, j = unpack(pop())\n        ret[#ret + 1] = {nums1[i], nums2[j]}\n        push(i, j + 1)\n        if j == 1 then\n            push(i + 1, 1)\n        end\n    end\n    return ret\nend",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[parent] > heap[i] then\n        heap[parent], heap[i] = heap[i], heap[parent]\n        i = parent\n      else\n        break\n      end\n    end\n  end",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local len1, len2 = #nums1, #nums2\n  if len1 == 0 or len2 == 0 then return {} end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][3] > sum then\n          heap[i], heap[parent] = heap[parent], heap[i]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local left, right = i * 2, i * 2 + 1\n        local min_child = left\n        if right <= #heap and heap[right][3] < heap[left][3] then\n          min_child = right\n        end\n        if heap[min_child][3] < heap[i][3] then\n          heap[i], heap[min_child] = heap[min_child], heap[i]\n          i = min_child\n        else\n          break\n        end\n      end\n    end\n  end\n  push(1, 1)\n  local res = {}\n  while #heap > 0 do\n    local i, j, sum = table.unpack(table.remove(heap, 1))\n    table.insert(res, {nums1[i], nums2[j]})\n    if j < len2 then\n      push(i, j + 1)\n    end\n  end\n  return res\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap+1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  local function pop()\n    local top = heap[1]\n    local last = heap[#heap]\n    heap[1] = last\n    heap[#heap] = nil\n    local i, j = last[2], last[3]\n    push(i, j+1)\n    push(i+1, j)\n    local k = 1\n    while k < #heap do\n      local l, r = k*2, k*2+1\n      if r <= #heap then\n        if heap[l][1] < heap[r][1] then\n          if heap[k][1] > heap[l][1] then\n            heap[k], heap[l] = heap[l], heap[k]\n            k = l\n          else\n            break\n          end\n        else\n          if heap[k][1] > heap[r][1] then\n            heap[k], heap[r] = heap[r], heap[k]\n            k = r\n          else\n            break\n          end\n        end\n      elseif l <= #heap then\n        if heap[k][1] > heap[l][1] then\n          heap[k], heap[l] = heap[l], heap[k]\n          k = l\n        else\n          break\n        end\n      else\n        break\n      end\n    end\n    return top\n  end\n  local function top()\n    return heap[1]\n  end\n  local function empty()\n    return #heap == 0\n  end\n  push(1, 1)\n  local result = {}\n  while k > 0 and not empty() do\n    local top = pop()\n    result[#result+1] = {nums1[top[2]], nums2[top[3]]}\n    k = k - 1\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local res = {}\n  local function add_pair(i, j)\n    if i > #nums1 or j > #nums2 then return end\n    table.insert(res, {nums1[i], nums2[j]})\n  end\n  local i, j = 1, 1\n  while #res < k do\n    add_pair(i, j)\n    if j == #nums2 then\n      i = i + 1\n      j = 1\n    else\n      j = j + 1\n    end\n  end\n  return res\nend",
    "  local function merge(nums1, nums2)\n    local i, j = 1, 1\n    local res = {}\n    while i <= #nums1 and j <= #nums2 do\n      if nums1[i] < nums2[j] then\n        table.insert(res, nums1[i])\n        i = i + 1\n      else\n        table.insert(res, nums2[j])\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      table.insert(res, nums1[i])\n      i = i + 1\n    end\n    while j <= #nums2 do\n      table.insert(res, nums2[j])\n      j = j + 1\n    end\n    return res\n  end",
    "    local result = {}\n    local heap = {}",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    return res\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > sum then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                local min = l\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    min = r\n                end\n                if heap[i][3] > heap[min][3] then\n                    heap[i], heap[min] = heap[min], heap[i]\n                    i = min\n                else\n                    break\n                end\n            end\n        end\n    end\n    push(1, 1)\n    local result = {}\n    while #heap > 0 do\n        local i, j, sum = table.unpack(table.remove(heap, 1))\n        table.insert(result, {nums1[i], nums2[j]})\n        if j < len2 then\n            push(i, j + 1)\n        end\n        if j == 1 and i < len1 then\n            push(i + 1, 1)\n        end\n    end\n    return result\nend",
    "  local function heap_pop(heap)\n    local ret = heap[1]\n    local last = table.remove(heap)\n    if #heap > 0 then\n      heap[1] = last\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j < #heap and heap[j][1] > heap[j + 1][1] then\n          j = j + 1\n        end\n        if last[1] <= heap[j][1] then\n          break\n        end\n        heap[i] = heap[j]\n        i = j\n      end\n      heap[i] = last\n    end\n    return ret\n  end",
    "  local res = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then\n    return res\n  end\n  local function push(n1, n2)\n    local sum = n1 + n2\n    local i = 1\n    while i <= #res and res[i][1] < sum do\n      i = i + 1\n    end\n    table.insert(res, i, {sum, n1, n2})\n    if #res > k then\n      table.remove(res)\n    end\n  end\n  for i = 1, math.min(k, len1) do\n    push(nums1[i], nums2[1])\n  end\n  for i = 2, len2 do\n    for j = 1, #res do\n      if res[j][2] < nums1[1] then\n        break\n      end\n      push(res[j][2], nums2[i])\n    end\n  end\n  return res\nend",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local function merge(nums1, nums2)\n        local i, j, m, n = 1, 1, #nums1, #nums2\n        local res = {}\n        while i <= m and j <= n do\n            if nums1[i] < nums2[j] then\n                table.insert(res, {nums1[i], nums2[j]})\n                i = i + 1\n            else\n                table.insert(res, {nums1[i], nums2[j]})\n                j = j + 1\n            end\n        end\n        while i <= m do\n            table.insert(res, {nums1[i], nums2[j]})\n            i = i + 1\n        end\n        while j <= n do\n            table.insert(res, {nums1[i], nums2[j]})\n            j = j + 1\n        end\n        return res\n    end\n    local res = merge(nums1, nums2)\n    local function quick_sort(res, l, r)\n        if l >= r then return end\n        local i, j, pivot = l, r, res[l].sum\n        while i < j do\n            while i < j and res[j].sum >= pivot do j = j - 1 end\n            if i < j then res[i].sum, res[j].sum = res[j].sum, res[i].sum end\n            while i < j and res[i].sum <= pivot do i = i + 1 end\n            if i < j then res[i].sum, res[j].sum = res[j].sum, res[i].sum end\n        end\n        quick_sort(res, l, i - 1)\n        quick_sort(res, i + 1, r)\n    end\n    quick_sort(res, 1, #res)\n    local res = {}\n    for i = 1, k do\n        table.insert(res, res[i])\n    end\n    return res\nend",
    "  local len1, len2 = #nums1, #nums2\n  if len1 == 0 or len2 == 0 then return {} end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > sum then\n          heap[i], heap[p] = heap[p], heap[i]\n          i = p\n        else\n          break\n        end\n      end\n    elseif heap[1][3] > sum then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = i * 2 + 1\n        local min_i = l\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          min_i = r\n        end\n        if heap[i][3] > heap[min_i][3] then\n          heap[i], heap[min_i] = heap[min_i], heap[i]\n          i = min_i\n        else\n          break\n        end\n      end\n    end\n  end\n  local function pop()\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      local r = i * 2 + 1\n      local min_i = l\n      if r <= #heap and heap[r][3] < heap[l][3] then\n        min_i = r\n      end\n      if heap[i][3] > heap[min_i][3] then\n        heap[i], heap[min_i] = heap[min_i], heap[i]\n        i = min_i\n      else\n        break\n     ",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  if #nums1 == 0 or #nums2 == 0 then\n    return {}\n  end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > heap[i][3] then\n          heap[p], heap[i] = heap[i], heap[p]\n          i = p\n        else\n          break\n        end\n      end\n    elseif heap[1][3] > sum then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = i * 2 + 1\n        local j = l\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          j = r\n        end\n        if heap[i][3] > heap[j][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  local result = {}\n  for i = 1, #heap do\n    local pair = heap[i]\n    table.insert(result, {nums1[pair[1]], nums2[pair[2]]})\n    if pair[2] < #nums2 then\n      push(pair[1], pair[2] + 1)\n    end\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      heap_up(heap, #heap)\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      heap_down(heap, 1)\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local res = {}\n  for i = 1, k do\n    if heap[1] then\n      local pair = heap[1]\n      table.insert(res, {nums1[pair[1]], nums2[pair[2]]})\n      push(pair[1], pair[2] + 1)\n    end\n  end\n  return res\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[i][1] + heap[i][2] < heap[j][1] + heap[j][2] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      table.sort(heap, function(a, b) return a[3] < b[3] end)\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      table.sort(heap, function(a, b) return a[3] < b[3] end)\n    end\n  end\n  push(1, 1)\n  local result = {}\n  while #heap > 0 do\n    local i, j, sum = table.unpack(table.remove(heap))\n    table.insert(result, {nums1[i], nums2[j]})\n    if j < #nums2 then\n      push(i, j + 1)\n    elseif i < #nums1 then\n      push(i + 1, 1)\n    end\n  end\n  return result\nend",
    "    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local res = {}\n    for i = 1, k do\n        table.insert(res, pairs[i])\n    end\n    return res\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            table.insert(heap, {nums1[i] + nums2[j], i, j})\n        end\n    end\n    push(1, 1)\n    table.sort(heap, function(a, b) return a[1] < b[1] end)\n    local result = {}\n    for i = 1, k do\n        if #heap == 0 then break end\n        local pair = table.remove(heap, 1)\n        table.insert(result, {nums1[pair[2]], nums2[pair[3]]})\n        push(pair[2], pair[3] + 1)\n        if pair[3] == 1 then\n            push(pair[2] + 1, 1)\n        end\n    end\n    return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[1] < b[1] end)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local pair = table.remove(heap, 1)\n    result[#result + 1] = {nums1[pair[2]], nums2[pair[3]]}\n    push(pair[2], pair[3] + 1)\n    push(pair[2] + 1, pair[3])\n    k = k - 1\n  end\n  return result\nend",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local result = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(result, nums1[i])\n                i = i + 1\n            else\n                table.insert(result, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(result, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(result, nums2[j])\n            j = j + 1\n        end\n        return result\n    end\n    local function merge_sort(nums)\n        if #nums <= 1 then\n            return nums\n        end\n        local mid = math.floor(#nums / 2)\n        local left = merge_sort(nums, 1, mid)\n        local right = merge_sort(nums, mid + 1, #nums)\n        return merge(left, right)\n    end\n    local function find_k_smallest_pairs(nums1, nums2, k)\n        local result = {}\n        local i, j = 1, 1\n        while i <= #nums1 and j <= #nums2 and #result < k do\n            if nums1[i] < nums2[j] then\n                table.insert(result, {nums1[i], nums2[j]})\n                i = i + 1\n            else\n                table.insert(result, {nums1[i], nums2[j]})\n                j = j + 1\n            end\n        end\n        while i <= #nums1 and #result < k do\n            table.insert(result, {nums1[i], nums2[j]})\n            i = i + 1\n        end\n        while j <= #nums2 and #result < k do\n            table.insert(result, {nums1[i], nums2[j]})\n",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local res = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(res, nums1[i])\n                i = i + 1\n            else\n                table.insert(res, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(res, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(res, nums2[j])\n            j = j + 1\n        end\n        return res\n    end",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][1] > heap[i][1] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        end\n    end\n    local function pop()\n        if #heap == 0 then\n            return nil\n        end\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n                j = j + 1\n            end\n            if heap[i][1] > heap[j][1] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local ret = {}\n    push(1, 1)\n    for i = 1, k do\n        local p = pop()\n        if not p then\n            break\n        end\n        ret[i] = {nums1[p[2]], nums2[p[3]]}\n        push(p[2], p[3] + 1)\n        if p[3] == 1 then\n            push(p[2] + 1, 1)\n        end\n    end\n    return ret\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        end\n    end\n    push(1, 1)\n    local res = {}\n    while #heap > 0 do\n        local i, j, sum = table.unpack(table.remove(heap))\n        table.insert(res, {nums1[i], nums2[j]})\n        if j < len2 then\n            push(i, j + 1)\n        end\n        if j == 1 and i < len1 then\n            push(i + 1, 1)\n        end\n    end\n    return res\nend",
    "    local len1, len2 = #nums1, #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local parent = math.floor(i / 2)\n                if heap[parent][3] > heap[i][3] then\n                    heap[parent], heap[i] = heap[i], heap[parent]\n                    i = parent\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > sum then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local left = i * 2\n                local right = i * 2 + 1\n                local child = left\n                if right <= #heap and heap[right][3] < heap[left][3] then\n                    child = right\n                end\n                if heap[child][3] < heap[i][3] then\n                    heap[child], heap[i] = heap[i], heap[child]\n                    i = child\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local res = {}\n    while #heap > 0 do\n        local pair = table.remove(heap, 1)\n        table.insert(res, {nums1[pair[1]], nums2[pair[2]]})\n        if pair[2] < len2 then\n            push(pair[1], pair[2] + 1)\n        end\n    end\n    return res\nend",
    "    local function merge(nums1, nums2)\n        local i, j, m, n = 1, 1, #nums1, #nums2\n        local res = {}\n        while i <= m and j <= n do\n            if nums1[i] < nums2[j] then\n                res[#res+1] = {nums1[i], nums2[j]}\n                i = i + 1\n            else\n                res[#res+1] = {nums1[i], nums2[j]}\n                j = j + 1\n            end\n        end\n        while i <= m do\n            res[#res+1] = {nums1[i], nums2[j]}\n            i = i + 1\n        end\n        while j <= n do\n            res[#res+1] = {nums1[i], nums2[j]}\n            j = j + 1\n        end\n        return res\n    end\n    local res = merge(nums1, nums2)\n    local function partition(res, l, r)\n        local pivot = res[l][1] + res[l][2]\n        local i, j = l, r\n        while i < j do\n            while i < j and res[j][1] + res[j][2] >= pivot do\n                j = j - 1\n            end\n            res[i], res[j] = res[j], res[i]\n            while i < j and res[i][1] + res[i][2] <= pivot do\n                i = i + 1\n            end\n            res[i], res[j] = res[j], res[i]\n        end\n        return i\n    end\n    local function quick_sort(res, l, r)\n        if l < r then\n            local p = partition(res, l, r)\n            quick_sort(res, l, p-1)\n            quick_sort(res, p+1, r)\n        end\n    end\n    quick_sort(res, 1, #res)\n    local result = {}\n    for i = 1, k do\n        result[i] = res[i]\n",
    "  local function heap_pop(heap)\n    local value = heap[1]\n    local last = table.remove(heap)\n    if #heap > 0 then\n      heap[1] = last\n      local i = 1\n      while true do\n        local left = i * 2\n        local right = i * 2 + 1\n        if left > #heap then\n          break\n        end\n        local min_index = left\n        if right <= #heap and heap[right][1] < heap[left][1] then\n          min_index = right\n        end\n        if heap[i][1] > heap[min_index][1] then\n          heap[i], heap[min_index] = heap[min_index], heap[i]\n          i = min_index\n        else\n          break\n        end\n      end\n    end\n    return value\n  end",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    local function pop()\n        if #heap == 0 then\n            return nil\n        end\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n                j = j + 1\n            end\n            if heap[i][1] <= heap[j][1] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n        return ret\n    end\n    local function sift_up(i)\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] <= heap[i][1] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n    end\n    push(1, 1)\n    local ret = {}\n    for i = 1, k do\n        local pair = pop()\n        if pair == nil then\n            break\n        end\n        ret[i] = {nums1[pair[2]], nums2[pair[3]]}\n        push(pair[2] + 1, pair[3])\n        push(pair[2], pair[3] + 1)\n    end\n    return ret\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      pairs[#pairs + 1] = {nums1[i], nums2[j]}\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    result[i] = pairs[i]\n  end\n  return result\nend",
    "  local result = {}\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    local heap_size = #heap\n    if heap_size < k then\n      heap[heap_size + 1] = {sum, i, j}\n      heap_size = heap_size + 1\n    elseif sum < heap[1][1] then\n      heap[1] = {sum, i, j}\n    else\n      return\n    end\n    local i = 1\n    while i <= heap_size do\n      local left = i * 2\n      local right = left + 1\n      local min_i = i\n      if left <= heap_size and heap[left][1] < heap[min_i][1] then\n        min_i = left\n      end\n      if right <= heap_size and heap[right][1] < heap[min_i][1] then\n        min_i = right\n      end\n      if min_i ~= i then\n        heap[i], heap[min_i] = heap[min_i], heap[i]\n        i = min_i\n      else\n        break\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][2]], nums2[heap[i][3]]}\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap+1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > heap[i][3] then\n          heap[p], heap[i] = heap[i], heap[p]\n          i = p\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = l + 1\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          l = r\n        end\n        if heap[i][3] > heap[l][3] then\n          heap[i], heap[l] = heap[l], heap[i]\n          i = l\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local ret = {}\n  for i = 1, #heap do\n    ret[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return ret\nend",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local function heapify(arr, i, size)\n    local l = 2 * i\n    local r = 2 * i + 1\n    local largest = i\n    if l <= size and compare(arr[l], arr[largest]) then\n      largest = l\n    end\n    if r <= size and compare(arr[r], arr[largest]) then\n      largest = r\n    end\n    if largest ~= i then\n      arr[i], arr[largest] = arr[largest], arr[i]\n      heapify(arr, largest, size)\n    end\n  end\n  local function build_heap(arr)\n    local size = #arr\n    for i = math.floor(size / 2), 1, -1 do\n      heapify(arr, i, size)\n    end\n  end\n  local function heap_sort(arr)\n    build_heap(arr)\n    local size = #arr\n    for i = size, 2, -1 do\n      arr[1], arr[i] = arr[i], arr[1]\n      size = size - 1\n      heapify(arr, 1, size)\n    end\n  end\n  local function insert(arr, val)\n    arr[#arr + 1] = val\n    heap_sort(arr)\n  end\n  local function pop(arr)\n    local val = arr[1]\n    arr[1] = arr[#arr]\n    arr[#arr] = nil\n    heapify(arr, 1, #arr)\n    return val\n  end\n  local function top(arr)\n    return arr[1]\n  end\n  local function empty(arr)\n    return #arr == 0\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      if #heap < k then\n        insert(heap, {nums1[i], nums2[j]})\n      elseif nums1[i] + nums2[j] < top(heap)[1]",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(x, y)\n        local key = nums1[x] + nums2[y]\n        if #heap < k then\n            heap[#heap + 1] = {x, y, key}\n            local i = #heap\n            while i > 1 do\n                local j = math.floor(i / 2)\n                if heap[j][3] > heap[i][3] then\n                    heap[j], heap[i] = heap[i], heap[j]\n                    i = j\n                else\n                    break\n                end\n            end\n        elseif key < heap[1][3] then\n            heap[1] = {x, y, key}\n            local i = 1\n            while i * 2 <= #heap do\n                local j = i * 2\n                if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n                    j = j + 1\n                end\n                if heap[i][3] > heap[j][3] then\n                    heap[i], heap[j] = heap[j], heap[i]\n                    i = j\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local result = {}\n    for i = 1, #heap do\n        result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return result\nend",
    "  local len1, len2 = #nums1, #nums2\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {sum, i, j}\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][1] > heap[i][1] then\n          heap[parent], heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][1] then\n      heap[1] = {sum, i, j}\n      local i = 1\n      while i * 2 <= #heap do\n        local left, right = i * 2, i * 2 + 1\n        if right <= #heap and heap[right][1] < heap[left][1] then\n          if heap[right][1] < heap[i][1] then\n            heap[right], heap[i] = heap[i], heap[right]\n            i = right\n          else\n            break\n          end\n        else\n          if heap[left][1] < heap[i][1] then\n            heap[left], heap[i] = heap[i], heap[left]\n            i = left\n          else\n            break\n          end\n        end\n      end\n    end\n  end\n  for i = 1, math.min(len1, k) do\n    push(i, 1)\n  end\n  local res = {}\n  while #heap > 0 do\n    local sum, i, j = table.unpack(table.remove(heap, 1))\n    res[#res + 1] = {nums1[i], nums2[j]}\n    if j < len2 then\n      push(i, j + 1)\n    end\n  end\n  return res\nend",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local res = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(res, nums1[i])\n                i = i + 1\n            else\n                table.insert(res, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(res, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(res, nums2[j])\n            j = j + 1\n        end\n        return res\n    end",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[i][1] + heap[i][2] >= heap[p][1] + heap[p][2] then\n                break\n            end\n            heap[i], heap[p] = heap[p], heap[i]\n            i = p\n        end\n    end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      table.sort(heap, function(a, b) return a[3] < b[3] end)\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      table.sort(heap, function(a, b) return a[3] < b[3] end)\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n  end\n  return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        local val = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap + 1] = {val, i, j}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][1] > heap[i][1] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif val < heap[1][1] then\n            heap[1] = {val, i, j}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                local min_i = l\n                if r <= #heap and heap[l][1] > heap[r][1] then\n                    min_i = r\n                end\n                if heap[i][1] > heap[min_i][1] then\n                    heap[i], heap[min_i] = heap[min_i], heap[i]\n                    i = min_i\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local ret = {}\n    for i = 1, #heap do\n        ret[i] = {nums1[heap[i][2]], nums2[heap[i][3]]}\n    end\n    return ret\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[1] < b[1] end)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local pair = table.remove(heap, 1)\n    result[#result + 1] = {nums1[pair[2]], nums2[pair[3]]}\n    push(pair[2], pair[3] + 1)\n    push(pair[2] + 1, pair[3])\n    k = k - 1\n  end\n  return result\nend",
    "    local function heap_pop(heap)\n        local ret = heap[1]\n        local last = table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local l = i * 2\n            local r = i * 2 + 1\n            if r <= #heap and heap[r][1] < heap[l][1] then\n                l = r\n            end\n            if last[1] <= heap[l][1] then\n                break\n            end\n            heap[i] = heap[l]\n            i = l\n        end\n        heap[i] = last\n        return ret\n    end",
    "    local function merge(nums1, nums2)\n        local res = {}\n        local i, j = 1, 1\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(res, nums1[i])\n                i = i + 1\n            else\n                table.insert(res, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(res, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(res, nums2[j])\n            j = j + 1\n        end\n        return res\n    end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local j = math.floor(i / 2)\n        if heap[j][3] > heap[i][3] then\n          heap[j], heap[i] = heap[i], heap[j]\n          i = j\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n          j = j + 1\n        end\n        if heap[i][3] > heap[j][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return result\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local function cmp(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local heap = {}\n    for i = 1, len1 do\n        for j = 1, len2 do\n            table.insert(heap, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(heap, cmp)\n    local res = {}\n    for i = 1, k do\n        if heap[i] then\n            table.insert(res, heap[i])\n        end\n    end\n    return res\nend",
    "  local function heap_pop(heap)\n    local last = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while true do\n      local left = i * 2\n      local right = i * 2 + 1\n      if left > #heap then\n        break\n      elseif right > #heap then\n        if heap[left][1] < last[1] then\n          heap[i] = heap[left]\n          heap[left] = last\n          i = left\n        end\n        break\n      else\n        if heap[left][1] < heap[right][1] then\n          if heap[left][1] < last[1] then\n            heap[i] = heap[left]\n            heap[left] = last\n            i = left\n          else\n            break\n          end\n        else\n          if heap[right][1] < last[1] then\n            heap[i] = heap[right]\n            heap[right] = last\n            i = right\n          else\n            break\n          end\n        end\n      end\n    end\n    return last\n  end",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heapinsert(heap, {nums1[i] + nums2[j], i, j})\n        end\n    end\n    push(1, 1)\n    local res = {}\n    while #res < k and #heap > 0 do\n        local val, i, j = table.unpack(heapremove(heap))\n        table.insert(res, {nums1[i], nums2[j]})\n        push(i, j + 1)\n        if j == 1 then\n            push(i + 1, 1)\n        end\n    end\n    return res\nend",
    "    local function cmp(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, cmp)\n    local ret = {}\n    for i = 1, k do\n        table.insert(ret, res[i])\n    end\n    return ret\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    push(1, 1)\n    table.sort(heap, function(a, b) return a[1] < b[1] end)\n    local result = {}\n    while k > 0 and #heap > 0 do\n        local pair = table.remove(heap, 1)\n        result[#result + 1] = {nums1[pair[2]], nums2[pair[3]]}\n        push(pair[2], pair[3] + 1)\n        push(pair[2] + 1, pair[3])\n        k = k - 1\n    end\n    return result\nend",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i][1] + heap[i][2] >= heap[j][1] + heap[j][2] then\n        break\n      end\n      heap[i], heap[j] = heap[j], heap[i]\n      i = j\n    end\n  end",
    "  local function merge(nums1, nums2)\n    local i, j = 1, 1\n    local res = {}\n    while i <= #nums1 and j <= #nums2 do\n      if nums1[i] < nums2[j] then\n        table.insert(res, nums1[i])\n        i = i + 1\n      else\n        table.insert(res, nums2[j])\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      table.insert(res, nums1[i])\n      i = i + 1\n    end\n    while j <= #nums2 do\n      table.insert(res, nums2[j])\n      j = j + 1\n    end\n    return res\n  end",
    "    local function compare(a, b)\n        return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and compare(heap[j + 1], heap[j]) then\n                j = j + 1\n            end\n            if compare(heap[i], heap[j]) then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n        return ret\n    end\n    local function heap_push(heap, val)\n        heap[#heap + 1] = val\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if compare(heap[j], heap[i]) then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            if #heap < k then\n                heap_push(heap, {nums1[i] + nums2[j], nums1[i], nums2[j]})\n            elseif nums1[i] + nums2[j] < heap[1][1] then\n                heap_pop(heap)\n                heap_push(heap, {nums1[i] + nums2[j], nums1[i], nums2[j]})\n            else\n                break\n            end\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        local val = heap_pop(heap)\n        ret[#ret + 1] = {val[2], val[",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[1] < b[1] end)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local top = table.remove(heap, 1)\n    result[#result + 1] = {nums1[top[2]], nums2[top[3]]}\n    push(top[2], top[3] + 1)\n    if top[3] == 1 then\n      push(top[2] + 1, 1)\n    end\n    k = k - 1\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > sum then\n          heap[i], heap[p] = heap[p], heap[i]\n          i = p\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while true do\n        local l = i * 2\n        local r = l + 1\n        if l > #heap then\n          break\n        elseif r > #heap then\n          if heap[l][3] < heap[i][3] then\n            heap[i], heap[l] = heap[l], heap[i]\n          end\n          break\n        elseif heap[l][3] < heap[r][3] then\n          if heap[l][3] < heap[i][3] then\n            heap[i], heap[l] = heap[l], heap[i]\n            i = l\n          else\n            break\n          end\n        else\n          if heap[r][3] < heap[i][3] then\n            heap[i], heap[r] = heap[r], heap[i]\n            i = r\n          else\n            break\n          end\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local function add_pairs(nums1, nums2, k, pairs)\n        for i = 1, #nums1 do\n            for j = 1, #nums2 do\n                table.insert(pairs, {nums1[i], nums2[j]})\n                if #pairs > k then\n                    table.remove(pairs, 1)\n                end\n            end\n        end\n    end\n    local pairs = {}\n    add_pairs(nums1, nums2, k, pairs)\n    table.sort(pairs, compare)\n    return pairs\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local parent = math.floor(i / 2)\n                if heap[parent][3] > sum then\n                    heap[i], heap[parent] = heap[parent], heap[i]\n                    i = parent\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local left = i * 2\n                local right = i * 2 + 1\n                local min_child\n                if right <= #heap then\n                    min_child = heap[left][3] < heap[right][3] and left or right\n                else\n                    min_child = left\n                end\n                if heap[min_child][3] < heap[i][3] then\n                    heap[i], heap[min_child] = heap[min_child], heap[i]\n                    i = min_child\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local result = {}\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        local pair = table.remove(heap, 1)\n        table.insert(result, {nums1[pair[1]], nums2[pair[2]]})\n        if pair[2] < len2 then\n            push(pair[1], pair[2] + 1)\n        end\n    end\n    return result\nend",
    "    local function heap_pop(heap)\n        local n = #heap\n        local ret = heap[1]\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while true do\n            local j = i * 2\n            if j > n then\n                break\n            end\n            if j + 1 <= n and heap[j + 1][1] < heap[j][1] then\n                j = j + 1\n            end\n            if heap[j][1] < heap[i][1] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local function heap_push(heap, val)\n        local n = #heap\n        heap[n + 1] = val\n        local i = n + 1\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] > heap[i][1] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i] + nums2[j], i, j})\n        end\n    end\n    local ret = {}\n    for i = 1, k do\n        local val = heap_pop(heap)\n        if val then\n            table.insert(ret, {nums1[val[2]], nums2[val[3]]})\n        end\n    end\n    return ret\nend",
    "  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      local sum = nums1[i] + nums2[j]\n      if #heap < k then\n        table.insert(heap, {sum, {nums1[i], nums2[j]}})\n      else\n        if sum < heap[1][1] then\n          heap[1] = {sum, {nums1[i], nums2[j]}}\n        end\n      end\n      heap_sort(heap, 1, #heap)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    table.insert(result, heap[i][2])\n  end\n  return result\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push_heap(heap, val)\n        heap[#heap + 1] = val\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i][1] < heap[parent][1] then\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function pop_heap(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local min_idx = left\n            if right <= #heap and heap[right][1] < heap[left][1] then\n                min_idx = right\n            end\n            if heap[min_idx][1] < heap[i][1] then\n                heap[i], heap[min_idx] = heap[min_idx], heap[i]\n                i = min_idx\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, math.min(len1, k) do\n        push_heap(heap, {nums1[i] + nums2[1], i, 1})\n    end\n    local ret = {}\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        local val, idx1, idx2 = table.unpack(pop_heap(heap))\n        ret[i] = {nums1[idx1], nums2[idx2]}\n        if idx2 < len2 then\n            push_heap(heap, {nums1[idx1] + nums2[",
    "    local result = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(result, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(result, function(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end)\n    return result\nend",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][1] + heap[p][2] > heap[i][1] + heap[i][2] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end",
    "    local result = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    local i = 1\n    local j = 1\n    while i <= len1 and j <= len2 and #result < k do\n        if nums1[i] < nums2[j] then\n            table.insert(result, {nums1[i], nums2[j]})\n            i = i + 1\n        else\n            table.insert(result, {nums1[i], nums2[j]})\n            j = j + 1\n        end\n    end\n    return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n            local i = #heap\n            while i > 1 do\n                local j = math.floor(i / 2)\n                if heap[j][1] > heap[i][1] then\n                    heap[j], heap[i] = heap[i], heap[j]\n                    i = j\n                else\n                    break\n                end\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n                j = j + 1\n            end\n            if heap[i][1] > heap[j][1] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    local ret = {}\n    for i = 1, k do\n        local v = pop()\n        if v then\n            ret[#ret + 1] = {v[2], v[3]}\n            push(v[2], v[3] + 1)\n        end\n    end\n    return ret\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "    local result = {}\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    for _, v in ipairs(heap) do\n        table.insert(result, {nums1[v[1]], nums2[v[2]]})\n    end\n    return result\nend",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local function merge(nums1, nums2)\n    local res = {}\n    local i, j = 1, 1\n    while i <= #nums1 and j <= #nums2 do\n      if nums1[i] < nums2[j] then\n        res[#res + 1] = nums1[i]\n        i = i + 1\n      else\n        res[#res + 1] = nums2[j]\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      res[#res + 1] = nums1[i]\n      i = i + 1\n    end\n    while j <= #nums2 do\n      res[#res + 1] = nums2[j]\n      j = j + 1\n    end\n    return res\n  end",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] <= heap[i][3] then\n          break\n        end\n        heap[i], heap[p] = heap[p], heap[i]\n        i = p\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l, r = i * 2, i * 2 + 1\n        local j = l\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          j = r\n        end\n        if heap[i][3] <= heap[j][3] then\n          break\n        end\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local result = {}\n    for i = 1, #heap do\n        table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n    end\n    return result\nend",
    "    local function push(heap, x, y, val)\n        if #heap < k then\n            heap[#heap + 1] = {x, y, val}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > val then\n            heap[1] = {x, y, val}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                local j = l\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    j = r\n                end\n                if heap[i][3] > heap[j][3] then\n                    heap[i], heap[j] = heap[j], heap[i]\n                    i = j\n                else\n                    break\n                end\n            end\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(heap, i, j, nums1[i] + nums2[j])\n        end\n    end\n    local ret = {}\n    for i = 1, #heap do\n        ret[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return ret\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local result = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    for i = 1, len1 do\n        for j = 1, len2 do\n            table.insert(result, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(result, function(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end)\n    local k = k or len1 * len2\n    return table.sub(result, 1, k)\nend",
    "    if #nums1 == 0 or #nums2 == 0 then\n        return {}\n    end",
    "  local heap = {}\n  local function push(x, y)\n    if #heap < k then\n      table.insert(heap, {x, y})\n      local i = #heap\n      while i > 1 do\n        local j = math.floor(i / 2)\n        if nums1[heap[j][1]] + nums2[heap[j][2]] > nums1[x] + nums2[y] then\n          heap[i] = heap[j]\n          i = j\n        else\n          break\n        end\n      end\n      heap[i] = {x, y}\n    else\n      if nums1[heap[1][1]] + nums2[heap[1][2]] > nums1[x] + nums2[y] then\n        heap[1] = {x, y}\n        local i = 1\n        while i * 2 <= #heap do\n          local j = i * 2\n          if j + 1 <= #heap and nums1[heap[j][1]] + nums2[heap[j][2]] > nums1[heap[j + 1][1]] + nums2[heap[j + 1][2]] then\n            j = j + 1\n          end\n          if nums1[heap[i][1]] + nums2[heap[i][2]] > nums1[heap[j][1]] + nums2[heap[j][2]] then\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n          else\n            break\n          end\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n  end\n  return result\nend",
    "    local result = {}\n    local heap = {}\n    local function push_heap(heap, item)\n        heap[#heap + 1] = item\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function pop_heap(heap)\n        local result = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local child = i * 2\n            if child + 1 <= #heap and heap[child + 1][1] + heap[child + 1][2] < heap[child][1] + heap[child][2] then\n                child = child + 1\n            end\n            if heap[i][1] + heap[i][2] > heap[child][1] + heap[child][2] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return result\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push_heap(heap, {nums1[i], nums2[j]})\n        end\n    end\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        result[i] = pop_heap(heap)\n    end\n    return result\nend",
    "    local result = {}\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    l = r\n                end\n                if heap[i][3] > heap[l][3] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    for i = 1, #heap do\n        table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n    end\n    return result\nend",
    "    local function heap_pop(heap)\n        local n = #heap\n        if n == 0 then return end\n        local ret = heap[1]\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = l + 1\n            if l > n then break end\n            if r > n then\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                end\n                break\n            end\n            if heap[l][1] < heap[r][1] then\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            else\n                if heap[i][1] > heap[r][1] then\n                    heap[i], heap[r] = heap[r], heap[i]\n                    i = r\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end\n    local function heap_push(heap, v)\n        local n = #heap\n        heap[n + 1] = v\n        local i = n + 1\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] > heap[i][1] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local ret = {}\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n        end\n    end\n    for i = 1, k do\n        local v = heap_pop(heap)\n        if v then\n            ret[i] = v[2]\n        else",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {sum, i, j})\n            table.sort(heap, function(a, b) return a[1] < b[1] end)\n        elseif sum < heap[1][1] then\n            heap[1] = {sum, i, j}\n            table.sort(heap, function(a, b) return a[1] < b[1] end)\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        table.insert(res, {nums1[heap[i][2]], nums2[heap[i][3]]})\n    end\n    return res\nend",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] + heap[j][2] > heap[i][1] + heap[i][2] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[1] < b[1] end)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local pair = table.remove(heap, 1)\n    result[#result + 1] = {nums1[pair[2]], nums2[pair[3]]}\n    push(pair[2], pair[3] + 1)\n    push(pair[2] + 1, pair[3])\n    k = k - 1\n  end\n  return result\nend",
    "  local function sort_pairs(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, sort_pairs)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local result = {}\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][3] > heap[i][3] then\n          heap[parent], heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif heap[1][3] > sum then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local left = i * 2\n        local right = i * 2 + 1\n        local min = left\n        if right <= #heap and heap[right][3] < heap[left][3] then\n          min = right\n        end\n        if heap[i][3] > heap[min][3] then\n          heap[i], heap[min] = heap[min], heap[i]\n          i = min\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return result\nend",
    "    local function heap_insert(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] + heap[j][2] > heap[i][1] + heap[i][2] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local res = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(res, nums1[i])\n                i = i + 1\n            else\n                table.insert(res, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(res, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(res, nums2[j])\n            j = j + 1\n        end\n        return res\n    end\n    local function merge_sort(nums)\n        if #nums <= 1 then return nums end\n        local mid = math.floor(#nums / 2)\n        local left = merge_sort(nums, 1, mid)\n        local right = merge_sort(nums, mid + 1, #nums)\n        return merge(left, right)\n    end\n    local function find_k_smallest_pairs(nums1, nums2, k)\n        local res = {}\n        local i, j = 1, 1\n        while i <= #nums1 and j <= #nums2 and k > 0 do\n            if nums1[i] < nums2[j] then\n                table.insert(res, {nums1[i], nums2[j]})\n                i = i + 1\n            else\n                table.insert(res, {nums1[i], nums2[j]})\n                j = j + 1\n            end\n            k = k - 1\n        end\n        while i <= #nums1 and k > 0 do\n            table.insert(res, {nums1[i], nums2[j]})\n            i = i + 1\n            k = k - 1\n        end\n        while j <= #nums2 and k > 0 do\n            table.insert(res, {nums1[i], num",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local res = {}\n  for i = 1, k do\n    table.insert(res, pairs[i])\n  end\n  return res\nend",
    "  local function heap_pop(heap)\n    local ret = heap[1]\n    local last = table.remove(heap)\n    if #heap > 0 then\n      heap[1] = last\n      local i = 1\n      while true do\n        local left = i * 2\n        local right = left + 1\n        if left > #heap then\n          break\n        end\n        local j = left\n        if right <= #heap and heap[right][1] < heap[left][1] then\n          j = right\n        end\n        if heap[i][1] > heap[j][1] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n    return ret\n  end\n  local function heap_push(heap, item)\n    table.insert(heap, item)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[j][1] > heap[i][1] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n    end\n  end\n  local ret = {}\n  for i = 1, k do\n    if #heap == 0 then\n      break\n    end\n    table.insert(ret, heap_pop(heap)[2])\n  end\n  return ret\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "  local function heap_push(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i][1] < heap[parent][1] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        table.insert(heap, {sum, i, j})\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent][1] > heap[i][1] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            local min = left\n            if right <= #heap and heap[right][1] < heap[left][1] then\n                min = right\n            end\n            if heap[i][1] > heap[min][1] then\n                heap[i], heap[min] = heap[min], heap[i]\n                i = min\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, len1 do\n        push(i, 1)\n    end\n    local ret = {}\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        local sum, x, y = table.unpack(pop())\n        table.insert(ret, {nums1[x], nums2[y]})\n        if y < len2 then\n            push(x, y + 1)\n        end\n    end\n    return ret\nend",
    "    local function merge(a, b)\n        local c = {}\n        local i, j = 1, 1\n        while i <= #a and j <= #b do\n            if a[i] < b[j] then\n                table.insert(c, a[i])\n                i = i + 1\n            else\n                table.insert(c, b[j])\n                j = j + 1\n            end\n        end\n        while i <= #a do\n            table.insert(c, a[i])\n            i = i + 1\n        end\n        while j <= #b do\n            table.insert(c, b[j])\n            j = j + 1\n        end\n        return c\n    end\n    local function merge_sort(a)\n        if #a <= 1 then\n            return a\n        end\n        local mid = math.floor(#a / 2)\n        local left = merge_sort(a:sub(1, mid))\n        local right = merge_sort(a:sub(mid + 1, #a))\n        return merge(left, right)\n    end\n    local function k_smallest_pairs_helper(nums1, nums2, k)\n        local pairs = {}\n        for i = 1, #nums1 do\n            for j = 1, #nums2 do\n                table.insert(pairs, {nums1[i], nums2[j]})\n            end\n        end\n        local sums = {}\n        for i = 1, #pairs do\n            table.insert(sums, pairs[i][1] + pairs[i][2])\n        end\n        sums = merge_sort(sums)\n        local res = {}\n        for i = 1, k do\n            table.insert(res, pairs[i])\n        end\n        return res\n    end\n    return k_smallest_pairs_helper(nums1, nums2, k)\nend",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    return res\nend",
    "    local res = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    for i = 1, len1 do\n        for j = 1, len2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local ret = {}\n    for i = 1, k do\n        table.insert(ret, res[i])\n    end\n    return ret\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end",
    "    local heap = {}\n    local function push(x, y)\n        if #heap < k then\n            heap[#heap + 1] = {x, y}\n            local i = #heap\n            while i > 1 do\n                local j = math.floor(i / 2)\n                if heap[j][1] + heap[j][2] <= heap[i][1] + heap[i][2] then\n                    break\n                end\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            end\n        else\n            if heap[1][1] + heap[1][2] <= x + y then\n                return\n            end\n            heap[1] = {x, y}\n            local i = 1\n            while i * 2 <= #heap do\n                local j = i * 2\n                if j + 1 <= #heap and heap[j + 1][1] + heap[j + 1][2] < heap[j][1] + heap[j][2] then\n                    j = j + 1\n                end\n                if heap[i][1] + heap[i][2] <= heap[j][1] + heap[j][2] then\n                    break\n                end\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(nums1[i], nums2[j])\n        end\n    end\n    return heap\nend",
    "  local result = {}\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    local heap_size = #heap\n    if heap_size < k then\n      heap[heap_size + 1] = {i, j, sum}\n      local i = heap_size + 1\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][3] > heap[i][3] then\n          heap[parent], heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif heap[1][3] > sum then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while true do\n        local left = i * 2\n        local right = i * 2 + 1\n        if left > heap_size then\n          break\n        elseif right > heap_size then\n          if heap[left][3] < heap[i][3] then\n            heap[left], heap[i] = heap[i], heap[left]\n          end\n          break\n        else\n          local min = heap[left][3] < heap[right][3] and left or right\n          if heap[min][3] < heap[i][3] then\n            heap[min], heap[i] = heap[i], heap[min]\n            i = min\n          else\n            break\n          end\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent][1] + heap[parent][2] > heap[i][1] + heap[i][2] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local ret = {}\n    for i = 1, k do\n        table.insert(ret, res[i])\n    end\n    return ret\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[1] < b[1] end)\n  local result = {}\n  while k > 0 and #heap > 0 do\n    local item = table.remove(heap, 1)\n    result[#result + 1] = {nums1[item[2]], nums2[item[3]]}\n    push(item[2], item[3] + 1)\n    push(item[2] + 1, item[3])\n    k = k - 1\n  end\n  return result\nend",
    "  local result = {}\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {sum, i, j}\n      local i = #heap\n      while i > 1 do\n        local parent = math.floor(i / 2)\n        if heap[parent][1] > heap[i][1] then\n          heap[parent], heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][1] then\n      heap[1] = {sum, i, j}\n      local i = 1\n      while true do\n        local left = i * 2\n        local right = left + 1\n        if left <= #heap then\n          if right <= #heap then\n            if heap[left][1] < heap[right][1] then\n              if heap[left][1] < heap[i][1] then\n                heap[left], heap[i] = heap[i], heap[left]\n                i = left\n              else\n                break\n              end\n            else\n              if heap[right][1] < heap[i][1] then\n                heap[right], heap[i] = heap[i], heap[right]\n                i = right\n              else\n                break\n              end\n            end\n          else\n            if heap[left][1] < heap[i][1] then\n              heap[left], heap[i] = heap[i], heap[left]\n              i = left\n            else\n              break\n            end\n          end\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][2]], nums2[heap[i][3]]}\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "  local function heap_pop(heap)\n    local ret = heap[1]\n    local last = table.remove(heap)\n    if #heap > 0 then\n      heap[1] = last\n      local i = 1\n      while true do\n        local l = i * 2\n        local r = i * 2 + 1\n        if l > #heap then\n          break\n        elseif r > #heap then\n          if heap[i][1] > heap[l][1] then\n            heap[i], heap[l] = heap[l], heap[i]\n          end\n          break\n        else\n          if heap[l][1] < heap[r][1] then\n            if heap[i][1] > heap[l][1] then\n              heap[i], heap[l] = heap[l], heap[i]\n              i = l\n            else\n              break\n            end\n          else\n            if heap[i][1] > heap[r][1] then\n              heap[i], heap[r] = heap[r], heap[i]\n              i = r\n            else\n              break\n            end\n          end\n        end\n      end\n    end\n    return ret\n  end",
    "    local function heap_pop(heap)\n        local n = #heap\n        if n == 0 then return nil end\n        local ret = heap[1]\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = l + 1\n            if l > n then break end\n            if r > n then\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                end\n                break\n            end\n            if heap[l][1] < heap[r][1] then\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            else\n                if heap[i][1] > heap[r][1] then\n                    heap[i], heap[r] = heap[r], heap[i]\n                    i = r\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end",
    "    local heap = {}\n    local function push(x, y)\n        local key = nums1[x] + nums2[y]\n        if #heap < k then\n            heap[#heap + 1] = {x, y, key}\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > key then\n            heap[1] = {x, y, key}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                local m = l\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    m = r\n                end\n                if heap[i][3] > heap[m][3] then\n                    heap[i], heap[m] = heap[m], heap[i]\n                    i = m\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local result = {}\n    for i = 1, #heap do\n        result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n    end\n    return result\nend",
    "  local function merge(nums1, nums2)\n    local i, j = 1, 1\n    local result = {}\n    while i <= #nums1 and j <= #nums2 do\n      if nums1[i] < nums2[j] then\n        table.insert(result, nums1[i])\n        i = i + 1\n      else\n        table.insert(result, nums2[j])\n        j = j + 1\n      end\n    end\n    while i <= #nums1 do\n      table.insert(result, nums1[i])\n      i = i + 1\n    end\n    while j <= #nums2 do\n      table.insert(result, nums2[j])\n      j = j + 1\n    end\n    return result\n  end\n  local function find_k_smallest(nums1, nums2, k)\n    if #nums1 == 0 or #nums2 == 0 then\n      return {}\n    end\n    if k == 1 then\n      return {nums1[1] + nums2[1]}\n    end\n    local result = {}\n    local i = 1\n    while i <= #nums1 and i <= k do\n      local sub_result = find_k_smallest(nums2, nums1, k - i + 1)\n      for j = 1, #sub_result do\n        table.insert(result, nums1[i] + sub_result[j])\n      end\n      i = i + 1\n    end\n    return merge(result, find_k_smallest(nums1, nums2, k))\n  end\n  local result = find_k_smallest(nums1, nums2, k)\n  local pairs = {}\n  for i = 1, #result do\n    local pair = {}\n    for j = 1, #nums1 do\n      if result[i] - nums1[j] > 0 and result[i] - nums1[j] <= nums2[#nums2] then\n        table.insert(pair, nums1[j])\n        table.insert(pair, result[i] - num",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        table.insert(heap, {i, j, sum})\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent][3] > heap[i][3] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        table.remove(heap)\n        local i = 1\n        while i < #heap do\n            local left = i * 2\n            local right = i * 2 + 1\n            if left > #heap then\n                break\n            end\n            local min_i = i\n            if heap[left][3] < heap[min_i][3] then\n                min_i = left\n            end\n            if right <= #heap and heap[right][3] < heap[min_i][3] then\n                min_i = right\n            end\n            if min_i ~= i then\n                heap[min_i], heap[i] = heap[i], heap[min_i]\n                i = min_i\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local ret = {}\n    push(1, 1)\n    while #ret < k and #heap > 0 do\n        local i, j, sum = unpack(pop())\n        table.insert(ret, {nums1[i], nums2[j]})\n        if j < len2 then\n            push(i, j + 1)\n        end\n    end\n    return ret\nend",
    "    local result = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    local i = 1\n    local j = 1\n    local count = 0\n    while count < k and i <= len1 and j <= len2 do\n        local sum = nums1[i] + nums2[j]\n        if i < len1 and nums1[i + 1] + nums2[j] < sum then\n            i = i + 1\n        elseif j < len2 and nums1[i] + nums2[j + 1] < sum then\n            j = j + 1\n        else\n            table.insert(result, {nums1[i], nums2[j]})\n            count = count + 1\n            if i < len1 and j < len2 then\n                if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] then\n                    i = i + 1\n                else\n                    j = j + 1\n                end\n            elseif i < len1 then\n                i = i + 1\n            else\n                j = j + 1\n            end\n        end\n    end\n    return result\nend",
    "    local function merge(a, b)\n        local result = {}\n        local i, j = 1, 1\n        while i <= #a and j <= #b do\n            if a[i] < b[j] then\n                table.insert(result, a[i])\n                i = i + 1\n            else\n                table.insert(result, b[j])\n                j = j + 1\n            end\n        end\n        while i <= #a do\n            table.insert(result, a[i])\n            i = i + 1\n        end\n        while j <= #b do\n            table.insert(result, b[j])\n            j = j + 1\n        end\n        return result\n    end",
    "    local heap = {}\n    local function heap_push(heap, val)\n        heap[#heap+1] = val\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i/2)\n            if heap[p][1] + heap[p][2] > heap[i][1] + heap[i][2] then\n                heap[i], heap[p] = heap[p], heap[i]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n            local l = i*2\n            local r = i*2+1\n            if l > #heap then\n                break\n            elseif r > #heap then\n                if heap[i][1] + heap[i][2] > heap[l][1] + heap[l][2] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                end\n                break\n            else\n                local min_i = l\n                if heap[r][1] + heap[r][2] < heap[l][1] + heap[l][2] then\n                    min_i = r\n                end\n                if heap[i][1] + heap[i][2] > heap[min_i][1] + heap[min_i][2] then\n                    heap[i], heap[min_i] = heap[min_i], heap[i]\n                    i = min_i\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end\n    local ret = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i], nums2[j]})\n            if #heap > k then\n                heap_pop(heap)\n            end\n        end\n    end\n    for i = #heap, 1",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    local function pop()\n        if #heap == 0 then\n            return nil\n        end\n        local t = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n                j = j + 1\n            end\n            if heap[i][1] <= heap[j][1] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n        return t[2], t[3]\n    end\n    push(1, 1)\n    local result = {}\n    while k > 0 do\n        local i, j = pop()\n        if i == nil then\n            break\n        end\n        result[#result + 1] = {nums1[i], nums2[j]}\n        push(i, j + 1)\n        if j == 1 then\n            push(i + 1, 1)\n        end\n        k = k - 1\n    end\n    return result\nend",
    "    local function heap_pop(heap)\n        local ret = heap[1]\n        local n = #heap\n        heap[1] = heap[n]\n        heap[n] = nil\n        local i = 1\n        while true do\n            local l, r = i * 2, i * 2 + 1\n            if l > n then break end\n            if r > n then\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                end\n                break\n            end\n            if heap[l][1] < heap[r][1] then\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            else\n                if heap[i][1] > heap[r][1] then\n                    heap[i], heap[r] = heap[r], heap[i]\n                    i = r\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end",
    "    local function heap_pop(heap)\n        local n = #heap\n        if n == 0 then\n            return nil\n        end\n        local ret = heap[1]\n        if n == 1 then\n            heap[1] = nil\n        else\n            heap[1] = heap[n]\n            heap[n] = nil\n            local i = 1\n            while true do\n                local l = i * 2\n                local r = l + 1\n                if l > n then\n                    break\n                end\n                local j = i\n                if heap[l][1] < heap[j][1] then\n                    j = l\n                end\n                if r <= n and heap[r][1] < heap[j][1] then\n                    j = r\n                end\n                if j == i then\n                    break\n                end\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            end\n        end\n        return ret\n    end\n    local function heap_push(heap, x)\n        local n = #heap\n        heap[n + 1] = x\n        local i = n + 1\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] <= heap[i][1] then\n                break\n            end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n        end\n    end\n    local ret = {}\n    for i = 1, k do\n        local x = heap_pop(heap)\n        if not x then\n            break\n        end\n        ret[i] = x[2]\n    end\n    return ret\nend",
    "    local res = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return res\n    end\n    local heap = {}\n    local function push(x, y)\n        local val = nums1[x] + nums2[y]\n        local idx = #heap + 1\n        heap[idx] = {val, x, y}\n        local parent = math.floor(idx / 2)\n        while parent > 0 and heap[parent][1] > val do\n            heap[parent], heap[idx] = heap[idx], heap[parent]\n            idx = parent\n            parent = math.floor(idx / 2)\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local idx = 1\n        while idx * 2 <= #heap do\n            local left = idx * 2\n            local right = left + 1\n            local min_idx = left\n            if right <= #heap and heap[right][1] < heap[left][1] then\n                min_idx = right\n            end\n            if heap[idx][1] <= heap[min_idx][1] then\n                break\n            end\n            heap[idx], heap[min_idx] = heap[min_idx], heap[idx]\n            idx = min_idx\n        end\n        return ret\n    end\n    push(1, 1)\n    while k > 0 and #heap > 0 do\n        local val, x, y = unpack(pop())\n        table.insert(res, {nums1[x], nums2[y]})\n        k = k - 1\n        if y < len2 then\n            push(x, y + 1)\n        end\n        if y == 1 and x < len1 then\n            push(x + 1, 1)\n        end\n    end\n    return res\nend",
    "  local function merge(nums1, nums2)\n    local i, j, m, n = 1, 1, #nums1, #nums2\n    local res = {}\n    while i <= m and j <= n do\n      if nums1[i] < nums2[j] then\n        table.insert(res, {nums1[i], nums2[j]})\n        i = i + 1\n      else\n        table.insert(res, {nums1[i], nums2[j]})\n        j = j + 1\n      end\n    end\n    while i <= m do\n      table.insert(res, {nums1[i], nums2[j]})\n      i = i + 1\n    end\n    while j <= n do\n      table.insert(res, {nums1[i], nums2[j]})\n      j = j + 1\n    end\n    return res\n  end\n  local res = merge(nums1, nums2)\n  local function partition(arr, l, r)\n    local pivot = arr[r][1] + arr[r][2]\n    local i = l - 1\n    for j = l, r - 1 do\n      if arr[j][1] + arr[j][2] < pivot then\n        i = i + 1\n        arr[i], arr[j] = arr[j], arr[i]\n      end\n    end\n    arr[i + 1], arr[r] = arr[r], arr[i + 1]\n    return i + 1\n  end\n  local function quick_select(arr, l, r, k)\n    if l == r then return end\n    local p = partition(arr, l, r)\n    if p == k then return end\n    if p > k then\n      quick_select(arr, l, p - 1, k)\n    else\n      quick_select(arr, p + 1, r, k)\n    end\n  end\n  quick_select(res, 1, #res, k)\n  return res\nend",
    "    local pairs = {}\n    for i, v1 in ipairs(nums1) do\n        for j, v2 in ipairs(nums2) do\n            table.insert(pairs, {v1, v2})\n        end\n    end\n    table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local result = {}\n    for i = 1, k do\n        result[i] = pairs[i]\n    end\n    return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local result = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    local i = 1\n    local j = 1\n    while i <= len1 and j <= len2 and #result < k do\n        if nums1[i] < nums2[j] then\n            table.insert(result, {nums1[i], nums2[j]})\n            i = i + 1\n        else\n            table.insert(result, {nums1[i], nums2[j]})\n            j = j + 1\n        end\n    end\n    return result\nend",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[i][1] + heap[i][2] >= heap[parent][1] + heap[parent][2] then\n                break\n            end\n            heap[i], heap[parent] = heap[parent], heap[i]\n            i = parent\n        end\n    end",
    "    local result = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    local i = 1\n    local j = 1\n    local count = 0\n    while count < k and i <= len1 and j <= len2 do\n        local sum = nums1[i] + nums2[j]\n        if i == len1 then\n            while count < k and j <= len2 do\n                table.insert(result, {nums1[i], nums2[j]})\n                count = count + 1\n                j = j + 1\n            end\n        elseif j == len2 then\n            while count < k and i <= len1 do\n                table.insert(result, {nums1[i], nums2[j]})\n                count = count + 1\n                i = i + 1\n            end\n        else\n            if sum < nums1[i + 1] + nums2[j] then\n                table.insert(result, {nums1[i], nums2[j]})\n                count = count + 1\n                j = j + 1\n            else\n                table.insert(result, {nums1[i], nums2[j]})\n                count = count + 1\n                i = i + 1\n            end\n        end\n    end\n    return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "  local function compare(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(heap, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(heap, compare)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, heap[i])\n  end\n  return result\nend",
    "    local function heap_pop(heap)\n        local n = #heap\n        if n == 0 then return nil end\n        local ret = heap[1]\n        heap[1] = heap[n]\n        heap[n] = nil\n        n = n - 1\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = i * 2 + 1\n            if l > n then break end\n            if r <= n then\n                if heap[l][1] < heap[r][1] then\n                    if heap[i][1] > heap[l][1] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                        i = l\n                    else\n                        break\n                    end\n                else\n                    if heap[i][1] > heap[r][1] then\n                        heap[i], heap[r] = heap[r], heap[i]\n                        i = r\n                    else\n                        break\n                    end\n                end\n            else\n                if heap[i][1] > heap[l][1] then\n                    heap[i], heap[l] = heap[l], heap[i]\n                    i = l\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end\n    local function heap_push(heap, val)\n        local n = #heap + 1\n        heap[n] = val\n        local i = n\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] > heap[i][1] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local ret = {}\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n        end\n    end\n    for i = 1, k do\n        local val = heap_pop(heap)",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        local last = heap[#heap]\n        heap[1] = last\n        heap[#heap] = nil\n        local i, j = 1, 1\n        while true do\n            local left = 2 * i\n            local right = left + 1\n            if left > #heap then\n                break\n            end\n            if right <= #heap and heap[right][1] < heap[left][1] then\n                left = right\n            end\n            if heap[i][1] <= heap[left][1] then\n                break\n            end\n            heap[i], heap[left] = heap[left], heap[i]\n            i = left\n        end\n        return ret\n    end\n    local function top()\n        return heap[1]\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    local ret = {}\n    for i = 1, k do\n        local t = top()\n        if not t then\n            break\n        end\n        ret[#ret + 1] = {t[2], t[3]}\n        push(t[2], t[3] + 1)\n        pop()\n    end\n    return ret\nend",
    "  local heap = {}\n  local function push(i, j)\n    if i <= #nums1 and j <= #nums2 then\n      heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n    end\n  end\n  push(1, 1)\n  table.sort(heap, function(a, b) return a[1] < b[1] end)\n  local result = {}\n  for i = 1, k do\n    local pair = table.remove(heap, 1)\n    if not pair then break end\n    result[i] = {nums1[pair[2]], nums2[pair[3]]}\n    push(pair[2], pair[3] + 1)\n    push(pair[2] + 1, pair[3])\n  end\n  return result\nend",
    "    local function merge(nums1, nums2)\n        local result = {}\n        local i, j = 1, 1\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(result, nums1[i])\n                i = i + 1\n            else\n                table.insert(result, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(result, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(result, nums2[j])\n            j = j + 1\n        end\n        return result\n    end",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap[#heap + 1] = {nums1[i] + nums2[j], i, j}\n            local i = #heap\n            while i > 1 do\n                local parent = math.floor(i / 2)\n                if heap[parent][1] > heap[i][1] then\n                    heap[parent], heap[i] = heap[i], heap[parent]\n                    i = parent\n                else\n                    break\n                end\n            end\n        end\n    end\n    local function pop()\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local child = i * 2\n            if child + 1 <= #heap and heap[child + 1][1] < heap[child][1] then\n                child = child + 1\n            end\n            if heap[i][1] > heap[child][1] then\n                heap[i], heap[child] = heap[child], heap[i]\n                i = child\n            else\n                break\n            end\n        end\n        return ret\n    end\n    for i = 1, #nums1 do\n        push(i, 1)\n    end\n    local ret = {}\n    for i = 1, k do\n        local pair = pop()\n        if not pair then\n            break\n        end\n        ret[#ret + 1] = {nums1[pair[2]], nums2[pair[3]]}\n        push(pair[2], pair[3] + 1)\n    end\n    return ret\nend",
    "  local res = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  if len1 == 0 or len2 == 0 then\n    return res\n  end\n  local function add_pair(i, j)\n    local sum = nums1[i] + nums2[j]\n    local len = #res\n    if len < k then\n      table.insert(res, {nums1[i], nums2[j]})\n      if len == k - 1 then\n        table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n      end\n    elseif sum < res[len][1] + res[len][2] then\n      res[len] = {nums1[i], nums2[j]}\n      table.sort(res, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    end\n  end\n  local i = 1\n  local j = 1\n  while i <= len1 and j <= len2 do\n    if nums1[i] < nums2[j] then\n      add_pair(i, j)\n      i = i + 1\n    else\n      add_pair(i, j)\n      j = j + 1\n    end\n  end\n  while i <= len1 do\n    add_pair(i, j)\n    i = i + 1\n  end\n  while j <= len2 do\n    add_pair(i, j)\n    j = j + 1\n  end\n  return res\nend",
    "    local res = {}\n    local len1 = #nums1\n    local len2 = #nums2\n    local i, j = 1, 1\n    while #res < k and i <= len1 and j <= len2 do\n        if nums1[i] <= nums2[j] then\n            table.insert(res, {nums1[i], nums2[j]})\n            i = i + 1\n        else\n            table.insert(res, {nums1[i], nums2[j]})\n            j = j + 1\n        end\n    end\n    while #res < k and i <= len1 do\n        table.insert(res, {nums1[i], nums2[j]})\n        i = i + 1\n    end\n    while #res < k and j <= len2 do\n        table.insert(res, {nums1[i], nums2[j]})\n        j = j + 1\n    end\n    return res\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(x, y)\n        local sum = nums1[x] + nums2[y]\n        if #heap < k then\n            table.insert(heap, {x, y, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > sum then\n            heap[1] = {x, y, sum}\n            local i = 1\n            while i * 2 <= k do\n                local l = i * 2\n                local r = i * 2 + 1\n                local j = l\n                if r <= k and heap[r][3] < heap[l][3] then\n                    j = r\n                end\n                if heap[i][3] > heap[j][3] then\n                    heap[i], heap[j] = heap[j], heap[i]\n                    i = j\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local result = {}\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        local x, y, sum = unpack(table.remove(heap, 1))\n        table.insert(result, {nums1[x], nums2[y]})\n        if y < len2 then\n            push(x, y + 1)\n        end\n    end\n    return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i > #nums1 or j > #nums2 then return end\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > sum then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                local j = l\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    j = r\n                end\n                if heap[i][3] > heap[j][3] then\n                    heap[i], heap[j] = heap[j], heap[i]\n                    i = j\n                else\n                    break\n                end\n            end\n        end\n    end\n    push(1, 1)\n    local result = {}\n    while #heap > 0 do\n        local i, j, sum = table.unpack(table.remove(heap, 1))\n        table.insert(result, {nums1[i], nums2[j]})\n        push(i, j + 1)\n        if j == 1 then\n            push(i + 1, 1)\n        end\n    end\n    return result\nend",
    "    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            local val = nums1[i] + nums2[j]\n            table.insert(heap, {i, j, val})\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n            if #heap > k then\n                table.remove(heap)\n            end\n        end\n    end\n    push(1, 1)\n    local res = {}\n    for _, v in ipairs(heap) do\n        table.insert(res, {nums1[v[1]], nums2[v[2]]})\n    end\n    return res\nend",
    "  local function heap_pop(heap)\n    local last = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i < #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1][1] < heap[j][1] then\n        j = j + 1\n      end\n      if last[1] <= heap[j][1] then\n        break\n      end\n      heap[i] = heap[j]\n      i = j\n    end\n    heap[i] = last\n    return last\n  end",
    "    local function merge(a, b)\n        local res = {}\n        local i, j = 1, 1\n        while i <= #a and j <= #b do\n            if a[i][1] + a[i][2] < b[j][1] + b[j][2] then\n                res[#res + 1] = a[i]\n                i = i + 1\n            else\n                res[#res + 1] = b[j]\n                j = j + 1\n            end\n        end\n        while i <= #a do\n            res[#res + 1] = a[i]\n            i = i + 1\n        end\n        while j <= #b do\n            res[#res + 1] = b[j]\n            j = j + 1\n        end\n        return res\n    end\n    local function merge_sort(a)\n        if #a <= 1 then return a end\n        local mid = math.floor(#a / 2)\n        local left = merge_sort(a, 1, mid)\n        local right = merge_sort(a, mid + 1, #a)\n        return merge(left, right)\n    end\n    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            res[#res + 1] = {nums1[i], nums2[j]}\n        end\n    end\n    res = merge_sort(res)\n    local ret = {}\n    for i = 1, k do\n        ret[#ret + 1] = res[i]\n    end\n    return ret\nend",
    "    local result = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(result, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(result, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    return result\nend",
    "  local result = {}\n  local len1 = #nums1\n  local len2 = #nums2\n  local i = 1\n  local j = 1\n  while i <= len1 and j <= len2 and #result < k do\n    if nums1[i] < nums2[j] then\n      table.insert(result, {nums1[i], nums2[j]})\n      i = i + 1\n    else\n      table.insert(result, {nums1[i], nums2[j]})\n      j = j + 1\n    end\n  end\n  return result\nend",
    "  local res = {}\n  local function insert(n1, n2)\n    local i = 1\n    while i <= #res and (res[i][1] + res[i][2]) <= (n1 + n2) do\n      i = i + 1\n    end\n    table.insert(res, i, {n1, n2})\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      insert(nums1[i], nums2[j])\n      if #res > k then\n        table.remove(res)\n      end\n    end\n  end\n  return res\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local heap = Heap.new(k)\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap:insert({nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n        end\n    end\n    local result = {}\n    for i = 1, k do\n        local item = heap:pop()\n        if item then\n            result[i] = item[2]\n        end\n    end\n    return result\nend",
    "  local function heap_pop(heap)\n    local n = #heap\n    local ret = heap[1]\n    heap[1] = heap[n]\n    heap[n] = nil\n    local i = 1\n    while i < n do\n      local l = i * 2\n      local r = i * 2 + 1\n      if heap[l] and heap[r] then\n        if heap[l][1] < heap[r][1] then\n          heap[i] = heap[l]\n          heap[l] = heap[n]\n          i = l\n        else\n          heap[i] = heap[r]\n          heap[r] = heap[n]\n          i = r\n        end\n      elseif heap[l] then\n        heap[i] = heap[l]\n        heap[l] = heap[n]\n        i = l\n      elseif heap[r] then\n        heap[i] = heap[r]\n        heap[r] = heap[n]\n        i = r\n      else\n        break\n      end\n    end\n    return ret\n  end\n  local function heap_push(heap, val)\n    local n = #heap + 1\n    heap[n] = val\n    local i = n\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[i][1] < heap[p][1] then\n        heap[i], heap[p] = heap[p], heap[i]\n        i = p\n      else\n        break\n      end\n    end\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n    end\n  end\n  local ret = {}\n  for i = 1, k do\n    local val = heap_pop(heap)\n    if val then\n      ret[i] = val[2]\n    end\n  end\n  return ret\nend",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            table.sort(heap, function(a, b) return a[3] < b[3] end)\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        table.insert(res, {nums1[heap[i][1]], nums2[heap[i][2]]})\n    end\n    return res\nend",
    "    local len1, len2 = #nums1, #nums2\n    if len1 == 0 or len2 == 0 then return {} end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif heap[1][3] > sum then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= k do\n                local l, r = i * 2, i * 2 + 1\n                local min_i = l\n                if r <= k and heap[r][3] < heap[l][3] then\n                    min_i = r\n                end\n                if heap[i][3] > heap[min_i][3] then\n                    heap[i], heap[min_i] = heap[min_i], heap[i]\n                    i = min_i\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local res = {}\n    for i = 1, k do\n        if #heap == 0 then break end\n        local h = table.remove(heap, 1)\n        table.insert(res, {nums1[h[1]], nums2[h[2]]})\n        if h[2] < len2 then\n            push(h[1], h[2] + 1)\n        end\n    end\n    return res\nend",
    "    local function heap_push(heap, val)\n        heap[#heap + 1] = val\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] + heap[j][2] > heap[i][1] + heap[i][2] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n    end\n    local function heap_pop(heap)\n        local ret = heap[1]\n        heap[1] = heap[#heap]\n        heap[#heap] = nil\n        local i = 1\n        while i * 2 <= #heap do\n            local j = i * 2\n            if j + 1 <= #heap and heap[j + 1][1] + heap[j + 1][2] < heap[j][1] + heap[j][2] then\n                j = j + 1\n            end\n            if heap[i][1] + heap[i][2] > heap[j][1] + heap[j][2] then\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            else\n                break\n            end\n        end\n        return ret\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i], nums2[j]})\n            if #heap > k then\n                heap_pop(heap)\n            end\n        end\n    end\n    local ret = {}\n    while #heap > 0 do\n        ret[#ret + 1] = heap_pop(heap)\n    end\n    return ret\nend",
    "    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, function(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end)\n    local result = {}\n    for i = 1, k do\n        table.insert(result, pairs[i])\n    end\n    return result\nend",
    "    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            local sum = nums1[i] + nums2[j]\n            if #res < k then\n                table.insert(res, {nums1[i], nums2[j]})\n            else\n                local max_sum = 0\n                for _, v in ipairs(res) do\n                    max_sum = math.max(max_sum, v[1] + v[2])\n                end\n                if sum < max_sum then\n                    table.remove(res)\n                    table.insert(res, {nums1[i], nums2[j]})\n                end\n            end\n        end\n    end\n    return res\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap + 1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > sum then\n          heap[i], heap[p] = heap[p], heap[i]\n          i = p\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local l = i * 2\n        local r = l + 1\n        if r <= #heap and heap[r][3] < heap[l][3] then\n          l = r\n        end\n        if heap[l][3] < heap[i][3] then\n          heap[i], heap[l] = heap[l], heap[i]\n          i = l\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    result[i] = {nums1[heap[i][1]], nums2[heap[i][2]]}\n  end\n  return result\nend",
    "  local function heap_pop(heap)\n    local n = #heap\n    if n == 0 then return end\n    local ret = heap[1]\n    if n == 1 then\n      heap[1] = nil\n      return ret\n    end\n    heap[1] = heap[n]\n    heap[n] = nil\n    local i = 1\n    while true do\n      local l, r = i * 2, i * 2 + 1\n      if l > n then break end\n      if r > n then\n        if heap[i][1] > heap[l][1] then\n          heap[i], heap[l] = heap[l], heap[i]\n        end\n        break\n      end\n      if heap[l][1] < heap[r][1] then\n        if heap[i][1] > heap[l][1] then\n          heap[i], heap[l] = heap[l], heap[i]\n          i = l\n        else\n          break\n        end\n      else\n        if heap[i][1] > heap[r][1] then\n          heap[i], heap[r] = heap[r], heap[i]\n          i = r\n        else\n          break\n        end\n      end\n    end\n    return ret\n  end\n  local function heap_push(heap, v)\n    local n = #heap + 1\n    heap[n] = v\n    local i = n\n    while i > 1 do\n      local p = math.floor(i / 2)\n      if heap[p][1] > heap[i][1] then\n        heap[p], heap[i] = heap[i], heap[p]\n        i = p\n      else\n        break\n      end\n    end\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n    end\n  end\n  local ret = {}\n  for i = 1, k do\n    local v = heap_pop(heap",
    "    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local parent = math.floor(i / 2)\n            if heap[parent] > heap[i] then\n                heap[parent], heap[i] = heap[i], heap[parent]\n                i = parent\n            else\n                break\n            end\n        end\n    end",
    "    local len1, len2 = #nums1, #nums2\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {sum, i, j})\n            table.sort(heap, function(a, b) return a[1] < b[1] end)\n        elseif sum < heap[1][1] then\n            heap[1] = {sum, i, j}\n            table.sort(heap, function(a, b) return a[1] < b[1] end)\n        end\n    end\n    for i = 1, len1 do\n        for j = 1, len2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        table.insert(res, {nums1[heap[i][2]], nums2[heap[i][3]]})\n    end\n    return res\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > sum then\n                    heap[i], heap[p] = heap[p], heap[i]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                local m = l\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    m = r\n                end\n                if heap[i][3] > heap[m][3] then\n                    heap[i], heap[m] = heap[m], heap[i]\n                    i = m\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local result = {}\n    while #heap > 0 do\n        local i, j, sum = unpack(table.remove(heap, 1))\n        table.insert(result, {nums1[i], nums2[j]})\n        if j < len2 then\n            push(i, j + 1)\n        end\n    end\n    return result\nend",
    "  local function heap_push(heap, val)\n    table.insert(heap, val)\n    local i = #heap\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if heap[i][1] + heap[i][2] < heap[j][1] + heap[j][2] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n  end\n  local function heap_pop(heap)\n    local ret = heap[1]\n    heap[1] = heap[#heap]\n    heap[#heap] = nil\n    local i = 1\n    while i * 2 <= #heap do\n      local j = i * 2\n      if j + 1 <= #heap and heap[j + 1][1] + heap[j + 1][2] < heap[j][1] + heap[j][2] then\n        j = j + 1\n      end\n      if heap[i][1] + heap[i][2] > heap[j][1] + heap[j][2] then\n        heap[i], heap[j] = heap[j], heap[i]\n        i = j\n      else\n        break\n      end\n    end\n    return ret\n  end\n  local heap = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap_push(heap, {nums1[i], nums2[j]})\n    end\n  end\n  local ret = {}\n  for i = 1, k do\n    if #heap == 0 then\n      break\n    end\n    table.insert(ret, heap_pop(heap))\n  end\n  return ret\nend",
    "    local len1, len2 = #nums1, #nums2\n    if len1 == 0 or len2 == 0 then\n        return {}\n    end\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {sum, i, j})\n            table.sort(heap, function(a, b) return a[1] < b[1] end)\n        elseif sum < heap[1][1] then\n            heap[1] = {sum, i, j}\n            table.sort(heap, function(a, b) return a[1] < b[1] end)\n        end\n    end\n    push(1, 1)\n    local res = {}\n    while #heap > 0 do\n        local sum, i, j = table.unpack(table.remove(heap, 1))\n        table.insert(res, {nums1[i], nums2[j]})\n        if j < len2 then\n            push(i, j + 1)\n        end\n        if j == 1 and i < len1 then\n            push(i + 1, 1)\n        end\n    end\n    return res\nend",
    "  local heap = Heap.new()\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap:push({nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n    end\n  end\n  local result = {}\n  for i = 1, k do\n    local pair = heap:pop()\n    if pair then\n      table.insert(result, pair[2])\n    end\n  end\n  return result\nend",
    "    local function heap_pop(heap)\n        local ret = heap[1]\n        local last = table.remove(heap)\n        local i = 1\n        while true do\n            local l = i * 2\n            local r = i * 2 + 1\n            if l > #heap then\n                break\n            end\n            local c = l\n            if r <= #heap and heap[r][1] < heap[l][1] then\n                c = r\n            end\n            if last[1] <= heap[c][1] then\n                break\n            end\n            heap[i] = heap[c]\n            i = c\n        end\n        heap[i] = last\n        return ret\n    end\n    local function heap_push(heap, val)\n        local i = #heap + 1\n        heap[i] = val\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] <= heap[i][1] then\n                break\n            end\n            heap[i] = heap[p]\n            i = p\n        end\n        heap[i] = val\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i] + nums2[j], {nums1[i], nums2[j]}})\n        end\n    end\n    local ret = {}\n    for i = 1, k do\n        if #heap == 0 then\n            break\n        end\n        local val = heap_pop(heap)\n        table.insert(ret, val[2])\n    end\n    return ret\nend",
    "    local n1, n2 = #nums1, #nums2\n    if n1 == 0 or n2 == 0 then return {} end\n    local heap = {}\n    local function push(i, j)\n        if i > n1 or j > n2 then return end\n        local v = nums1[i] + nums2[j]\n        if #heap < k then\n            heap[#heap + 1] = {v, i, j}\n            heap_up(heap, #heap)\n        elseif v < heap[1][1] then\n            heap[1] = {v, i, j}\n            heap_down(heap, 1)\n        end\n    end\n    push(1, 1)\n    local res = {}\n    while #heap > 0 do\n        local v, i, j = unpack(table.remove(heap, 1))\n        res[#res + 1] = {nums1[i], nums2[j]}\n        push(i, j + 1)\n        if j == 1 then push(i + 1, 1) end\n    end\n    return res\nend",
    "  local function heap_insert(heap, val)\n    heap[#heap + 1] = val\n    local i = #heap\n    while i > 1 do\n      local parent = math.floor(i / 2)\n      if heap[i] < heap[parent] then\n        heap[i], heap[parent] = heap[parent], heap[i]\n        i = parent\n      else\n        break\n      end\n    end\n  end",
    "    local res = {}\n    local heap = {}\n    local function push(i, j)\n        if i <= #nums1 and j <= #nums2 then\n            heap_push(heap, {nums1[i] + nums2[j], i, j})\n        end\n    end\n    push(1, 1)\n    while #res < k and #heap > 0 do\n        local val, i, j = unpack(heap_pop(heap))\n        table.insert(res, {nums1[i], nums2[j]})\n        push(i, j + 1)\n        if j == 1 then\n            push(i + 1, 1)\n        end\n    end\n    return res\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local ret = {}\n    for i = 1, k do\n        table.insert(ret, pairs[i])\n    end\n    return ret\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end\n  table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n  local result = {}\n  for i = 1, k do\n    table.insert(result, pairs[i])\n  end\n  return result\nend",
    "  local heap = Heap.new(function(a, b)\n    return a[1] + a[2] < b[1] + b[2]\n  end)\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      heap:push({nums1[i], nums2[j]})\n    end\n  end\n  local res = {}\n  for i = 1, k do\n    if heap:empty() then break end\n    res[i] = heap:pop()\n  end\n  return res\nend",
    "  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      table.insert(heap, {i, j, sum})\n      local i = #heap\n      while i > 1 do\n        local j = math.floor(i / 2)\n        if heap[j][3] > heap[i][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n          j = j + 1\n        end\n        if heap[j][3] < heap[i][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n  end\n  return result\nend",
    "  local pairs = {}\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      table.insert(pairs, {nums1[i], nums2[j]})\n    end\n  end",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, compare)\n    local res = {}\n    for i = 1, k do\n        table.insert(res, pairs[i])\n    end\n    return res\nend",
    "  local function insert(t, v)\n    local i = #t\n    while i > 0 and v[1] + v[2] < t[i][1] + t[i][2] do\n      i = i - 1\n    end\n    table.insert(t, i + 1, v)\n  end\n  local function pop(t)\n    return table.remove(t, 1)\n  end\n  local function top(t)\n    return t[1]\n  end\n  local function empty(t)\n    return #t == 0\n  end\n  local function size(t)\n    return #t\n  end\n  local function push(t, v)\n    insert(t, v)\n    if size(t) > k then\n      pop(t)\n    end\n  end\n  local function merge(t1, t2)\n    local t = {}\n    while not empty(t1) and not empty(t2) do\n      if top(t1)[1] + top(t1)[2] < top(t2)[1] + top(t2)[2] then\n        push(t, pop(t1))\n      else\n        push(t, pop(t2))\n      end\n    end\n    while not empty(t1) do\n      push(t, pop(t1))\n    end\n    while not empty(t2) do\n      push(t, pop(t2))\n    end\n    return t\n  end\n  local function merge_sort(t)\n    if size(t) <= 1 then\n      return t\n    end\n    local mid = math.floor(size(t) / 2)\n    local left = {}\n    local right = {}\n    for i = 1, mid do\n      left[i] = t[i]\n    end\n    for i = mid + 1, size(t) do\n      right[i - mid] = t[i]\n    end\n    return merge(merge_sort(left), merge_sort(right))\n  end\n  local t1 = merge_sort(nums1)\n  local t2 = merge_sort(nums2)\n  local t = {}\n  for i",
    "  local function heap_pop(heap)\n    local ret = heap[1]\n    local last = table.remove(heap)\n    local i = 1\n    while i * 2 <= #heap do\n      local l = i * 2\n      local r = i * 2 + 1\n      if r <= #heap and heap[r][1] < heap[l][1] then\n        l = r\n      end\n      if last[1] <= heap[l][1] then\n        break\n      end\n      heap[i] = heap[l]\n      i = l\n    end\n    heap[i] = last\n    return ret\n  end",
    "  if #nums1 == 0 or #nums2 == 0 then return {} end\n  local heap = {}\n  local function push(i, j)\n    local sum = nums1[i] + nums2[j]\n    if #heap < k then\n      heap[#heap+1] = {i, j, sum}\n      local i = #heap\n      while i > 1 do\n        local p = math.floor(i / 2)\n        if heap[p][3] > sum then\n          heap[i], heap[p] = heap[p], heap[i]\n          i = p\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {i, j, sum}\n      local i = 1\n      while true do\n        local l = i * 2\n        local r = i * 2 + 1\n        if l > #heap then break end\n        local min = heap[l][3]\n        local min_i = l\n        if r <= #heap and heap[r][3] < min then\n          min = heap[r][3]\n          min_i = r\n        end\n        if heap[i][3] > min then\n          heap[i], heap[min_i] = heap[min_i], heap[i]\n          i = min_i\n        else\n          break\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    push(i, 1)\n  end\n  local res = {}\n  for i = 1, #heap do\n    local h = heap[i]\n    res[i] = {nums1[h[1]], nums2[h[2]]}\n    if h[2] < #nums2 then\n      push(h[1], h[2] + 1)\n    end\n  end\n  return res\nend",
    "    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k or sum < heap[1][1] then\n            heapq.heappush(heap, {sum, i, j})\n            if #heap > k then\n                heapq.heappop(heap)\n            end\n        end\n    end\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            push(i, j)\n        end\n    end\n    local res = {}\n    for i = 1, #heap do\n        local item = heapq.heappop(heap)\n        res[#res + 1] = {nums1[item[2]], nums2[item[3]]}\n    end\n    return res\nend",
    "    local len1 = #nums1\n    local len2 = #nums2\n    local heap = {}\n    local function push(i, j)\n        local sum = nums1[i] + nums2[j]\n        if #heap < k then\n            table.insert(heap, {i, j, sum})\n            local i = #heap\n            while i > 1 do\n                local p = math.floor(i / 2)\n                if heap[p][3] > heap[i][3] then\n                    heap[p], heap[i] = heap[i], heap[p]\n                    i = p\n                else\n                    break\n                end\n            end\n        elseif sum < heap[1][3] then\n            heap[1] = {i, j, sum}\n            local i = 1\n            while i * 2 <= #heap do\n                local l = i * 2\n                local r = i * 2 + 1\n                if r <= #heap and heap[r][3] < heap[l][3] then\n                    l = r\n                end\n                if heap[l][3] < heap[i][3] then\n                    heap[l], heap[i] = heap[i], heap[l]\n                    i = l\n                else\n                    break\n                end\n            end\n        end\n    end\n    for i = 1, math.min(len1, k) do\n        push(i, 1)\n    end\n    local result = {}\n    while #heap > 0 do\n        local i, j, sum = table.unpack(table.remove(heap, 1))\n        table.insert(result, {nums1[i], nums2[j]})\n        if j + 1 <= len2 then\n            push(i, j + 1)\n        end\n    end\n    return result\nend",
    "  if #nums1 == 0 or #nums2 == 0 then\n    return {}\n  end\n  local heap = {}\n  local function push(x, y)\n    local sum = nums1[x] + nums2[y]\n    if #heap < k then\n      table.insert(heap, {x, y, sum})\n      local i = #heap\n      while i > 1 do\n        local j = math.floor(i / 2)\n        if heap[j][3] > heap[i][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    elseif sum < heap[1][3] then\n      heap[1] = {x, y, sum}\n      local i = 1\n      while i * 2 <= #heap do\n        local j = i * 2\n        if j + 1 <= #heap and heap[j + 1][3] < heap[j][3] then\n          j = j + 1\n        end\n        if heap[i][3] > heap[j][3] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n  push(1, 1)\n  local result = {}\n  while #heap > 0 do\n    local x, y, sum = table.unpack(table.remove(heap, 1))\n    table.insert(result, {nums1[x], nums2[y]})\n    if x < #nums1 and y < #nums2 then\n      push(x, y + 1)\n      push(x + 1, y)\n    elseif x < #nums1 then\n      push(x + 1, y)\n    elseif y < #nums2 then\n      push(x, y + 1)\n    end\n  end\n  return result\nend",
    "    local function heap_pop(heap)\n        local ret = heap[1]\n        local last = table.remove(heap)\n        if #heap > 0 then\n            heap[1] = last\n            local i = 1\n            while true do\n                local l = i * 2\n                local r = l + 1\n                if l > #heap then break end\n                local j = l\n                if r <= #heap and heap[r][1] < heap[l][1] then\n                    j = r\n                end\n                if heap[i][1] <= heap[j][1] then break end\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            end\n        end\n        return ret\n    end\n    local function heap_push(heap, item)\n        table.insert(heap, item)\n        local i = #heap\n        while i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j][1] <= heap[i][1] then break end\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n    end\n    local function heap_top(heap)\n        return heap[1]\n    end\n    local function heap_empty(heap)\n        return #heap == 0\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            heap_push(heap, {nums1[i] + nums2[j], i, j})\n        end\n    end\n    local ret = {}\n    for i = 1, k do\n        if heap_empty(heap) then break end\n        local item = heap_pop(heap)\n        table.insert(ret, {nums1[item[2]], nums2[item[3]]})\n    end\n    return ret\nend",
    "  local heap = {}\n  local function push(x, y)\n    if #heap < k then\n      table.insert(heap, {x, y})\n      local i = #heap\n      while i > 1 do\n        local j = math.floor(i / 2)\n        if nums1[heap[i][1]] + nums2[heap[i][2]] < nums1[heap[j][1]] + nums2[heap[j][2]] then\n          heap[i], heap[j] = heap[j], heap[i]\n          i = j\n        else\n          break\n        end\n      end\n    else\n      if nums1[x] + nums2[y] < nums1[heap[1][1]] + nums2[heap[1][2]] then\n        heap[1] = {x, y}\n        local i = 1\n        while 2 * i <= #heap do\n          local j = 2 * i\n          if j + 1 <= #heap and nums1[heap[j + 1][1]] + nums2[heap[j + 1][2]] < nums1[heap[j][1]] + nums2[heap[j][2]] then\n            j = j + 1\n          end\n          if nums1[heap[i][1]] + nums2[heap[i][2]] > nums1[heap[j][1]] + nums2[heap[j][2]] then\n            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n          else\n            break\n          end\n        end\n      end\n    end\n  end\n  for i = 1, #nums1 do\n    for j = 1, #nums2 do\n      push(i, j)\n    end\n  end\n  local result = {}\n  for i = 1, #heap do\n    table.insert(result, {nums1[heap[i][1]], nums2[heap[i][2]]})\n  end\n  return result\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local res = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                res[#res + 1] = nums1[i]\n                i = i + 1\n            else\n                res[#res + 1] = nums2[j]\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            res[#res + 1] = nums1[i]\n            i = i + 1\n        end\n        while j <= #nums2 do\n            res[#res + 1] = nums2[j]\n            j = j + 1\n        end\n        return res\n    end",
    "    local pairs = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(pairs, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(pairs, function(a, b) return a[1] + a[2] < b[1] + b[2] end)\n    local result = {}\n    for i = 1, k do\n        if pairs[i] then\n            table.insert(result, pairs[i])\n        end\n    end\n    return result\nend",
    "    local function merge(nums1, nums2)\n        local i, j = 1, 1\n        local res = {}\n        while i <= #nums1 and j <= #nums2 do\n            if nums1[i] < nums2[j] then\n                table.insert(res, nums1[i])\n                i = i + 1\n            else\n                table.insert(res, nums2[j])\n                j = j + 1\n            end\n        end\n        while i <= #nums1 do\n            table.insert(res, nums1[i])\n            i = i + 1\n        end\n        while j <= #nums2 do\n            table.insert(res, nums2[j])\n            j = j + 1\n        end\n        return res\n    end\n    local function merge_sort(nums)\n        if #nums <= 1 then return nums end\n        local mid = math.floor(#nums / 2)\n        local left = merge_sort(nums, 1, mid)\n        local right = merge_sort(nums, mid + 1, #nums)\n        return merge(left, right)\n    end\n    local function k_smallest(nums1, nums2, k)\n        local res = {}\n        for i = 1, #nums1 do\n            for j = 1, #nums2 do\n                table.insert(res, {nums1[i], nums2[j]})\n            end\n        end\n        table.sort(res, function(a, b)\n            return a[1] + a[2] < b[1] + b[2]\n        end)\n        local res_k = {}\n        for i = 1, k do\n            table.insert(res_k, res[i])\n        end\n        return res_k\n    end\n    return k_smallest(nums1, nums2, k)\nend",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end",
    "    local function heap_pop(heap)\n        local ret = heap[1]\n        local last = table.remove(heap)\n        if #heap > 0 then\n            heap[1] = last\n            local i = 1\n            while true do\n                local l, r = 2 * i, 2 * i + 1\n                if r <= #heap then\n                    if heap[l][1] < heap[r][1] then\n                        if heap[i][1] > heap[l][1] then\n                            heap[i], heap[l] = heap[l], heap[i]\n                            i = l\n                        else\n                            break\n                        end\n                    else\n                        if heap[i][1] > heap[r][1] then\n                            heap[i], heap[r] = heap[r], heap[i]\n                            i = r\n                        else\n                            break\n                        end\n                    end\n                elseif l <= #heap then\n                    if heap[i][1] > heap[l][1] then\n                        heap[i], heap[l] = heap[l], heap[i]\n                        i = l\n                    else\n                        break\n                    end\n                else\n                    break\n                end\n            end\n        end\n        return ret\n    end\n    local function heap_push(heap, val)\n        table.insert(heap, val)\n        local i = #heap\n        while i > 1 do\n            local p = math.floor(i / 2)\n            if heap[p][1] > heap[i][1] then\n                heap[p], heap[i] = heap[i], heap[p]\n                i = p\n            else\n                break\n            end\n        end\n    end\n    local heap = {}\n    for i = 1, #nums1 do\n        heap_push(heap, {nums1[i] + nums2[1], i, 1})\n    end\n    local ret = {}\n    while #ret < k and #heap > 0 do\n        local val = heap_pop(heap)\n        table.insert(ret, {nums1[val[2]], nums2[val[3]]})\n",
    "    local function compare(a, b)\n        return a[1] + a[2] < b[1] + b[2]\n    end\n    local res = {}\n    for i = 1, #nums1 do\n        for j = 1, #nums2 do\n            table.insert(res, {nums1[i], nums2[j]})\n        end\n    end\n    table.sort(res, compare)\n    local ret = {}\n    for i = 1, k do\n        table.insert(ret, res[i])\n    end\n    return ret\nend"
  ]
}