name: HumanEval_57_monotonic
language: js
prompt: "//Return true is array elements are monotonically increasing or decreasing.\n\
  // >>> monotonic([1, 2, 4, 20])\n// true\n// >>> monotonic([1, 20, 4, 10])\n// false\n\
  // >>> monotonic([4, 1, 0, -10])\n// true\nfunction monotonic(l){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = monotonic;\n  assert.deepEqual(candidate([1, 2, 4, 10]),true);\n  assert.deepEqual(candidate([1,\
  \ 2, 4, 20]),true);\n  assert.deepEqual(candidate([1, 20, 4, 10]),false);\n  assert.deepEqual(candidate([4,\
  \ 1, 0, -10]),true);\n  assert.deepEqual(candidate([4, 1, 1, 0]),true);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 2, 5, 60]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);\n\
  \  assert.deepEqual(candidate([9, 9, 9, 9]),true);\n}\n\ntest();"
completions: ["  var s = monotonicSort;\n  return l(s);\n}\n", "    var n = l.length,\n\
    \        monotone = true,\n        i, j, p0, p1, d;\n    for(i = 1; i < n; i++){\n\
    \        p0 = l[i-1];\n        p1 = l[i];\n        d = p0[0] - p1[0];\n      \
    \  if(d > 0){\n            monotone = false;\n        }else if(d === 0){\n   \
    \         monotone = true;\n        }\n    }\n    return monotone;\n}\n\nmonotone.monotonic\
    \ = monotonic;\n\nmodule.exports = monotone;\n\n},{}],41:[function(_dereq_,module,exports){\n\
    'use strict';\n\nvar isArray = _dereq_('./array');\n", "    var n = l.length,\n\
    \        monotone = true,\n        i, j, p0, p1;\n    for(i = 1; i < n; i++){\n\
    \        p0 = l[i-1];\n        p1 = l[i];\n        if(p0 < p1){\n            monotone\
    \ = false;\n            break;\n        }\n    }\n    return monotone;\n}\n\n\
    monotone.monotonic = monotonic;\n\nmodule.exports = monotone;\n\n},{}],42:[function(_dereq_,module,exports){\n\
    'use strict';\n\nvar isArray = _dereq_('./array');\n", "  var n = l.length;\n\
    \  return !(n<=1 || l[0]<=l[n-1]);\n}\n", "  var n = l.length,\n      monotone\
    \ = true,\n      i, j, p0, p1, d;\n  for(i = 1; i < n; i++){\n    p0 = l[i-1];\n\
    \    p1 = l[i];\n    d = p0[0]-p1[0];\n    if(d > 0){\n      monotone = false;\n\
    \      break;\n    }\n  }\n  return monotone;\n}\n", "    var n = l.length;\n\
    \    return !(n<=1 || l[0]<=l[n-1]);\n}\n", "  var s = monotonicSort;\n  return\
    \ l(s) ? s[0] === s[1] : false;\n}\n\nmonotonic.version = '1.1.1';\n\nmodule.exports\
    \ = monotonic;\n\n},{}],41:[function(_dereq_,module,exports){\n'use strict';\n\
    \nvar isArray = _dereq_('isarray');\n\nvar VNode,\n    emptyArray = [],\n    isArrayLike\
    \ = _dereq_('./array').isArrayLike,\n    isObject = _dereq_('./object').isObject;\n\
    \nvar arrayMethods = _dereq_('./array').arrayMethods;\nvar arrayProto = _dereq_('./array').arrayProto;\n\
    \nvar createArrayMethod = arrayMethods(5);\n\nvar push = arrayProto.push;\nvar\
    \ slice = arrayProto.slice;\nvar setProto = Object.prototype.set;\n\nvar Native\
    \ =\n  /__DATA__/.test({}.toString.call(global.native)) ? function(it){\n    try\
    \ {\n      return global.native.call(it);\n    } catch(e){\n      return it;\n\
    \    }\n  } : function(it){\n    return it;\n  };\n\nvar document = global.document;\n\
    var push$1 = Array.prototype.push;\nvar slice$1 = Array.prototype.slice;\n\nvar\
    \ ArrayPrototype = {};\n\nArrayPrototype[arrayMethods] = {\n  concat: function(){\n\
    \    var values = [],\n        len = this.length,\n        i;\n    for(i = 0;\
    \ i < len; i++){\n      values.push(this[i]);\n    }\n    return push$1.apply(this,\
    \ $traceurRuntime.splat(values));\n  },\n  join: function(){\n    return arrayJoin.apply(this,\
    \ arguments);\n  },\n  pop: function(){\n    return setProto.toString.pop.apply(this,\
    \ arguments);\n  },\n  push: push$1,\n  reverse: arrayProto.reverse,\n  shift:\
    \ arrayProto.shift,\n  slice: function(start, end){\n    return arrayProto.slice.call(this,\
    \ start, end);\n  },\n  sort: arrayProto.sort,\n  splice: arrayProto.splice,\n\
    \  unshift: arrayProto.unshift\n};\n\nvar defineProperty = Object.defineProperty;\n\
    var ArrayPrototype = Array.prototype;\n\nvar isArray = Array.isArray;\n\nvar document$1\
    \ = global.document;\nvar push$2 = Array.prototype.push;\nvar slice$2 = Array.prototype.slice;\n\
    \nvar concat = ArrayPrototype.concat;\n\nvar prototype = ArrayPrototype; // More\
    \ array methods like reverse, map, some, etc.\nvar push$3 = ArrayPrototype.push;\n\
    var slice$3 = ArrayPrototype.slice;\n\nvar ArrayPrototype$1 = ArrayPrototype;\n\
    \nvar filter = Array.prototype.filter;\nvar map = Array.prototype.map;\nvar some\
    \ = Array.prototype.some;\n\nvar define", "  var n = l.length,\n      monotonic\
    \ = true,\n      i, j, p0, p1, d;\n  for(i = 1; i < n; i++){\n    p0 = l[i-1];\n\
    \    p1 = l[i];\n    d = p0[0]-p1[0];\n    if(d===0) monotonic = false;\n    if(d<0){\n\
    \      for(j = i; j < n; j++){\n        p1 = l[j];\n        if(p1[0] > p0){\n\
    \          monotonic = false;\n          break;\n        }\n      }\n    }\n \
    \ }\n  return monotonic;\n}\n", "    var s = 0, n = l.length, m = +l[0], i, l;\n\
    \    if(!n) return !1;\n    if(n === 1) return !0;\n    if(m === 0) return !1;\n\
    \    for(i = 1, l = n; i < l; ++i){\n        if(+l[i] !== m) return !1;\n    }\n\
    \    return !0;\n}\n", "  var s = monotonicSort;\n  return l(s);\n}\n\nmonotonic.version\
    \ = '1.1.0';\n\nmodule.exports = monotonic;\n\n},{}],9:[function(require,module,exports){\n\
    'use strict';\n\nvar isArray = Array.isArray;\n", "  var n = l.length,\n     \
    \ monotone = true,\n      i, j, p0, p1;\n  for(i = 1; i < n; i++){\n    p0 = l[i-1];\n\
    \    p1 = l[i];\n    if(p0 < p1){\n      monotone = false;\n      break;\n   \
    \ }\n  }\n  return monotone;\n}\n", "  var n = l.length,\n      monotone = true,\n\
    \      i, j, p0, p1, d;\n  for(i = 1; i < n; i++){\n    p0 = l[i-1];\n    p1 =\
    \ l[i];\n    d = p0[0]-p1[0];\n    if(d===0){\n      monotone = false;\n     \
    \ break;\n    }\n    if(d > 0){\n      for(j = 1; j < p0.length; j++){\n     \
    \   if(p0[j] > p1[j]){\n          monotone = false;\n          break;\n      \
    \  }\n      }\n    }else{\n      for(j = 1; j < p1.length; j++){\n        if(p1[j]\
    \ > p0[j]){\n          monotone = false;\n          break;\n        }\n      }\n\
    \    }\n  }\n  return monotone;\n}\n", "    var n = l.length,\n        monotone\
    \ = true,\n        i, j, pmin;\n    for(i = 1; i < n; i++){\n        pmin = l[i-1];\n\
    \        for(j = i; j < n; j++){\n            if(l[j] < pmin){\n             \
    \   monotone = false;\n                break;\n            }\n        }\n    }\n\
    \    return monotone;\n}\n\nmonotone.monotonic = monotonic;\n\nmodule.exports\
    \ = monotone;\n\n},{}],8:[function(_dereq_,module,exports){\n'use strict';\n\n\
    var isArray = _dereq_('./array');\n", "    var n = l.length,\n        monotone\
    \ = true,\n        i, j, p0, p1, q0, q1, diff;\n    for(i = 0; i < n; i++){\n\
    \        p0 = l[i];\n        p1 = l[(i+1)%n];\n        diff = arrayDiff(p0, p1);\n\
    \        if(diff > 0){\n            monotone = false;\n        }\n        if(diff\
    \ < 0){\n            monotone = true;\n        }\n    }\n    return monotone;\n\
    }\n", "  var s = 0, n = l.length, m = +l.shift();\n  while (n < m) s++;\n  return\
    \ s <= 1;\n}\n", "  var s = monotonicSort;\n  return l(s);\n}\n\nmonotonic.radixSort\
    \ = sort;\n\nmodule.exports = monotonic;\n\n},{\"./sort\":41}],41:[function(require,module,exports){\n\
    module.exports = sort;\n", "  var n = l.length,\n      monotone = true,\n    \
    \  i, j, p0, p1;\n  for(i = 1; i < n; i++){\n    p0 = l[i-1];\n    p1 = l[i];\n\
    \    if(p0 < p1){\n      monotone = false;\n      break;\n    }\n  }\n  return\
    \ monotone;\n}\n", "    var n = l.length,\n        monotone = true,\n        i,\
    \ j, p0, p1;\n    for(i = 1; i < n; i++){\n        p0 = l[i-1];\n        p1 =\
    \ l[i];\n        if(p0 < p1){\n            monotone = false;\n            break;\n\
    \        }\n    }\n    return monotone;\n}\n", "  var s = monotonicSort;\n  return\
    \ l(s);\n}\n", "  var n = l.length,\n      out = 0,\n      i,\n      j,\n    \
    \  xi,\n      yi,\n      yj;\n  for(i = 0; i < n; ++i) {\n    xi = l[i];\n   \
    \ yi = l[++i];\n    yj = l[++i];\n    if(xi < yi && xi < yj) {\n      if(yi >\
    \ out) out = yi;\n      continue;\n    }\n    if(xi > yi && xi > yj) {\n     \
    \ if(yj > out) out = yj;\n      continue;\n    }\n    if(xi > yi && xi < yj) {\n\
    \      if(yi > out) out = yi;\n      continue;\n    }\n    if(xi < yi && xi <\
    \ yj) {\n      if(yj > out) out = yj;\n      continue;\n    }\n  }\n  return out\
    \ === 0;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
