name: HumanEval_115_max_fill
language: js
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid, capacity){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
  \ 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0,\
  \ 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n\
  \  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();"
completions: ["    let count = 0;\n    for(let i = 0; i < grid.length; i++){\n   \
    \     for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ===\
    \ 1){\n                count += max_fill(grid, capacity);\n            }\n   \
    \     }\n    }\n    return count;\n}\n", "    let buckets = Array(grid.length).fill(0).map(()\
    \ => Array(capacity).fill(0));\n    for(let i = 0; i < grid.length; i++){\n  \
    \      for(let j = 0; j < grid[i].length; j++){\n            buckets[i][j] = grid[i][j];\n\
    \        }\n    }\n    \n    let count = 0;\n    for(let i = 0; i < buckets.length;\
    \ i++){\n        for(let j = 0; j < buckets[i].length; j++){\n            if(buckets[i][j]\
    \ === 1){\n                count += 1;\n                for(let k = j; k < buckets[i].length;\
    \ k++){\n                    buckets[i][k] = 0;\n                }\n         \
    \   }\n        }\n    }\n    \n    return count;\n}\n", "    let buckets = Array(grid.length).fill(0).map(()\
    \ => Array(capacity).fill(0));\n    for(let i = 0; i < grid.length; i++){\n  \
    \      for(let j = 0; j < grid[i].length; j++){\n            buckets[i][j] = grid[i][j];\n\
    \        }\n    }\n    \n    let count = 0;\n    for(let i = 0; i < buckets.length;\
    \ i++){\n        for(let j = 0; j < buckets[i].length; j++){\n            if(buckets[i][j]\
    \ === 1){\n                count += 1;\n                for(let k = j; k < buckets[i].length;\
    \ k++){\n                    buckets[i][k] = 0;\n                }\n         \
    \   }\n        }\n    }\n    return count;\n}\n", "    let buckets = Array(grid.length).fill(0).map(()\
    \ => Array(capacity).fill(0));\n    \n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            buckets[i][j] =\
    \ grid[i][j];\n        }\n    }\n    \n    let count = 0;\n    \n    for(let i\
    \ = 0; i < buckets.length; i++){\n        for(let j = 0; j < buckets[i].length;\
    \ j++){\n            count += buckets[i][j];\n        }\n    }\n    \n    return\
    \ count;\n}\n", "    let buckets = Array(grid.length).fill(0).map(() => Array(capacity).fill(0));\n\
    \    let count = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let\
    \ j = 0; j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n      \
    \          buckets[i][j] = 1;\n                count += 1;\n            }\n  \
    \      }\n    }\n    return count;\n}\n", "    let buckets = Array(grid.length).fill(0).map(()\
    \ => Array(capacity).fill(0));\n    \n    for (let i = 0; i < grid.length; i++){\n\
    \        for (let j = 0; j < grid[i].length; j++){\n            if (grid[i][j]\
    \ === 1){\n                buckets[i][j] = 1;\n            }\n        }\n    }\n\
    \    \n    let count = 0;\n    \n    for (let i = 0; i < buckets.length; i++){\n\
    \        for (let j = 0; j < buckets[i].length; j++){\n            if (buckets[i][j]\
    \ === 0){\n                count++;\n            }\n        }\n    }\n    \n \
    \   return count;\n}\n", "    let result = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                let bucket = grid[i][j];\n                while(bucket\
    \ > 0){\n                    bucket -= 1;\n                    result += 1;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\n",
  "    let buckets = new Array(capacity).fill(0);\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                buckets[grid[i][j]] += 1;\n            }\n        }\n\
    \    }\n    let count = 0;\n    for(let i = 0; i < buckets.length; i++){\n   \
    \     if(buckets[i] > 0){\n            count += buckets[i];\n        }\n    }\n\
    \    return count;\n}\n", "    let buckets = Array.from({ length: capacity },\
    \ () => new Array(capacity).fill(0));\n    let count = 0;\n    for(let i = 0;\
    \ i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n \
    \           buckets[grid[i][j]][buckets[grid[i][j]].length - 1]++;\n        }\n\
    \    }\n    for(let i = 0; i < buckets.length; i++){\n        for(let j = 0; j\
    \ < buckets[i].length; j++){\n            if(buckets[i][j] === 0){\n         \
    \       buckets[i][j] = 1;\n                count++;\n            }\n        }\n\
    \    }\n    return count;\n}\n", "    let buckets = Array(grid.length).fill(0).map(()\
    \ => Array(capacity).fill(0));\n    for(let i = 0; i < grid.length; i++){\n  \
    \      for(let j = 0; j < grid[i].length; j++){\n            buckets[i][j] = grid[i][j];\n\
    \        }\n    }\n    for(let i = 0; i < buckets.length; i++){\n        for(let\
    \ j = 0; j < buckets[i].length; j++){\n            buckets[i][j] = buckets[i][j]\
    \ ? buckets[i][j] + 1 : 1;\n        }\n    }\n    return buckets.reduce((a, b)\
    \ => a > b ? a : b);\n}\n", "    let result = 0;\n    let buckets = Array(grid.length).fill(0);\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            buckets[grid[i][j]] += 1;\n        }\n    }\n    for(let\
    \ i = 0; i < buckets.length; i++){\n        if(buckets[i] < capacity){\n     \
    \       buckets[i] -= capacity;\n            result += 1;\n        }\n    }\n\
    \    return result;\n}\n", "    let buckets = new Array(capacity).fill(0);\n \
    \   let count = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let\
    \ j = 0; j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n      \
    \          buckets[grid[i][j]] += 1;\n            }\n        }\n    }\n    for(let\
    \ i = 0; i < buckets.length; i++){\n        if(buckets[i] <= 0){\n           \
    \ buckets[i] = 0;\n        }\n    }\n    while(buckets.length > 0){\n        buckets.shift();\n\
    \        count += 1;\n    }\n    return count;\n}\n", "    let count = 0;\n  \
    \  for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                let bucket = grid[i][j];\n\
    \                while(bucket > 0){\n                    bucket--;\n         \
    \           grid[i][j] = 0;\n                    count++;\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    let buckets = Array(grid.length).fill(0).map(() => Array(capacity).fill(0));\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            buckets[i][j] = grid[i][j];\n        }\n    }\n    while(buckets.some(row\
    \ => row.some(cell => cell === 1))){\n        buckets = buckets.map(row => row.map(cell\
    \ => cell === 1 ? 0 : cell));\n        count++;\n    }\n    return count;\n}\n",
  "    let result = 0;\n    let buckets = grid.map((row) => new Array(capacity).fill(0));\n\
    \    \n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[0].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                buckets[grid[i][j]][buckets[grid[i][j]].length\
    \ - 1]++;\n            }\n        }\n    }\n    \n    for(let i = 0; i < buckets.length;\
    \ i++){\n        for(let j = 0; j < buckets[i].length; j++){\n            if(buckets[i][j]\
    \ === 0){\n                buckets[i][j] = 1;\n                result ++;\n  \
    \          }\n        }\n    }\n    \n    return result;\n}\n", "    let count\
    \ = 0;\n    let buckets = Array(grid.length).fill(0);\n    for(let i = 0; i <\
    \ grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n     \
    \       buckets[grid[i][j]] += 1;\n        }\n    }\n    for(let i = 0; i < buckets.length;\
    \ i++){\n        if(buckets[i] > capacity){\n            count += buckets[i] -\
    \ capacity;\n        }\n    }\n    return count;\n}\n", "    let result = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                let bucket = grid[i][j];\n\
    \                for(let k = 0; k < bucket; k++){\n                    grid[i][j]\
    \ = 0;\n                    result++;\n                }\n            }\n    \
    \    }\n    }\n    return result;\n}\n", "    let result = 0;\n    for(let i =\
    \ 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                let bucket = grid[i][j];\n\
    \                while(bucket > 0){\n                    bucket -= 1;\n      \
    \              result += 1;\n                }\n            }\n        }\n   \
    \ }\n    return result;\n}\n", "    let count = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[0].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                count += max_fill(grid.slice(i + 1, i + 2), capacity);\n\
    \                count += max_fill(grid.slice(j, j + 1), capacity);\n        \
    \    }\n        }\n    }\n    return count;\n}\n", "    let buckets = new Array(capacity).fill(0);\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                buckets[grid[i][j]-1]++;\n\
    \            }\n        }\n    }\n    let count = 0;\n    for(let i = 0; i < buckets.length;\
    \ i++){\n        if(buckets[i] > 0){\n            count += buckets[i];\n     \
    \   }\n    }\n    return count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
