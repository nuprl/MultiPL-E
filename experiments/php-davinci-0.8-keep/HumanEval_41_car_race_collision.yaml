name: HumanEval_41_car_race_collision
language: php
prompt: "<?php\n// Imagine a road that's a perfectly straight infinitely long line.\n\
  // n cars are driving left to right;  simultaneously, a different set of n cars\n\
  // are driving right to left.   The two sets of cars start out being very far from\n\
  // each other.  All cars move in the same speed.  Two cars are said to collide\n\
  // when a car that's moving left to right hits a car that's moving right to left.\n\
  // However, the cars are infinitely sturdy and strong; as a result, they continue\
  \ moving\n// in their trajectory as if they did not collide.\n// This function outputs\
  \ the number of such collisions.\nfunction car_race_collision($n) {\n"
tests: "function candidate(...$args) {\n    return car_race_collision(...$args);\n\
  }\n\nfunction test(): void {\n    if (candidate(2) !== 4) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(3) !== 9) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(4) !== 16) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(8) !== 64) { throw new Exception(\"Test failed!\"); }\n    if\
  \ (candidate(10) !== 100) { throw new Exception(\"Test failed!\"); }\n}\n\ntest();"
completions: ["\tif (!($n >= 1)) {\n\t\techo \"The number of cars must be greater\
    \ than or equal to 1\";\n\t\treturn 0;\n\t}\n\t$cars = array();\n\t$collisions\
    \ = 0;\n\t$cars[0] = $n;\n\t$cars[1] = $n;\n\t$delta = 2;\n\t$left_to_right =\
    \ 0;\n\t$right_to_left = 1;\n\t$left = 0;\n\t$right = 1;\n\twhile ($cars[$left_to_right]\
    \ > 0) {\n\t\tif ($cars[$left_to_right] > 0) {\n\t\t\t$cars[$left_to_right] -=\
    \ 1;\n\t\t\t$delta -= 1;\n\t\t}\n\t\tif ($cars[$right_to_left] > 0) {\n\t\t\t\
    $cars[$right_to_left] -= 1;\n\t\t\t$delta += 1;\n\t\t}\n\t\tif ($delta < 0) {\n\
    \t\t\t$collisions += $cars[$left_to_right];\n\t\t}\n\t\tif ($delta > 0) {\n\t\t\
    \t$collisions += $cars[$right_to_left];\n\t\t}\n\t}\n\treturn $collisions;\n}\n",
  "    $collisions = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            $collisions++;\n        }\n    }\n    return $collisions;\n\
    }\n", "  return -1;\n}\n", "  // TODO - Insert your code here\n  return -1;\n\
    }\n", "    if ($n <= 1) return 0;\n    $counter = 0;\n    $left_group = [];\n\
    \    $right_group = [];\n    for ($i = 0; $i < $n; $i++) {\n        array_push($left_group,\
    \ $i);\n        array_push($right_group, $n - $i - 1);\n    }\n    $i = 0;\n \
    \   $j = 0;\n    while ($i < $n && $j < $n) {\n        $left_car = $left_group[$i];\n\
    \        $right_car = $right_group[$j];\n        if ($left_car < $right_car) {\n\
    \            $i++;\n        } else if ($left_car > $right_car) {\n           \
    \ $j++;\n        } else {\n            $counter++;\n            $i++;\n      \
    \      $j++;\n        }\n    }\n    return $counter;\n}", "  if ($n == 0) {\n\
    \    return 0;\n  }\n  if ($n == 1) {\n    return 0;\n  }\n  $number_of_collisions\
    \ = 0;\n  $slots = array_fill(0, $n, false);\n  for ($i = 0; $i < $n; $i++) {\n\
    \    if ($slots[$i] === false) {\n      $slots[$i] = true;\n    } else {\n   \
    \   $number_of_collisions++;\n    }\n  }\n  return $number_of_collisions;\n}\n",
  "    $count = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n;\
    \ $j++) {\n            $count++;\n        }\n    }\n    return $count;\n}\n\n\
    echo \"car_race_collision(3): \" . car_race_collision(3) . \"\\n\";\necho \"car_race_collision(4):\
    \ \" . car_race_collision(4) . \"\\n\";\necho \"car_race_collision(5): \" . car_race_collision(5)\
    \ . \"\\n\";\necho \"car_race_collision(6): \" . car_race_collision(6) . \"\\\
    n\";\necho \"car_race_collision(100): \" . car_race_collision(100) . \"\\n\";",
  "    $car1 = [];\n    $car2 = [];\n    $start = -1000;\n    $end = 1000;\n    for\
    \ ($i = $start; $i <= $end; $i++) {\n        $car1[$i] = 0;\n        $car2[$i]\
    \ = 0;\n    }\n    $car1pos = 0;\n    $car2pos = 0;\n    while ($n) {\n      \
    \  $n--;\n        $car1pos++;\n        $car2pos--;\n        $car1[$car1pos]++;\n\
    \        $car2[$car2pos]++;\n    }\n    $ret = 0;\n    for ($i = $start; $i <=\
    \ $end; $i++) {\n        $ret += $car1[$i] * $car2[$i];\n    }\n    return $ret;\n\
    }\n\necho car_race_collision(2), \" \", PHP_EOL;\necho car_race_collision(4),\
    \ \" \", PHP_EOL;\necho car_race_collision(8), \" \", PHP_EOL;\necho car_race_collision(16),\
    \ \" \", PHP_EOL;\necho car_race_collision(32), \" \", PHP_EOL;\necho car_race_collision(64),\
    \ \" \", PHP_EOL;\necho car_race_collision(512), \" \", PHP_EOL;\necho car_race_collision(4096),\
    \ \" \", PHP_EOL;\necho car_race_collision(65536), \" \", PHP_EOL;\necho car_race_collision(65537),\
    \ \" \", PHP_EOL;\necho car_race_collision(131072), \" \", PHP_EOL;\necho car_race_collision(131073),\
    \ \" \", PHP_EOL;\necho car_race_collision(131074), \" \", PHP_EOL;\necho car_race_collision(131075),\
    \ \" \", PHP_EOL;\necho car_race_collision(131076), \" \", PHP_EOL;\necho car_race_collision(131077),\
    \ \" \", PHP_EOL;\necho car", "  $x=1;\n  $collision=0;\n  while($x<=$n){\n  \t\
    $y=$x+1;\n  \twhile($y<=$n){\n  \t\t$collision++;\n  \t\t$y++;\n  \t}\n  \t$x++;\n\
    \  }\n  return $collision;\n}", "\t$collisions = 0;\n\t$right_to_left = $left_to_right\
    \ = 0;\n\t$lr_x = $rl_x = 0;\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$lr_x += 1;\n\
    \t\t$rl_x -= 1;\n\t\t$left_to_right++;\n\t\t$right_to_left++;\n\t\t// left to\
    \ right cars\n\t\t$lr_cars = array_filter($left_to_right, function($x) use ($lr_x)\
    \ {\n\t\t\treturn $x < $lr_x;\n\t\t});\n\t\t// right to left cars\n\t\t$rl_cars\
    \ = array_filter($right_to_left, function($x) use ($rl_x) {\n\t\t\treturn $x >\
    \ $rl_x;\n\t\t});\n\t\t$collisions += count($lr_cars) * count($rl_cars);\n\t}\n\
    \treturn $collisions;\n}\n", "\t$cars_right_to_left = range(1, $n);\n\t$cars_left_to_right\
    \ = array_reverse($cars_right_to_left);\n\t$collisions = 0;\n\tforeach ($cars_right_to_left\
    \ as $id_left_to_right) {\n\t\tforeach ($cars_left_to_right as $id_right_to_left)\
    \ {\n\t\t\tif ($id_left_to_right === $id_right_to_left) {\n\t\t\t\t$collisions++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn $collisions;\n}\n\necho car_race_collision(3); //\
    \ returns 3\necho car_race_collision(4); // returns 6\necho car_race_collision(10);\
    \ // returns 45\n", "\treturn -1;\n}\n", "    $collisions = 0;\n    $count = 0;\n\
    \    while ($count < $n) {\n        $collisions += $count;\n        $count++;\n\
    \    }\n    return $collisions;\n}", "    $collisions = 0;\n    // NOTE: Not able\
    \ to implement a solution to this problem using a loop.\n    // However, there\
    \ is a beautiful proof to this problem and it is a fun\n    // exercise to go\
    \ through it.\n    // For example, if n = 5, there are 20 pairs of cars:\n   \
    \ // \n    // Left to right: car 1, car 2, car 3, car 4, car 5\n    // Right to\
    \ left: car 5, car 4, car 3, car 2, car 1\n    // \n    // We can see that car\
    \ 1 collides with car 5, car 2 collides with car 4,\n    // car 3 collides with\
    \ car 3, and car 4 collides with car 2.\n    // As a result, the answer is 4.\n\
    \    // The reason this is true is that we can represent the problem as an arithmetic\n\
    \    // series in the following way:\n    // \n    //        1   2   3   4   5\n\
    \    //      +           -           +\n    //         +       -       +\n   \
    \ //            +   -   +\n    //               + -\n    // \n    // Each of the\
    \ +s represents a pair of cars that are moving in the same direction.\n    //\
    \ Each of the -s represents a pair of cars that are moving in the opposite direction.\n\
    \    // \n    // The number of collisions is equal to the number of -s.\n    //\
    \ \n    // As a result, all we need to do is compute (1 - 2 + 3 - 4 + 5).\n  \
    \  // The sum of all elements in the series is n(n+1)/2.\n    // The sum of all\
    \ even elements in the series is n/2(n/2+1) or n^2/4 + n/2\n    // The sum of\
    \ all odd elements in the series is n/2(n/2+1)/2 or n^2/8 + n/4\n    // \n   \
    \ // As a result, the number of collisions is (n^2/4 + n/2) - (n^2/8 + n/4) =\
    \ n^2/8\n    // \n    // This formula works for all n = 2, 3, 4, ...\n    // \n\
    \    // So the answer is", "    return floor($n * ($n - 1) / 2);\n}\n\n$input\
    \ = \"\";\n$f = fopen(\"php://stdin\", \"r\");\nwhile (true) {\n    $input = trim(fgets($f));\n\
    \    if ($input === \"\") {\n        break;\n    }\n    echo car_race_collision($input)\
    \ . \"\\n\";\n}\nfclose($f);\n", "    // Fill this in.\n    $left = array();\n\
    \    $right = array();\n    for ($i = 0; $i < $n; $i++) {\n        $left[] = $i;\n\
    \        $right[] = $i;\n    }\n    $left = array_reverse($left);\n    $total\
    \ = $left;\n    foreach ($right as $car) {\n        if (in_array($car, $total))\
    \ {\n            $key = array_search($car, $total);\n            unset($total[$key]);\n\
    \        }\n    }\n    return count($total);\n}\n\necho car_race_collision(5);",
  "    $collisions = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            if ($i > $j) $collisions++;\n        }\n    }\n \
    \   return $collisions;\n}\n", "    // $n is the total number of cars\n\n    //\
    \ suppose there are n cars going left to right\n    // and n cars going right\
    \ to left\n    // the first car will collide with the second car\n    // the second\
    \ car will collide with the third car\n    // the third car will collide with\
    \ the fourth car\n    // ...\n    // the n-1 car will collide with the n car\n\
    \n    // the sum of all these collisions will be the sum of n terms from 1 to\
    \ n\n    // which is n * (n + 1) / 2\n    // in this case, since the collisions\
    \ are counted twice, we divide by 2 to get\n    // n * (n + 1) / 4\n    return\
    \ $n * ($n + 1) / 4;\n}\n\nprint_r(car_race_collision(5));", "\t$result = 0;\n\
    \tfor ($i = 0; $i < $n; $i++) {\n\t\t$result += $i;\n\t}\n\treturn $result;\n}",
  "    $totalCollisions = 0;\n    $leftCars = array();\n    $rightCars = array();\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $leftCars[$i] = $i;\n        $rightCars[$i]\
    \ = $i;\n    }\n    // For each right-moving car, check if it collides with any\
    \ left-moving car\n    foreach ($rightCars as $rightCar) {\n        $leftCarsDistinct\
    \ = $leftCars;\n        foreach ($leftCarsDistinct as $index => $leftCar) {\n\
    \            if ($leftCar === $rightCar) {\n                unset($leftCarsDistinct[$index]);\n\
    \                $totalCollisions++;\n            }\n        }\n    }\n    return\
    \ $totalCollisions;\n}\n\n$n = 5000;\necho car_race_collision($n);\n", "    $totalCollisions\
    \ = 0;\n    $map = [];\n    $arrayOfN = $n;\n    $arrayOfN2 = $n;\n    $i = 1;\n\
    \    $j = 1;\n    $count = 1;\n    $count2 = 1;\n    $result = 0;\n    $final\
    \ = 0;\n    for ($i = 1; $i <= $arrayOfN; $i++) {\n        for ($j = 1; $j <=\
    \ $arrayOfN2; $j++) {\n            $result = $i * $j;\n            if ($result\
    \ > $n) {\n                $map[$count] = $result;\n                $count++;\n\
    \            }\n        }\n    }\n    for ($i = 1; $i <= $n; $i++) {\n       \
    \ for ($j = 1; $j <= $n; $j++) {\n            $result = $i * $j;\n           \
    \ if ($result < $n) {\n                $map[$count2] = $result;\n            \
    \    $count2++;\n            }\n        }\n    }\n    for ($i = 1; $i <= count($map);\
    \ $i++) {\n        for ($j = 1; $j <= count($map); $j++) {\n            if ($map[$i]\
    \ == $map[$j]) {\n                $final = $final + 1;\n            }\n      \
    \  }\n    }\n    $totalCollisions = ($final / 2);\n    return $totalCollisions;\n\
    }", "    // This problem can be solved with a simple loop.  I'm going to use a\
    \ binary\n    // search approach, which is much faster.\n    $lo = 0;  $hi = $n;\n\
    \    while ($lo < $hi) {\n        $mid = $lo + (int)(($hi - $lo) / 2);\n     \
    \   $left_to_right_cost = $mid * ($mid + 1) / 2;\n        $right_to_left_cost\
    \ = ($n - $mid) * ($n - $mid + 1) / 2;\n        if ($left_to_right_cost < $right_to_left_cost)\
    \ {\n            $lo = $mid + 1;\n        } else if ($left_to_right_cost > $right_to_left_cost)\
    \ {\n            $hi = $mid;\n        } else {\n            return $left_to_right_cost;\n\
    \        }\n    }\n    return $lo * ($lo - 1) / 2;\n}\n$n = 10;\nprint_r(car_race_collision($n));",
  "    // TODO: Fill this in.\n    $collisions = 0;\n    for ($i = 0; $i < $n; $i++)\
    \ {\n        for ($j = 0; $j < $n; $j++) {\n            if ($i == $j) {\n    \
    \            $collisions++;\n            }\n        }\n    }\n    return $collisions;\n\
    }\n\n$n = 3;\necho \"Collisions: \" . car_race_collision($n) . \"\\n\";", "  \
    \  // Write your code here\n}\n", "  // Fill this in.\n  return $n;\n}\n\necho\
    \ car_race_collision(3) . \"\\n\";", "\tif ($n < 2) {\n\t\treturn 0;\n\t}\n\n\t\
    $right_to_left = range(1, $n);\n\t$left_to_right = range($n, 1);\n\n\t$right_to_left_index\
    \ = 0;\n\t$left_to_right_index = 0;\n\t$collisions = 0;\n\n\twhile ($right_to_left_index\
    \ < $n && $left_to_right_index < $n) {\n\t\tif ($right_to_left[$right_to_left_index]\
    \ > $left_to_right[$left_to_right_index]) {\n\t\t\t$right_to_left_index++;\n\t\
    \t\t$left_to_right_index++;\n\t\t\t$collisions++;\n\t\t} else {\n\t\t\t$right_to_left_index++;\n\
    \t\t}\n\t}\n\n\treturn $collisions;\n}\n\necho car_race_collision(5);", "    if\
    \ ($n <= 0) return 0;\n    // Build the two arrays.\n    $cars_left = [];\n  \
    \  $cars_right = [];\n    for ($i = 0; $i < $n; $i++) {\n        $cars_left[]\
    \ = $i;\n        $cars_right[] = $i;\n    }\n    // Shuffle the two arrays.\n\
    \    shuffle($cars_left);\n    shuffle($cars_right);\n    $left_index = 0;\n \
    \   $right_index = 0;\n    $collisions = 0;\n    // Move the cars one at a time,\
    \ while updating the collisions.\n    // Take advantage of the fact that the cars\
    \ are already sorted by\n    // their number.\n    while (count($cars_left) >\
    \ 0 && count($cars_right) > 0) {\n        $current_left = $cars_left[$left_index];\n\
    \        $current_right = $cars_right[$right_index];\n        if ($current_left\
    \ < $current_right) {\n            $cars_left = array_slice($cars_left, $left_index\
    \ + 1);\n            $left_index = 0;\n        } elseif ($current_left > $current_right)\
    \ {\n            $cars_right = array_slice($cars_right, $right_index + 1);\n \
    \           $right_index = 0;\n        } else {\n            // Collision.\n \
    \           $collisions++;\n            $cars_left = array_slice($cars_left, $left_index\
    \ + 1);\n            $cars_right = array_slice($cars_right, $right_index + 1);\n\
    \            $left_index = 0;\n            $right_index = 0;\n        }\n    }\n\
    \    return $collisions;\n}\n", "\t// TODO: your code here.  Please write up a\
    \ nice explanation of why your algorithm is\n\t// correct and how long it takes\
    \ to run in the space below.\n\t$collision = 0;\n\n\tfor ($i = 0; $i < $n; $i++)\
    \ {\n\t\t$collision += ($n - $i - 1);\n\t}\n\n\treturn $collision;\n}\n", "  $total\
    \ = 0;\n  $lefts = [0];\n  $rights = [0];\n  for ($i = 1; $i <= $n; $i++) {\n\
    \    $lefts[] = $lefts[$i - 1] + 1;\n    $rights[] = $rights[$i - 1] + 1;\n  }\n\
    \  $lefts = array_reverse($lefts);\n  $rights = array_reverse($rights);\n  for\
    \ ($i = 1; $i <= $n; $i++) {\n    if ($lefts[$i] == $rights[$i]) {\n      $total++;\n\
    \    }\n  }\n  return $total;\n}\n", "  // your code here\n}", "\t$collisions\
    \ = 0;\n\t$leftToRight = range(1, $n);\n\t$rightToLeft = range($n, 1);\n\tforeach\
    \ ($leftToRight as $num) {\n\t\tforeach ($rightToLeft as $num2) {\n\t\t\tif ($num\
    \ === $num2) {\n\t\t\t\t$collisions += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn $collisions;\n\
    }\n", "    // the n cars driving left to right will hit n cars driving right to\
    \ left\n    return $n;\n}\n", "    return 1;\n}\n", "    // TODO: Implement this\
    \ function.\n}\n", "    $cars = [];\n    $c = 0;\n    $i = 0;\n    while ($i <\
    \ $n) {\n        $car = new Car($i);\n        $cars[] = $car;\n        $i++;\n\
    \    }\n    while (count($cars) > 0) {\n        $i = 0;\n        while ($i < count($cars))\
    \ {\n            $cars[$i]->move();\n            if ($cars[$i]->hits_other_car($cars))\
    \ {\n                $c++;\n            }\n            if ($cars[$i]->get_x()\
    \ > 15 || $cars[$i]->get_x() < -15) {\n                unset($cars[$i]);\n   \
    \         }\n            $i++;\n        }\n        $cars = array_values($cars);\n\
    \    }\n    return $c;\n}\n\nclass Car {\n    private $x;\n    private $l;\n \
    \   private $r;\n    private $id;\n\n    public function __construct($id) {\n\
    \        $this->x = -15;\n        $this->l = true;\n        $this->r = false;\n\
    \        $this->id = $id;\n    }\n\n    public function get_x() {\n        return\
    \ $this->x;\n    }\n\n    public function hits_other_car($cars) {\n        $result\
    \ = false;\n        foreach ($cars as $car) {\n            if ($car->get_x() ==\
    \ $this->x && $car->get_id() != $this->id) {\n                $result = true;\n\
    \            }\n        }\n        return $result;\n    }\n\n    public function\
    \ get_id() {\n        return $this->id;\n    }\n\n    public function set_direction($direction)\
    \ {\n        $this->l = $direction;\n        $this->r = !$direction;\n    }\n\n\
    \    public function move() {\n        if ($this->l) {\n            $this->x++;\n\
    \        } else if ($this->r) {\n            $this->x--;\n        }\n    }\n}\n\
    \nprint car_race_collision(5);", "    return ($n * ($n - 1)) / 2;\n}", "  // TODO:\
    \ implement the function\n  $count = 0;\n  for ($i = 0; $i < $n; $i++){\n    for\
    \ ($j = 0; $j < $n; $j++){\n      if ($i - $j == $n){\n        $count++;\n   \
    \   }\n    }\n  }\n  return $count;\n}\n", "    $total_collisions = 0;\n    //\
    \ Sort both the arrays.\n    $right_to_left = $n;\n    $left_to_right = $n;\n\
    \    $right_to_left = array_merge($right_to_left, $left_to_right);\n    $left_to_right\
    \ = array_merge($left_to_right, $right_to_left);\n    for ($i = 0; $i < count($right_to_left);\
    \ $i++) {\n        for ($j = 0; $j < count($left_to_right); $j++) {\n        \
    \    if ($right_to_left[$i] > $left_to_right[$j]) {\n                $total_collisions\
    \ += 1;\n            }\n        }\n    }\n    return $total_collisions;\n}\n",
  "  // Todo: implement this function\n}\n", "    $collisions = 0;\n    for ($i =\
    \ 0; $i < $n; $i++) {\n        $collisions += $i;\n    }\n    return $collisions;\n\
    }", "    $cars = array();\n    for ($i = 0; $i < $n; $i++) {\n        $cars[$i]\
    \ = $i;\n    }\n    shuffle($cars);\n    shuffle($cars);\n    $i = 0;\n    $j\
    \ = 0;\n    $k = 0;\n    while ($i < $n && $j < $n) {\n        if ($cars[$i] >\
    \ $cars[$j]) {\n            $k++;\n            $i++;\n            $j++;\n    \
    \    } else if ($cars[$i] < $cars[$j]) {\n            $i++;\n        } else {\n\
    \            $j++;\n        }\n    }\n    return $k;\n}\n", "  // your solution\
    \ here\n  $left_to_right = $right_to_left = range(1, $n);\n  $number_of_collisions\
    \ = 0;\n  $i = $j = 0;\n  while ($i < $n && $j < $n) {\n    if ($left_to_right[$i]\
    \ > $right_to_left[$j]) {\n      $number_of_collisions++;\n      $j++;\n    }\
    \ else {\n      $i++;\n    }\n  }\n  return $number_of_collisions;\n}\n", "\t\
    // Your code goes here\n\t$cars = array();\n\tfor ($i = 0; $i < $n; $i++) {\n\t\
    \t$cars[$i] = array('x' => 0, 's' => rand(1, 100));\n\t}\n\t$collisions = 0;\n\
    \t$time = 0;\n\twhile (count($cars) > 0) {\n\t\t$remove = array();\n\t\tforeach\
    \ ($cars as $key => $car) {\n\t\t\t$cars[$key]['x'] += $car['s'];\n\t\t\tif ($cars[$key]['x']\
    \ >= 1000) {\n\t\t\t\t$remove[] = $key;\n\t\t\t}\n\t\t}\n\t\tforeach ($remove\
    \ as $key) {\n\t\t\tunset($cars[$key]);\n\t\t}\n\t\t$time++;\n\t\tif (count($cars)\
    \ == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t$remove = array();\n\t\tforeach ($cars as\
    \ $key => $car) {\n\t\t\t$cars[$key]['x'] -= $car['s'];\n\t\t\tif ($cars[$key]['x']\
    \ <= 0) {\n\t\t\t\t$remove[] = $key;\n\t\t\t}\n\t\t}\n\t\tforeach ($remove as\
    \ $key) {\n\t\t\tunset($cars[$key]);\n\t\t}\n\t\t$time++;\n\t\tif (count($cars)\
    \ == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tforeach ($cars as $key => $car) {\n\t\t\t\
    $collisions += binary_search($cars, $car['x'], 0, $key - 1) + binary_search($cars,\
    \ $car['x'], $key + 1, count($cars) - 1);\n\t\t}\n\t}\n\treturn $collisions;\n\
    }\n", "   return ($n * ($n - 1)) / 2;\n}\necho \"The number of collisions is \"\
    \ . car_race_collision(5) . \".\\n\";", "    // for this algorithm to work, $n\
    \ must be a valid positive integer.\n    if (!is_int($n) || $n <= 0) {\n     \
    \   return false;\n    }\n\n    // initialize variables\n    $collisions = 0;\n\
    \    $reverse_cars = $n;\n    $forward_cars = $n;\n\n    // iterate until all\
    \ forward-moving cars have passed\n    while ($forward_cars > 0) {\n        //\
    \ if a forward-moving car is within distance of a reverse-moving car,\n      \
    \  // a collision occurs\n        if ($reverse_cars > 0) {\n            $collisions++;\n\
    \            $reverse_cars--;\n        }\n        $forward_cars--;\n    }\n\n\
    \    return $collisions;\n}\n", "    // BEGIN (write your solution here)\n   \
    \ $collisions = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            if ($i === $j) {\n                $collisions++;\n\
    \            }\n        }\n    }\n    return $collisions;\n    // END\n}", " \
    \   return $n;\n}\n", "    // Let's simulate the collision.\n    // This function\
    \ checks whether the last car moving left to right \n    // has collided with\
    \ the first car moving right to left.\n    // If so, it returns true.\n    //\
    \ If not, it returns false.\n    // The two arguments are the two sets of cars.\n\
    \    function move_one_sec($left_cars, $right_cars) {\n        if(count($left_cars)==0\
    \ || count($right_cars)==0) {\n            return false;\n        }\n        if($left_cars[count($left_cars)-1]\
    \ >= -$right_cars[0]) {\n            return true;\n        }\n        return false;\n\
    \    }\n    $left_cars = range(1, $n);\n    $right_cars = range(1, $n);\n    $collision_count\
    \ = 0;\n    while(count($left_cars)>0 || count($right_cars)>0) {\n        // If\
    \ there is a collision, increment the collision count\n        // and move the\
    \ car that moves right to left.\n        if(move_one_sec($left_cars, $right_cars))\
    \ {\n            $collision_count += 1;\n            array_shift($right_cars);\n\
    \        }\n        // Else, we will move the car that moves left to right.\n\
    \        else {\n            array_pop($left_cars);\n        }\n    }\n    return\
    \ $collision_count;\n}\n$n = 5;\necho \"Input: \".$n.\"\\n\";\necho \"Output:\
    \ \".car_race_collision($n).\"\\n\";", "    // TODO: Implement me!\n}\n", "  \
    \  $collisions = 0;\n    $left_to_right = [];\n    $right_to_left = [];\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        $left_to_right[] = rand(0, 1000);\n     \
    \   $right_to_left[] = rand(0, 1000);\n    }\n    sort($left_to_right);\n    sort($right_to_left);\n\
    \    for ($i = 0; $i < $n; $i++) {\n        if ($left_to_right[$i] > $right_to_left[$i])\
    \ {\n            $collisions++;\n        }\n    }\n    return $collisions;\n}\n",
  "    // Note that we can imagine the road to be a straight line.  All we have to\
    \ do is to\n    // determine the number of times that some car that's moving right\
    \ to left meets a car\n    // that's moving left to right.  Let's imagine that\
    \ the left-to-right cars are at positions\n    // {A0, A1, ..., An-1} and the\
    \ right-to-left cars are at positions {B0, B1, ..., Bn-1}\n    // in the line.\
    \  If we look at the left-to-right cars, we can see that the possible collisions\n\
    \    // for each of the cars are:\n    //\n    // A0: B0, B1, B2, ...\n    //\
    \ A1: B0, B1, B2, ...\n    // A2: B0, B1, B2, ...\n    // ...\n    //\n    //\
    \ I.e., each left-to-right car can collide with any of the right-to-left cars.\
    \  Thus, it is\n    // clear that the number of collisions is:\n    //\n    //\
    \ A0 * n + A1 * n + A2 * n + ... + An-1 * n\n    //\n    // Let's group the terms\
    \ by the constant n:\n    //\n    // n * (A0 + A1 + A2 + ... + An-1)\n    //\n\
    \    // The terms in the parentheses sum up to n.  Thus, the total number of collisions\
    \ is n * n = n^2.\n    //\n    // The time complexity is O(1), since this is a\
    \ constant-time algorithm.\n    // The space complexity is O(1), since this is\
    \ a constant-space algorithm.\n    return pow($n, 2);\n}", "  $cars = new SplDoublyLinkedList();\n\
    \  for ($i = 0; $i < $n; $i++) {\n    $cars->push($i);\n  }\n  $cars->rewind();\n\
    \  $m = 0;\n  for ($i = 0; $i < $n; $i++) {\n    $car = $cars->current();\n  \
    \  $cars->next();\n    if (!$cars->offsetExists($car)) {\n      continue;\n  \
    \  }\n    while ($cars->offsetExists($car)) {\n      $m++;\n      $cars->offsetUnset($car);\n\
    \      $car++;\n    }\n  }\n  return $m;\n}\n", "  // We use a variable $num_left_to_right_moving_cars\
    \ to keep track of how many cars\n  // are moving left to right.\n  $num_left_to_right_moving_cars\
    \ = 0;\n  // Loop through each car that is moving left to right.\n  for ($i =\
    \ 0; $i < $n; $i++) {\n    // Increase the counter of cars moving left to right\
    \ by 1.\n    $num_left_to_right_moving_cars++;\n    // A car that is moving left\
    \ to right will collide with all of the cars\n    // that are moving right to\
    \ left.  This is because, when a car that's moving\n    // left to right encounters\
    \ a car that's moving right to left, the car moving\n    // left to right will\
    \ continue on its trajectory (as if it never collided).\n    // On the other hand,\
    \ the car moving right to left will move to the car's left,\n    // out of the\
    \ trajectory of the car moving left to right.  That is why, the car\n    // moving\
    \ left to right will encounter all other cars moving right to left.\n    $num_collisions\
    \ += $n - $num_left_to_right_moving_cars;\n  }\n  return $num_collisions;\n}\n",
  "    $d = 1;\n    $p = 1;\n    $t = 0;\n    while ($n > 0) {\n        $t += ($d\
    \ - $p) * $n;\n        $d++;\n        $p *= 2;\n        $n /= 2;\n    }\n    return\
    \ $t;\n}\n", "    // First, construct the array $left_to_right that is of size\
    \ $n+1, where $left_to_right[i] = true\n    // if car i+1 is moving left to right.\n\
    \    $left_to_right = array();\n    for ($i = 0; $i < $n+1; $i++) {\n        $left_to_right[$i]\
    \ = true;\n    }\n    $num_collisions = 0;\n    $num_cars_driving_left_to_right\
    \ = $n;\n    $num_cars_driving_right_to_left = $n;\n    while ($num_cars_driving_left_to_right\
    \ > 0 and $num_cars_driving_right_to_left > 0) {\n        // At this point,\n\
    \        // i) $num_cars_driving_left_to_right is the number of cars that are\n\
    \        // still driving left to right.\n        // ii) $num_cars_driving_right_to_left\
    \ is the number of cars that are\n        // still driving right to left.\n  \
    \      // iii) $left_to_right[i] is true if car i+1 is still driving left to right,\n\
    \        // and false otherwise.\n        // Find the total number of collisions\
    \ that have occurred so far.\n        // (Hint:  There is an efficient algorithm\
    \ to compute this in O(n) time\n        // rather than O(n^2).)\n        $num_collisions\
    \ += $num_cars_driving_left_to_right;\n        // Next, let's run one time step,\
    \ during which all cars that are still\n        // driving move 1 unit forward.\n\
    \        // 1. First, mark the cars driving left to right that have collided as\
    \ no longer driving left to right.\n        for ($i = 0; $i < $n+1; $i++) {\n\
    \            if ($left_to_right[$i]) {\n                $left_to_right[$i] = false;\n\
    \                $num_cars_driving_left_to_right--;\n            }\n        }\n\
    \        // 2. Next, mark the cars driving right to left that have collided as\
    \ no longer driving right to left.\n        // (Hint:", "\t// Your code here\n\
    \t// Fill this out and submit it to the Collabedit site.\n}", "\treturn $n * ($n\
    \ - 1) / 2;\n}\n", "    $collisions = 0;\n    // TODO\n    // echo $collisions;\n\
    }", "    $num_collisions = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for\
    \ ($j = 0; $j < $n; $j++) {\n            $num_collisions++;\n        }\n    }\n\
    \    return $num_collisions;\n}\n", "    // This function's output is bounded\
    \ by the absolute value of n,\n    // as n cars cannot collide with more than\
    \ n cars in another direction.\n    // Therefore, the output's magnitude should\
    \ be O(n).\n    // Furthermore, it should be O(1) to insert each element into\
    \ the hash table\n    // and to check for collisions.\n    // Therefore, the total\
    \ complexity is O(n).\n    $cars = [];\n    for ($i = 0; $i < $n; $i++) {\n  \
    \      $cars[$i] = [\n            'position' => 0,\n            'direction' =>\
    \ 1,\n        ];\n    }\n    for ($i = $n; $i < 2 * $n; $i++) {\n        $cars[$i]\
    \ = [\n            'position' => 0,\n            'direction' => -1,\n        ];\n\
    \    }\n    $collisions = 0;\n    while (count($cars) > 0) {\n        $new_cars\
    \ = [];\n        foreach ($cars as $car) {\n            $car['position'] += $car['direction'];\n\
    \            if (array_key_exists($car['position'], $new_cars)) {\n          \
    \      $collisions++;\n            } else {\n                $new_cars[$car['position']]\
    \ = $car;\n            }\n        }\n        $cars = $new_cars;\n    }\n    return\
    \ $collisions;\n}\n", "    $left_to_right = [];\n    $right_to_left = [];\n  \
    \  for ($i = 0; $i < $n; $i++) {\n        $left_to_right[] = $i;\n        $right_to_left[]\
    \ = $i;\n    }\n    shuffle($left_to_right);\n    shuffle($right_to_left);\n \
    \   $collisions = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($left_to_right[$i]\
    \ == $right_to_left[$i]) {\n            $collisions++;\n        }\n    }\n   \
    \ return $collisions;\n}\n", "   $no_of_cars_moving_left = $n;\n   $no_of_cars_moving_right\
    \ = $n;\n   $collisions = 0;\n   for ($i = 0; $i < $n; $i++) {\n      if ($no_of_cars_moving_left\
    \ > 0 && $no_of_cars_moving_right > 0) {\n         $collisions += ($no_of_cars_moving_left\
    \ * $no_of_cars_moving_right);\n      }\n      $no_of_cars_moving_left--;\n  \
    \    $no_of_cars_moving_right--;\n   }\n   return $collisions;\n}", "    $count\
    \ = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}\n", "    if\
    \ ($n == 0) {\n        return 0;\n    }\n    return car_race_collision($n - 1)\
    \ + $n - 1;\n}\n", "    // Solution:\n    // The collision occurs when a car from\
    \ the left passes the car from the right.\n    // The left cars are numbered from\
    \ 1 to n, where n is the count of the left cars.\n    // The right cars are also\
    \ numbered from 1 to n, where n is the count of the right cars.\n    // The collision\
    \ occurs only when the number of the left car is equal to the number of the right\
    \ car.\n    // For example, if there are 4 left cars and 4 right cars, then the\
    \ collisions will occur when the numbers of\n    // the cars are the same.\n \
    \   // Therefore, the total count of collisions will be the sum of the car numbers.\n\
    \    // For example, if there are 4 left cars and 4 right cars, then the total\
    \ count of collisions will be:\n    // 1 + 2 + 3 + 4 = 10\n    $sum = 0;\n   \
    \ for ($i = 1; $i <= $n; $i++) {\n        $sum += $i;\n    }\n    return $sum;\n\
    }\n", "\t// number of cars\n\t//$numberOfCars = $n;\n\t// left to right\n\t$carStartPos\
    \ = array();\n\t// right to left\n\t$carEndPos = array();\n\t// collision count\n\
    \t$collision = 0;\n\t\n\t// initialize $carStartPos to 1,2,3,...,n\n\tfor ($i\
    \ = 0; $i < $n; $i++) {\n\t\t$carStartPos[$i] = $i + 1;\n\t}\n\t// initialize\
    \ $carEndPos to n,n-1,n-2,...,1\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$carEndPos[$i]\
    \ = $n - $i;\n\t}\n\t\n\t// find collisions\n\tfor ($i = 0; $i < $n; $i++) {\n\
    \t\t// loop through the $carEndPos array\n\t\tfor ($j = 0; $j < $n; $j++) {\n\t\
    \t\t// if $carStartPos[$i] == $carEndPos[$j]\n\t\t\tif ($carStartPos[$i] == $carEndPos[$j])\
    \ {\n\t\t\t\t// increment collision count\n\t\t\t\t$collision++;\n\t\t\t}\n\t\t\
    }\n\t}\n\t// return the collision count\n\treturn $collision;\n}\n", "  $l2r =\
    \ array();\n  $r2l = array();\n  $collision_count = 0;\n  for ($i = 0; $i < $n;\
    \ $i++) {\n    $l2r[] = rand(1, 1000000000);\n    $r2l[] = rand(1, 1000000000);\n\
    \  }\n  sort($l2r);\n  sort($r2l);\n  $l2r_p = 0;\n  $r2l_p = 0;\n  $end_l2r =\
    \ count($l2r) - 1;\n  $end_r2l = count($r2l) - 1;\n  while ($l2r_p <= $end_l2r\
    \ && $r2l_p <= $end_r2l) {\n    if ($l2r[$l2r_p] <= $r2l[$r2l_p]) {\n      $l2r_p++;\n\
    \    } else {\n      $collision_count += $end_l2r - $l2r_p + 1;\n      $r2l_p++;\n\
    \    }\n  }\n  return $collision_count;\n}\n\nvar_dump(car_race_collision(1000));",
  "\t$t = ceil($n/2);\n\treturn $t;\n}\n", "    $numOfCollisions = 0;\n    $leftToRight\
    \ = [];\n    $rightToLeft = [];\n    for ($i = 0; $i < $n; $i++) {\n        //\
    \ generates an integer from 0 to 1,000,000 inclusive\n        $leftToRight[] =\
    \ rand(0,1000000);\n        $rightToLeft[] = rand(0,1000000);\n    }\n    sort($leftToRight);\n\
    \    sort($rightToLeft);\n    $leftToRightIndex = 0;\n    $rightToLeftIndex =\
    \ 0;\n    while ($leftToRightIndex < $n && $rightToLeftIndex < $n) {\n       \
    \ if ($leftToRight[$leftToRightIndex] < $rightToLeft[$rightToLeftIndex]) {\n \
    \           $leftToRightIndex++;\n        } else if ($leftToRight[$leftToRightIndex]\
    \ > $rightToLeft[$rightToLeftIndex]) {\n            $rightToLeftIndex++;\n   \
    \     } else {\n            $numOfCollisions++;\n            $leftToRightIndex++;\n\
    \            $rightToLeftIndex++;\n        }\n    }\n    return $numOfCollisions;\n\
    }\n", "    $left_pos = [];\n    $right_pos = [];\n    $left_idx = 0;\n    $right_idx\
    \ = 0;\n    for ($i = 0; $i < $n; $i++) {\n        // a car starting at 0 is supposed\
    \ to collide with a car\n        // starting at n-1.  In general, a car starting\
    \ at k should\n        // collide with a car starting at n-1-k.\n        $left_pos[$i]\
    \ = $i;\n        $right_pos[$i] = $n - 1 - $i;\n    }\n    $collisions = 0;\n\
    \    $left_idx = 0;\n    $right_idx = 0;\n    while ($left_idx < $n && $right_idx\
    \ < $n) {\n        if ($left_pos[$left_idx] > $right_pos[$right_idx]) {\n    \
    \        $left_idx++;\n        } else if ($left_pos[$left_idx] < $right_pos[$right_idx])\
    \ {\n            $right_idx++;\n        } else {\n            $collisions++;\n\
    \            $left_idx++;\n            $right_idx++;\n        }\n    }\n    return\
    \ $collisions;\n}", "    $r2l = array(); // r2l = car that moves right to left.\n\
    \    $l2r = array(); // l2r = car that moves left to right.\n    for ($i = 0;\
    \ $i < $n; $i++) {\n        $r2l[] = $i;\n        $l2r[] = $i;\n    }\n    $num_collisions\
    \ = 0;\n    $i = 0;\n    $j = 0;\n    while ($i < $n && $j < $n) {\n        if\
    \ ($r2l[$i] > $l2r[$j]) {\n            $num_collisions++;\n            $i++;\n\
    \            $j++;\n        } else {\n            $i++;\n        }\n    }\n  \
    \  return $num_collisions;\n}", "    if ($n == 0) return 0;\n    return $n - 1\
    \ + car_race_collision($n - 1);\n}\n", "    $left_to_right = [];\n    $right_to_left\
    \ = [];\n    for ($i = 0; $i < $n; $i++) {\n        $left_to_right[] = mt_rand(0,\
    \ 100000);\n        $right_to_left[] = mt_rand(0, 100000);\n    }\n    sort($left_to_right);\n\
    \    sort($right_to_left);\n    $collisions = 0;\n    $left_pos = 0;\n    $right_pos\
    \ = $n - 1;\n    while ($left_pos < $n && $right_pos >= 0) {\n        if ($left_to_right[$left_pos]\
    \ > $right_to_left[$right_pos]) {\n            $collisions++;\n            $left_pos++;\n\
    \            $right_pos--;\n        } else {\n            $left_pos++;\n     \
    \   }\n    }\n    return $collisions;\n}", "    $collisions = 0;\n    $l_cars\
    \ = range(1, $n);\n    $r_cars = range($n + 1, 2 * $n);\n    for ($i = 0; $i <\
    \ $n; $i++) {\n        $l_car = $l_cars[$i];\n        $r_car = $r_cars[$i];\n\
    \        $l_start = $l_car - $i;\n        $r_start = $r_car - $i;\n        $collisions\
    \ += max($l_start, $r_start);\n    }\n    return $collisions;\n}\n", "    $left\
    \ = 0;\n    $right = 0;\n    $collision = 0;\n    while ($left < $n || $right\
    \ < $n) {\n        if ($left < $n) {\n            $left++;\n        }\n      \
    \  if ($right < $n) {\n            $right++;\n        }\n        if ($left ==\
    \ $right) {\n            $collision++;\n        }\n    }\n    return $collision;\n\
    }\necho car_race_collision(3);", "\t// Your code here...\n}\n", "\t$collisions\
    \ = 0;\n\t$left_array = array();\n\t$right_array = array();\n\tfor ($i = 0; $i\
    \ < $n; $i++) {\n\t\t$left_array[$i] = rand();\n\t\t$right_array[$i] = rand();\n\
    \t}\n\t$left_array = quick_sort($left_array);\n\t$right_array = quick_sort($right_array);\n\
    \t$i = 0;\n\t$j = 0;\n\twhile ($i < $n && $j < $n) {\n\t\tif ($left_array[$i]\
    \ < $right_array[$j]) {\n\t\t\t$i++;\n\t\t} else {\n\t\t\t$j++;\n\t\t\t$collisions\
    \ += $i;\n\t\t}\n\t}\n\treturn $collisions;\n}\n", "    $collisions = 0;\n   \
    \ $left_to_right = range(1, $n);\n    $right_to_left = range($n + 1, 2 * $n);\n\
    \    while ($left_to_right[0] < $right_to_left[0]) {\n        if ($left_to_right[0]\
    \ < $right_to_left[0]) {\n            array_shift($left_to_right);\n        }\
    \ else {\n            array_shift($right_to_left);\n        }\n        $collisions++;\n\
    \    }\n    return $collisions;\n}\n$n = 10;\necho car_race_collision($n);", " \
    \ $collisions = 0;\n  $left = array();\n  $right = array();\n  for ($i = 0; $i\
    \ < $n; $i++) {\n    $left[$i] = $i;\n    $right[$i] = $n + $i;\n  }\n  // Simulate\
    \ cars moving from left to right and from right to left.\n  for ($i = 0; $i <\
    \ 2 * $n; $i++) {\n    if (in_array($i, $left)) {\n      foreach ($right as $key\
    \ => $value) {\n        if ($value == $i) {\n          unset($right[$key]);\n\
    \          $collisions++;\n          break;\n        }\n      }\n    }\n    if\
    \ (in_array($i, $right)) {\n      foreach ($left as $key => $value) {\n      \
    \  if ($value == $i) {\n          unset($left[$key]);\n          $collisions++;\n\
    \          break;\n        }\n      }\n    }\n  }\n  return $collisions;\n}\n\n\
    assert(car_race_collision(2) == 4);\nassert(car_race_collision(3) == 6);\nassert(car_race_collision(4)\
    \ == 8);\nassert(car_race_collision(5) == 10);\nassert(car_race_collision(10)\
    \ == 20);\nassert(car_race_collision(100) == 200);\nassert(car_race_collision(PHP_INT_MAX)\
    \ == 2 * PHP_INT_MAX);\n\n$i = 100;\n$time_start = microtime(true);\ncar_race_collision($i);\n\
    $time_end = microtime(true);\n$time = $time_end - $time_start;\nprintf(\"%s: %f\\\
    n\", $i, $time);", "\t$n = intval($n);\n\tif ($n < 1) return 0;\n\tif ($n == 1)\
    \ return 1;\n\t// From the problem definition, this is equivalent to counting\n\
    \t// the number of pairs of cars whose indices differ by 1.\n\t// which is the\
    \ same as counting the number of pairs of cars whose\n\t// indices sum to n. \
    \ This is the same as the number of diagonals\n\t// in an n x n grid, which is\
    \ (n*(n-1))/2 = n*(n-1)/2.\n\treturn ($n * ($n - 1)) / 2;\n}\n\necho car_race_collision(5)\
    \ . \"\\n\";\necho car_race_collision(100) . \"\\n\";\necho car_race_collision(4999)\
    \ . \"\\n\";\necho car_race_collision(5000) . \"\\n\";\necho car_race_collision(5001)\
    \ . \"\\n\";\necho car_race_collision(1) . \"\\n\";\necho car_race_collision(2)\
    \ . \"\\n\";\necho car_race_collision(3) . \"\\n\";\necho car_race_collision(0)\
    \ . \"\\n\";\necho car_race_collision(-50) . \"\\n\";", "    // Since the cars\
    \ are infinitely strong, the collisions will never stop.\n    // Eventually all\
    \ cars will collide with each other.  Thus the number of\n    // collisions will\
    \ be n^2, assuming there are n cars on each side of the road.\n    // As an aside,\
    \ note that the number of collisions will be the same if we\n    // have n cars\
    \ moving in both directions.\n    return $n * $n;\n}", "    return ($n * ($n -\
    \ 1)) / 2;\n}\n", "    if ($n <= 0) {\n        return 0;\n    }\n    if ($n ==\
    \ 1) {\n        return 0;\n    }\n    if ($n == 2) {\n        return 1;\n    }\n\
    \    $fact = 1;\n    $nFact = 1;\n    for ($i = 2; $i <= $n; $i++) {\n       \
    \ $fact *= $i;\n        $nFact *= ($n + $i);\n    }\n    $nFact = $nFact / $fact;\n\
    \    $result = $nFact - $n;\n    return $result;\n}\n", "    $collisions = 0;\n\
    \    // TODO\n    //1. move all cars to the right, array length $n\n    //2. move\
    \ all cars to the left, array length $n\n    //3. when car values are equal, collision!\
    \  increment value by 1\n    $left_to_right = $n;\n    $right_to_left = $n;\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $left_to_right[$i] = $i;\n       \
    \ $right_to_left[$i] = $n - $i;\n    }\n    for ($i = 0; $i < $n; $i++) {\n  \
    \      for ($j = 0; $j < $n; $j++) {\n            if ($left_to_right[$i] == $right_to_left[$j])\
    \ {\n                $collisions += 1;\n            }\n        }\n    }\n    return\
    \ $collisions;\n}\n", "    return ($n * ($n - 1)) / 2;\n}\n", "  // intialize\
    \ the array of hashes to store the position of all left-to-right cars.\n  $left\
    \ = array();\n  // initialze the array of hashes to store the position of all\
    \ right-to-left cars.\n  $right = array();\n  // generate $n*2 (n sets of 2 cars)\
    \ cars at random position\n  // and assign the initial positions to be the keys\
    \ of the hashes.\n  for ($i = 0; $i < $n*2; $i++) {\n    $left[floor(mt_rand(0,\
    \ $n*2))] = 1;\n    $right[floor(mt_rand(0, $n*2))] = 1;\n  }\n  // intialize\
    \ the count of collisions to be 0.\n  $count = 0;\n  // for each set of 2 cars,\
    \ move the car from left to right 1 unit.\n  for ($i = 0; $i < $n*2; $i++) {\n\
    \    // get the position of the left-to-right car\n    $pos = array_keys($left)[$i];\n\
    \    // if the position of the left-to-right car is already in the hash of right-to-left\
    \ cars,\n    // then it has collided with a right-to-left car.\n    if (isset($right[$pos]))\
    \ {\n      // increment the collision count.\n      $count++;\n    }\n    // increment\
    \ the position of the left-to-right car by 1.\n    $left[$pos]++;\n  }\n  // return\
    \ the count of collisions.\n  return $count;\n}\n\necho car_race_collision(10)\
    \ . \"\\n\";", "    $collisions = 0;\n    $left_to_right = $right_to_left = [];\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $left_to_right[] = rand(0, 100);\n\
    \        $right_to_left[] = rand(0, 100);\n    }\n    $left_to_right = $right_to_left\
    \ = [1,1,2,2,3,3,4,4,6,8,9,10,12,12,13,13,14,14,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16",
  "    $car_A = [];\n    $car_B = [];\n    $collision = 0;\n    // fill car_A with\
    \ a's and car_B with b's\n    for ($i = 0; $i < $n; $i++) {\n        $car_A[]\
    \ = \"a\";\n        $car_B[] = \"b\";\n    }\n    // count collisions\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n         \
    \   if ($car_A[$i] === $car_B[$j]) {\n                $collision++;\n        \
    \    }\n        }\n    }\n    return $collision;\n}\n", "    $num_collisions =\
    \ 0;\n    $n_squared = $n * $n;\n    for ($i = 0; $i < $n_squared; $i++) {\n \
    \       $num_collisions++;\n    }\n    return $num_collisions;\n}\n", "    return\
    \ ($n*($n-1))/2;\n}\n", "    $collisions = 0;\n    $a = range(1, $n); // left-to-right\
    \ cars\n    $b = range($n, 1); // right-to-left cars\n    while (count($a) > 0\
    \ && count($b) > 0) {\n        $a_max = array_pop($a);\n        $b_max = array_pop($b);\n\
    \        if ($a_max === $b_max) {\n            $collisions++;\n        } elseif\
    \ ($a_max > $b_max) {\n            $a[] = $a_max;\n        } else {\n        \
    \    $b[] = $b_max;\n        }\n    }\n    return $collisions;\n}\n\n$ans = car_race_collision(5);\n\
    echo $ans.\"\\n\";\n$ans = car_race_collision(6);\necho $ans.\"\\n\";\n$ans =\
    \ car_race_collision(4);\necho $ans.\"\\n\";\n", "  $count = 0;\n  for ($i = 0;\
    \ $i < $n; $i++) {\n    for ($j = 0; $j < $n; $j++) {\n      if ($i < $j) {\n\
    \        $count++;\n      }\n    }\n  }\n  return $count;\n}\n", "  ///////////////////////////////////////////////////////////////////////////\n\
    \  // Write your code below this line.\n  ///////////////////////////////////////////////////////////////////////////\n\
    \  $collision = 0;\n  $cars = array();\n  // create an array that contains the\
    \ positions of all cars, 1 to n\n  for ($i = 1; $i <= $n; $i++) {\n    $cars[$i]\
    \ = array();\n    $cars[$i]['position'] = $i;\n    $cars[$i]['direction'] = 1;\n\
    \  }\n  $cars = array_reverse($cars);\n  // flip the array so that car 1 is now\
    \ moving right and car n is moving left\n  for ($i = 1; $i <= $n; $i++) {\n  \
    \  $cars[$i]['direction'] = -1;\n  }\n  $movement = true;\n  // keep moving the\
    \ cars until the last car's position equals 1\n  while ($movement) {\n    $movement\
    \ = false;\n    for ($i = 1; $i <= $n; $i++) {\n      // check to see if the current\
    \ car has a position of 1; if so, then break out of this\n      // for loop, because\
    \ that car won't move anymore\n      if ($cars[$i]['position'] == 1) {\n     \
    \   break;\n      }\n      else {\n        // check to see if the current car's\
    \ position has been hit by another car\n        if ($cars[$i]['position'] == $cars[$i-1]['position'])\
    \ {\n          $collision++;\n        }\n        // move the current car\n   \
    \     $cars[$i]['position'] = $cars[$i]['position'] + $cars[$i]['direction'];\n\
    \        $movement = true;\n      }\n    }\n  }\n  return $collision;\n  ///////////////////////////////////////////////////////////////////////////\n\
    \  // Write your code above this line.\n  ///////////////////////////////////////////////////////////////////////////\n\
    }\n", "\t$ret = $n * ($n - 1) / 2;\n\t$left = $n;\n\t$right = $n;\n\tfor ($i =\
    \ 0; $i < $n; $i++) {\n\t\t$ret -= $left * $right;\n\t\t$left--;\n\t\t$right--;\n\
    \t}\n\treturn $ret;\n}\n", "    if ($n <= 1) return 0;\n    $numCollisions = 0;\n\
    \    $ahead = array(); // right-to-left cars that are ahead (to the left) of a\
    \ left-to-right car\n    // Process cars moving left to right\n    for ($i = 0;\
    \ $i < $n; $i++) {\n        $numCollisions += $ahead[$i];\n        $ahead[$i +\
    \ 1] = $ahead[$i] + 1;\n    }\n    return $numCollisions;\n}\n", "    return floor($n/2);\n\
    }\n\necho 'res = '.car_race_collision(8).\"\\n\";\necho 'res = '.car_race_collision(13).\"\
    \\n\";\necho 'res = '.car_race_collision(16).\"\\n\";\necho 'res = '.car_race_collision(1).\"\
    \\n\";\necho 'res = '.car_race_collision(10000).\"\\n\";\n", "    if($n < 1) {\n\
    \        return 0;\n    }\n    $collisions = 0;\n    $left = 0;\n    $right =\
    \ $n - 1;\n    $left_travelled = 0;\n    $right_travelled = 0;\n    while($left\
    \ < $right) {\n        $left_travelled += $left;\n        $right_travelled +=\
    \ $right;\n        $left++;\n        $right--;\n        if($left_travelled ===\
    \ $right_travelled) {\n            $collisions++;\n        }\n    }\n    return\
    \ $collisions;\n}", "    // Your code here.\n}\n", "\t$right=1;\n\t$left=$n;\n\
    \t$total=0;\n\twhile($right<=$n) {\n\t\tif($right==$left) {\n\t\t\t$total++;\n\
    \t\t}\n\t\t$right++;\n\t\t$left--;\n\t}\n\treturn $total;\n}\n", "    // We will\
    \ be creating a new array for each car coming from the left, and each car\n  \
    \  // coming from the right.  If we don't have a lot of cars, this will be O(n^2)\
    \ space.\n    // Regardless, it is O(n^2) time.\n    $leftCars = [];\n    $rightCars\
    \ = [];\n    // All cars coming from the left will begin at 0\n    for ($i = 0;\
    \ $i < $n; $i++) {\n        $leftCars[] = 0;\n    }\n    // All cars coming from\
    \ the right will begin at $n\n    for ($i = 0; $i < $n; $i++) {\n        $rightCars[]\
    \ = $n;\n    }\n    // We will move all cars in the same direction by one unit.\
    \  Because we know\n    // each car is moving at the same speed, every move will\
    \ be equivalent.\n    $numCollisions = 0;\n    while (count($leftCars) > 0 &&\
    \ count($rightCars) > 0) {\n        // We want to know if the left car is going\
    \ to crash into the right car\n        // We will iterate over the left car array\
    \ and check against each of the cars\n        // in the right array.  If the car\
    \ is to the right of the right array car,\n        // then that means the right\
    \ car will hit the left car.\n        // We will move the left car by one unit.\n\
    \        foreach ($leftCars as $leftKey => $leftCar) {\n            $leftCar++;\n\
    \            $leftCars[$leftKey] = $leftCar;\n            foreach ($rightCars\
    \ as $rightKey => $rightCar) {\n                if ($leftCar >= $rightCar) {\n\
    \                    // There is a collision.  We will increment our collision\
    \ count,\n                    // and remove the right car (because we know it's\
    \ already been hit).\n                    // Since the left car will continue\
    \ moving forward, we will not\n                    // remove it.\n           \
    \         $numCollisions++;\n                    unset($rightCars[$rightKey]);\n\
    \                }\n            }\n        }\n        // We will do the same for\
    \ the right car array.\n        foreach ($rightCars as $rightKey => $", "  $car_l2r\
    \ = $car_r2l = array();\n  $start_l2r = 0;\n  $start_r2l = $n;\n  for ($i = 0;\
    \ $i < $n; $i++) {\n    array_push($car_l2r, $start_l2r++);\n    array_push($car_r2l,\
    \ $start_r2l--);\n  }\n  //print_r($car_l2r);\n  //print_r($car_r2l);\n  $collision\
    \ = 0;\n  while ($n > 0) {\n    $car_l2r_pos = array_shift($car_l2r);\n    $car_r2l_pos\
    \ = array_shift($car_r2l);\n    if ($car_l2r_pos >= $car_r2l_pos) {\n      //echo\
    \ \"collision: $car_l2r_pos, $car_r2l_pos \\n\";\n      $collision++;\n    }\n\
    \    else {\n      array_push($car_l2r, $car_l2r_pos);\n      array_push($car_r2l,\
    \ $car_r2l_pos);\n    }\n    $n--;\n  }\n  return $collision;\n}\n\necho car_race_collision(4)\
    \ . \"\\n\"; // 2\necho car_race_collision(5) . \"\\n\"; // 5\necho car_race_collision(6)\
    \ . \"\\n\"; // 9\necho car_race_collision(7) . \"\\n\"; // 14\n", "    if ($n\
    \ <= 1) return 0;\n    $collision = 0;\n    $half_n = intval($n / 2);\n    if\
    \ ($n % 2 == 0) {\n        $half_n -= 1;\n    }\n    for ($i = 0; $i <= $half_n;\
    \ $i++) {\n        $collision += $i;\n    }\n    return $collision;\n}\n", " \
    \   // TODO: insert your code here.\n    if ($n <= 1) {\n        return 0;\n \
    \   }\n    return $n * ($n - 1);\n}", "    $leftToRight = [];\n    $rightToLeft\
    \ = [];\n    for ($i = 0; $i < $n; $i++) {\n        $leftToRight[] = rand(0, 100);\n\
    \        $rightToLeft[] = rand(0, 100);\n    }\n    sort($leftToRight);\n    sort($rightToLeft);\n\
    \    //echo 'Left to right: ' . implode(', ', $leftToRight) . PHP_EOL;\n    //echo\
    \ 'Right to left: ' . implode(', ', $rightToLeft) . PHP_EOL;\n    $leftToRightPointer\
    \ = 0;\n    $rightToLeftPointer = 0;\n    $collisions = 0;\n    while (true) {\n\
    \        if ($leftToRightPointer >= count($leftToRight) || $rightToLeftPointer\
    \ >= count($rightToLeft)) {\n            break;\n        }\n        if ($leftToRight[$leftToRightPointer]\
    \ < $rightToLeft[$rightToLeftPointer]) {\n            $leftToRightPointer++;\n\
    \        } else {\n            $rightToLeftPointer++;\n            $collisions\
    \ += $leftToRightPointer;\n        }\n    }\n    return $collisions;\n}\n\necho\
    \ car_race_collision(10) . PHP_EOL;\necho car_race_collision(100) . PHP_EOL;\n\
    echo car_race_collision(1000) . PHP_EOL;\necho car_race_collision(10000) . PHP_EOL;\n\
    echo car_race_collision(100000) . PHP_EOL;\necho car_race_collision(1000000) .\
    \ PHP_EOL;\necho car_race_collision(10000000) . PHP_EOL;\n", "    // Write your\
    \ code here\n    // To debug (equivalent to var_dump): error_log(var_export($var,\
    \ true));\n    if ($n == 0) {\n        return 0;\n    }\n    $left_to_right =\
    \ array();\n    $right_to_left = array();\n    for ($i = 0; $i < $n; $i++) {\n\
    \        $left_to_right[] = -1 * $i;\n        $right_to_left[] = $i;\n    }\n\
    \    $collisions = 0;\n    $left_to_right_pos = 0;\n    $right_to_left_pos = 0;\n\
    \    while (1) {\n        $left_to_right_pos = count($left_to_right) - 1;\n  \
    \      $right_to_left_pos = count($right_to_left) - 1;\n        $left_to_right_car\
    \ = $left_to_right[$left_to_right_pos];\n        $right_to_left_car = $right_to_left[$right_to_left_pos];\n\
    \        if ($left_to_right_car >= $right_to_left_car) {\n            // Pass\
    \ left to right car\n            unset($left_to_right[$left_to_right_pos]);\n\
    \            // error_log(var_export($left_to_right, true));\n            // error_log(var_export($right_to_left,\
    \ true));\n            continue;\n        }\n        // error_log(var_export($left_to_right,\
    \ true));\n        // error_log(var_export($right_to_left, true));\n        $collisions++;\n\
    \        // Collision, remove both cars\n        unset($left_to_right[$left_to_right_pos]);\n\
    \        unset($right_to_left[$right_to_left_pos]);\n        if (count($left_to_right)\
    \ == 0 && count($right_to_left) == 0) {\n            break;\n        }\n    }\n\
    \    return $collisions;\n}", "    $collisions = 0;\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        $collisions += $i;\n    }\n    return $collisions;\n}\n", " \
    \ $cars_left = 0;\n  $cars_right = 0;\n  for ($i = 0; $i < $n; $i++) {\n    $cars_left++;\n\
    \    $cars_right++;\n    if ($cars_left > 0) {\n      $cars_left--;\n    }\n \
    \   if ($cars_right > 0) {\n      $cars_right--;\n    }\n  }\n  return $cars_left\
    \ * $cars_right;\n}\n", "    // 1. Calculate the distance between two sets of\
    \ cars. \n    // 2. A car moving left to right will collide with another car moving\
    \ right to left when\n    // the distance between the two cars becomes 0. \n \
    \   // 3. A car moving left to right can collide with up to n cars moving right\
    \ to left. \n    // 4. On the other hand, a car moving right to left can collide\
    \ with up to n-1 cars\n    // moving left to right.  The nth car moving left to\
    \ right cannot collide with\n    // it.\n    $distance = ($n*$n-1)/2;\n    return\
    \ $distance;\n}\n\necho car_race_collision(5);", "\t// given the size of the sets,\
    \ this is an O(n^2) algorithm\n\t// if n is large, that could become problematic.\
    \  But you\n\t// have to start somewhere.\n\t$collisions = 0;\n\t$cars_left_to_right\
    \ = $cars_right_to_left = range(1, $n);\n\tforeach ($cars_left_to_right as $left_right_car)\
    \ {\n\t\tforeach ($cars_right_to_left as $right_left_car) {\n\t\t\tif ($left_right_car\
    \ == $right_left_car) {\n\t\t\t\t$collisions++;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ $collisions;\n}\n\n$tests = array(\n\t1,\n\t2,\n\t3,\n\t10,\n\t100,\n\t1000,\n\
    \t10000,\n\t100000,\n\t1000000,\n\t10000000,\n\t100000000,\n\t1000000000,\n);\n\
    foreach ($tests as $test) {\n\techo car_race_collision($test) . \"\\n\";\n}",
  "  $left = array();\n  $right = array();\n  for ($i = 0; $i < $n; $i++) {\n    $left[]\
    \ = 0;\n    $right[] = $n - 1 - $i;\n  }\n  return car_race_collision_helper($left,\
    \ $right);\n}\n", "\t// for every car on one side, how many cars does it collide\
    \ with\n\t// on the other side\n\t// i.e. car 1 on the left side collides with\
    \ n - 1 cars on the right side\n\t$num_collisions = ($n * ($n - 1)) / 2;\n\treturn\
    \ $num_collisions;\n}\n", "\tif ( $n == 0 ) {\n\t\treturn 0;\n\t}\n\n\t$collisions\
    \ = 0;\n\t$left_to_right = array();\n\t$right_to_left = array();\n\n\t// Create\
    \ n cars moving left to right\n\tfor ( $i = 0; $i < $n; $i++ ) {\n\t\t$left_to_right[]\
    \ = array(\n\t\t\t'start' => $i * 10,\n\t\t\t'end' => ( $i + 1 ) * 10\n\t\t);\n\
    \t}\n\n\t// Create n cars moving right to left\n\tfor ( $i = 0; $i < $n; $i++\
    \ ) {\n\t\t$right_to_left[] = array(\n\t\t\t'start' => ( $n - $i ) * 10,\n\t\t\
    \t'end' => ( $n - $i - 1 ) * 10\n\t\t);\n\t}\n\n\t// Check for collisions\n\t\
    for ( $i = 0; $i < $n; $i++ ) {\n\t\tfor ( $j = 0; $j < $n; $j++ ) {\n\t\t\tif\
    \ ( $left_to_right[$i]['start'] <= $right_to_left[$j]['end'] &&\n\t\t\t\t $left_to_right[$i]['end']\
    \ >= $right_to_left[$j]['start'] ) {\n\t\t\t\t$collisions++;\n\t\t\t}\n\t\t}\n\
    \t}\n\n\treturn $collisions;\n}\n", "    // Put your solution here\n    $colision\
    \ = $n/2;\n    return $colision;\n}\necho car_race_collision(1);\necho car_race_collision(2);\n\
    echo car_race_collision(3);\necho car_race_collision(4);\necho car_race_collision(5);\n\
    echo car_race_collision(6);\necho car_race_collision(7);\necho car_race_collision(8);\n\
    echo car_race_collision(9);\necho car_race_collision(10);\necho car_race_collision(100);\n\
    echo car_race_collision(1000);\necho car_race_collision(10000);\necho car_race_collision(100000);\n\
    echo car_race_collision(1000000);\necho car_race_collision(10000000);\necho car_race_collision(100000000);\n\
    echo car_race_collision(1000000000);\n", "    // TODO: Implement the solution\
    \ here.\n}\n", "    $cars = [];\n    for ($i = 0; $i < $n; $i++) {\n        $cars[]\
    \ = ['going' => 'left', 'speed' => $i];\n        $cars[] = ['going' => 'right',\
    \ 'speed' => $i];\n    }\n    $num_collisions = 0;\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($cars[$i]['going']\
    \ === 'left' && $cars[$j]['going'] === 'right') {\n                if ($cars[$i]['speed']\
    \ < $cars[$j]['speed']) {\n                    $num_collisions++;\n          \
    \      }\n            }\n        }\n    }\n    return $num_collisions;\n}\n\n\
    $n = 15;\nprint_r(car_race_collision($n));", "  if ($n === 0) {\n    return 0;\n\
    \  }\n  $arr = range(1, $n);\n  $left = $arr;\n  $right = array_reverse($arr);\n\
    \  $arr = array_merge($left, $right);\n  $col = 0;\n  for ($i = 0; $i < count($arr)\
    \ - 1; $i++) {\n    for ($j = $i + 1; $j < count($arr); $j++) {\n      if ($arr[$i]\
    \ > $arr[$j]) {\n        $col++;\n      }\n    }\n  }\n  return $col;\n}", " \
    \   // TODO: Complete this function\n\n    // NOTES: \n    // 0-indexed array\
    \ from 0 to n-1 and from n-1 to 0; this array stores the car number at that position\n\
    \    // Car 0 moves from position 0 to n-1\n    // Car 1 moves from position 1\
    \ to n-2\n    // ...\n    // Car n-1 moves from position n-1 to 0\n    // For\
    \ n = 4, we have an array of 8:\n    // [0, 1, 2, 3, 3, 2, 1, 0]\n    // For n\
    \ = 5, we have an array of 10:\n    // [0, 1, 2, 3, 4, 4, 3, 2, 1, 0]\n    //\
    \ For n = 6, we have an array of 12:\n    // [0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1,\
    \ 0]\n    // Goal: \n    // Find the count of adjacent pairs such that the first\
    \ number is < the second number\n    // Generalize for n cars\n    // Calculate\
    \ expected time complexity\n\n    // ALGORITHM\n    // Start from 1 and iterate\
    \ till n-1\n    // If (n - i) is greater than i, increment count\n    // Else,\
    \ continue\n    //\n\n    $count = 0;\n    for ($i = 1; $i < $n; $i++) {\n   \
    \     if (($n - $i) > $i) {\n            $count++;\n        }\n    }\n\n    return\
    \ $count;\n}\n", "    if ($n < 2) {\n        return 0;\n    }\n    $collisions\
    \ = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = $i + 1; $j < $n;\
    \ $j++) {\n            if ($i < $j) {\n                $collisions++;\n      \
    \      }\n        }\n    }\n    return $collisions;\n}\n", "  // O(n^2) runtime\n\
    \  $count = 0;\n  for ($i = 0; $i < $n; $i++) {\n    for ($j = 0; $j < $n; $j++)\
    \ {\n      $count++;\n    }\n  }\n  return $count;\n}\n", "\t// YOUR CODE GOES\
    \ HERE.\n\t$left = range(1, $n);\n\t$right = range($n, 1);\n\t$l_index = 0;\n\t\
    $r_index = 0;\n\t$collision = 0;\n\t$len = count($left);\n\tfor ($i = 0; $i <\
    \ $len; $i++) {\n\t\tif ($left[$l_index] < $right[$r_index]) {\n\t\t\t$l_index++;\n\
    \t\t} else if ($left[$l_index] > $right[$r_index]) {\n\t\t\t$r_index++;\n\t\t\
    } else {\n\t\t\t$collision++;\n\t\t\t$l_index++;\n\t\t\t$r_index++;\n\t\t}\n\t\
    }\n\treturn $collision;\n}\n", "    $result = 0;\n    $left = [];\n    $right\
    \ = [];\n    $rightPosition = $n;\n    for ($i = 0; $i < $n; $i++) {\n       \
    \ $rightPosition -= 1;\n        $left[] = $i;\n        $right[] = $rightPosition;\n\
    \    }\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            if ($left[$i] === $right[$j]) {\n                $result += 1;\n\
    \            }\n        }\n    }\n    return $result;\n}\n\necho car_race_collision(10);",
  "  // Returns -1 if the parameter $n is not a positive integer\n  if (!is_integer($n)\
    \ || $n <= 0) {\n    return -1;\n  }\n  return $n * ($n - 1) / 2;\n}\n", "  $left_cars\
    \ = array();\n  $right_cars = array();\n  $collisions = 0;\n  for ($i = 0; $i\
    \ < $n; $i++) {\n    $left_cars[$i] = array(\n      'speed' => rand(1, 10),\n\
    \      'x' => rand(0, 10),\n    );\n    $right_cars[$i] = array(\n      'speed'\
    \ => rand(1, 10),\n      'x' => rand(20, 30),\n    );\n  }\n  foreach ($left_cars\
    \ as $left_car) {\n    foreach ($right_cars as $right_car) {\n      $elapsed_time\
    \ = ($right_car['x'] - $left_car['x']) / ($left_car['speed'] + $right_car['speed']);\n\
    \      if ($elapsed_time >= 0) {\n        $collisions++;\n      }\n    }\n  }\n\
    \  return $collisions;\n}\nprint car_race_collision(3);", "    $right_cars = $n;\n\
    \    $left_cars = $n;\n    $collisions = 0;\n    while ($right_cars > 0 && $left_cars\
    \ > 0) {\n        if ($right_cars > $left_cars) {\n            $right_cars = $right_cars\
    \ - $left_cars;\n            $collisions += $left_cars;\n        } else if ($left_cars\
    \ > $right_cars) {\n            $left_cars = $left_cars - $right_cars;\n     \
    \       $collisions += $right_cars;\n        } else {\n            $collisions\
    \ += $right_cars;\n            $right_cars = 0;\n            $left_cars = 0;\n\
    \        }\n    }\n    return $collisions;\n}\n", "    $nCollisions = 0;\n   \
    \ for ($i = 0; $i < $n; $i++) {\n        $nCollisions += $i;\n    }\n    return\
    \ $nCollisions;\n}\n", "  return $n * ($n - 1) / 2;\n}\n\necho car_race_collision(3)\
    \ . PHP_EOL;\necho car_race_collision(4) . PHP_EOL;\necho car_race_collision(5)\
    \ . PHP_EOL;\necho car_race_collision(6) . PHP_EOL;\necho car_race_collision(7)\
    \ . PHP_EOL;\necho car_race_collision(8) . PHP_EOL;\necho car_race_collision(9)\
    \ . PHP_EOL;\necho car_race_collision(10) . PHP_EOL;\n\n$start = microtime(true);\n\
    echo car_race_collision(100) . PHP_EOL;\n$end = microtime(true);\necho ($end -\
    \ $start) * 1000 . PHP_EOL;\n\n$start = microtime(true);\necho car_race_collision(200)\
    \ . PHP_EOL;\n$end = microtime(true);\necho ($end - $start) * 1000 . PHP_EOL;\n\
    \n$start = microtime(true);\necho car_race_collision(300) . PHP_EOL;\n$end = microtime(true);\n\
    echo ($end - $start) * 1000 . PHP_EOL;\n\n$start = microtime(true);\necho car_race_collision(400)\
    \ . PHP_EOL;\n$end = microtime(true);\necho ($end - $start) * 1000 . PHP_EOL;\n\
    \n$start = microtime(true);\necho car_race_collision(500) . PHP_EOL;\n$end = microtime(true);\n\
    echo ($end - $start) * 1000 . PHP_EOL;\n", "    $left_cars = range(1, $n);\n \
    \   $right_cars = range($n, 1);\n    $collisions = 0;\n    while ($right_cars)\
    \ {\n        $right_car = array_pop($right_cars);\n        $left_cars = array_filter($left_cars,\
    \ function($left_car) use ($right_car, &$collisions) {\n            if ($left_car\
    \ <= $right_car) {\n                $collisions++;\n                return false;\n\
    \            }\n            return true;\n        });\n    }\n    return $collisions;\n\
    }\n\nvar_dump(car_race_collision(3)); // int(3)\nvar_dump(car_race_collision(5));\
    \ // int(10)\nvar_dump(car_race_collision(9)); // int(36)\nvar_dump(car_race_collision(10));\
    \ // int(45)\n", "  $left_to_right = $right_to_left = $result = 0;\n  $right_to_left\
    \ = $n;\n  $last_left_car = -1;\n\n  while ($left_to_right < $n) {\n    $new_left_car\
    \ = rand(0, $n);\n    // Only count if we get a new left car\n    if ($new_left_car\
    \ != $last_left_car) {\n      $last_left_car = $new_left_car;\n      $left_to_right++;\n\
    \      $result += $right_to_left;\n    }\n  }\n  return $result;\n}\n\necho car_race_collision(100)\
    \ . \"\\n\";\n", "    return 0;\n}\n", "\treturn $n * ($n - 1) / 2;\n}\n", " \
    \   $left = array(); // we maintain a heap for the cars moving left to right\n\
    \    $right = array(); // we maintain a heap for the cars moving right to left\n\
    \    for ($i = 0; $i < $n; $i++) {\n        // Each car is an integer.  The integer\
    \ represents the starting point\n        // of the car on the road.  The leftmost\
    \ car is 0, the rightmost car is -1.\n        $left[] = $i;\n        $right[]\
    \ = -1 - $i;\n    }\n    usort($left, function($a, $b) { return $a - $b; });\n\
    \    usort($right, function($a, $b) { return $a - $b; });\n    $l = 0; // index\
    \ of the next car to move in the array $left\n    $r = 0; // index of the next\
    \ car to move in the array $right\n    $collisions = 0;\n    while ($l < $n &&\
    \ $r < $n) {\n        // The next left car has not collided with any right car\
    \ that is\n        // to the left of it.\n        if ($left[$l] < $right[$r])\
    \ {\n            $l++;\n        } else if ($left[$l] > $right[$r]) {\n       \
    \     $r++;\n        } else {\n            // The next left car will collide with\
    \ the next right car.\n            $collisions++;\n            $l++;\n       \
    \     $r++;\n        }\n    }\n    return $collisions;\n}\n", "    $i = 0;\n \
    \   $j = $n-1;\n    $count = 0;\n    while ($i < $n && $j >= 0) {\n        if\
    \ ($i == $j) {\n            $count++;\n        } else {\n            $count +=\
    \ 2;\n        }\n        $i++;\n        $j--;\n    }\n    return $count;\n}\n\n\
    $n = 3;\necho car_race_collision($n) . PHP_EOL;", "    $car_l2r = array();\n \
    \   $car_r2l = array();\n    $clash = 0;\n    $car_l2r = range(1, $n);\n    $car_r2l\
    \ = range($n, 1);\n    while ($n > 0) {\n        $l2r = current($car_l2r);\n \
    \       $r2l = current($car_r2l);\n        if ($l2r == $r2l) {\n            $clash++;\n\
    \        }\n        $n--;\n        next($car_l2r);\n        next($car_r2l);\n\
    \    }\n    return $clash;\n}\necho car_race_collision(10);", "  if ($n <= 1)\
    \ {\n    return 0;\n  }\n\n  $collisions = 0;\n  $left_to_right = 0;\n  $right_to_left\
    \ = $n - 1;\n\n  while ($left_to_right < $right_to_left) {\n    $collisions +=\
    \ $right_to_left - $left_to_right;\n    $left_to_right++;\n    $right_to_left--;\n\
    \  }\n\n  return $collisions;\n}\n\n$n = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n$expected\
    \ = [0, 1, 3, 6, 10, 15, 21, 28, 36, 45];\n\nfor ($i = 0; $i < count($n); $i++)\
    \ {\n  $result = car_race_collision($n[$i]);\n  if ($result === $expected[$i])\
    \ {\n    echo 'Success!' . PHP_EOL;\n  } else {\n    echo 'Failure!' . PHP_EOL;\n\
    \  }\n}", "\t// Since this is a straight line, we can simplify the question to:\n\
    \t// Given two sorted arrays of integers, what is the number of\n\t// pairs of\
    \ values that satisfy the condition that the first element is larger than the\
    \ second?\n\t$left_to_right = range(1, $n);\n\t$right_to_left = range($n, 1);\n\
    \t// Now it's a classic 2-pointer problem:\n\t$num_collisions = 0;\n\t$left_index\
    \ = 0;\n\t$right_index = 0;\n\t$left_car = $left_to_right[$left_index];\n\t$right_car\
    \ = $right_to_left[$right_index];\n\twhile ($left_index < $n && $right_index <\
    \ $n) {\n\t\t// If the car to the left is smaller, move the left car forward\n\
    \t\tif ($left_car < $right_car) {\n\t\t\t$left_index++;\n\t\t\t$left_car = $left_to_right[$left_index];\n\
    \t\t}\n\t\t// Otherwise, if the car to the right is smaller, move the right car\
    \ forward\n\t\telse if ($left_car > $right_car) {\n\t\t\t$right_index++;\n\t\t\
    \t$right_car = $right_to_left[$right_index];\n\t\t}\n\t\t// Otherwise, the left\
    \ car and the right car are equal, so move both forward\n\t\telse {\n\t\t\t$left_index++;\n\
    \t\t\t$right_index++;\n\t\t\t$left_car = $left_to_right[$left_index];\n\t\t\t\
    $right_car = $right_to_left[$right_index];\n\t\t}\n\t\t// If the left car is behind\
    \ the right car, then there's a collision\n\t\tif ($left_index < $right_index)\
    \ {\n\t\t\t$num_collisions++;\n\t\t}\n\t}\n\treturn $num_collisions;\n}\n\necho\
    \ car_race_collision(5);", "    if (empty($n)) return 0;\n    $left = array_fill(0,\
    \ $n, 0); // left-to-right cars\n    $right = array_fill(0, $n, 0); // right-to-left\
    \ cars\n    foreach ($left as $k => $v) {\n        $left[$k] = $k;\n    }\n  \
    \  foreach ($right as $k => $v) {\n        $right[$k] = $n - $k - 1;\n    }\n\
    \    $collision = 0;\n    for ($i = 0; $i < $n; $i++) {\n        $l = array_search($i,\
    \ $left);\n        $r = array_search($i, $right);\n        if ($l < $r) {\n  \
    \          $collision += $r - $l;\n        }\n    }\n    return $collision;\n\
    }\n", "    $left = [];\n    $right = [];\n    for ($i = 0; $i < $n; $i++) {\n\
    \        $left[] = 0;\n        $right[] = $n - 1 - $i;\n    }\n    $out = 0;\n\
    \    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n  \
    \          if ($left[$i] == $right[$j]) {\n                $out++;\n         \
    \   }\n        }\n        $left[$i]++;\n    }\n    return $out;\n}\necho car_race_collision(5)\
    \ . \"\\n\";  // 5\necho car_race_collision(10) . \"\\n\";  // 55\necho car_race_collision(30)\
    \ . \"\\n\";  // 465\n", "    // Check if there is only one car or none.\n   \
    \ if ($n <= 1) {\n        return 0;\n    }\n    // Count the number of collisions.\n\
    \    $count = 0;\n    // Move the left to right cars.\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        // Move the right to left cars\n        for ($j = 0; $j < $n;\
    \ $j++) {\n            if ($i == $j) {\n                $count++;\n          \
    \  }\n        }\n    }\n    return $count;\n}\n\nprint_r(car_race_collision(100));",
  "\t// A collision happens when cars at the same position and moving in opposite\
    \ directions.\n\t// Therefore, the number of collisions is the number of pairs\
    \ at the same position.\n\t// We can count the number of collisions by building\
    \ an associative array to\n\t// count the number of cars at the same position.\n\
    \t// The time complexity is O(n), and the space complexity is O(n).\n\t$car_positions\
    \ = array();\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$car_positions[$i] = 0;\n\t\
    }\n\t$collisions = 0;\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$car_positions[rand(0,\
    \ $n-1)]++;\n\t}\n\tforeach ($car_positions as $cars_at_pos) {\n\t\t$collisions\
    \ += $cars_at_pos * ($cars_at_pos - 1) / 2;\n\t}\n\treturn $collisions;\n}\n",
  "    $i = 0;\n    $counter = 0;\n    $array = array();\n    // Generate array of\
    \ random positive integers from 1 to 10000\n    while ($i < $n) {\n        $array[]\
    \ = rand(1,10000);\n        $i++;\n    }\n    // Sort array\n    sort($array);\n\
    \    // Loop through array; if two values are the same, add to counter\n    foreach\
    \ ($array as $key => $value) {\n        if ($value == $array[$key + 1]) {\n  \
    \          $counter++;\n        }\n    }\n    return $counter;\n}", "    $car_numbers\
    \ = range(1, $n);\n    $left_cars = $car_numbers;\n    $right_cars = array_reverse($car_numbers);\n\
    \    $left_index = 0;\n    $right_index = 0;\n    $collisions = 0;\n    while\
    \ ($left_index < $n && $right_index < $n) {\n        if ($left_cars[$left_index]\
    \ > $right_cars[$right_index]) {\n            $collisions++;\n            $right_index++;\n\
    \        } else {\n            $left_index++;\n        }\n    }\n    return $collisions;\n\
    }\necho car_race_collision(5);", "    if($n < 2) {\n        return 0;\n    }\n\
    \    $denom = 1;\n    $sum = 0;\n    for($i = 2 * $n - 1; $i > 0; $i--) {\n  \
    \      $denom *= 2;\n        $sum += ($i - 1) / $denom;\n    }\n    return floor($sum);\n\
    }\n", "    if ($n <= 0) {\n        return 0;\n    }\n    $collisions = 0;\n  \
    \  $curr = 0;\n    $right_to_left = [];\n    for ($i = 0; $i < $n; $i++) {\n \
    \       $right_to_left[$i] = $n - $i - 1;\n    }\n    for ($i = 0; $i < $n; $i++)\
    \ {\n        $curr = $right_to_left[$curr];\n        $collisions++;\n    }\n \
    \   return $collisions;\n}\n", "    $right = array();\n    $left = array();\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $right[] = $i + 1;\n        $left[]\
    \ = $n - $i;\n    }\n    $index = 0;\n    $collision = 0;\n    while ($index <\
    \ $n) {\n        if ($right[$index] == $left[$index]) {\n            $collision++;\n\
    \        }\n        $index++;\n    }\n    return $collision;\n}", "    return\
    \ $n;\n}\n\necho car_race_collision(2) . \"\\n\";\necho car_race_collision(3)\
    \ . \"\\n\";\necho car_race_collision(4) . \"\\n\";\necho car_race_collision(5)\
    \ . \"\\n\";\necho car_race_collision(15) . \"\\n\";\necho car_race_collision(16)\
    \ . \"\\n\";\necho car_race_collision(100) . \"\\n\";\necho car_race_collision(10000)\
    \ . \"\\n\";\necho car_race_collision(100000000) . \"\\n\";\necho car_race_collision(1000000000)\
    \ . \"\\n\";", "  $collisions = 0;\n  $l2r = 0;\n  $r2l = $n - 1;\n  while ($l2r\
    \ < $r2l) {\n    $l2r += 1;\n    $r2l -= 1;\n    $collisions += 1;\n  }\n  return\
    \ $collisions;\n}\n\nfor ($i = 1; $i < 10; $i++) {\n  $expected = ($i * ($i -\
    \ 1)) / 2;\n  $actual = car_race_collision($i);\n  print \"$i: $expected vs $actual\\\
    n\";\n}", "  // Fill this in\n  $left = array();\n  $right = array();\n  for ($i\
    \ = 0; $i < $n; $i++) {\n    $left[] = rand();\n    $right[] = rand();\n  }\n\
    \  // $left = [2, 2, 5, 6, 8, 10];\n  // $right = [1, 7, 3, 3, 3, 7];\n  // echo\
    \ 'left: ' . implode(', ', $left) . '<br>';\n  // echo 'right: ' . implode(',\
    \ ', $right) . '<br>';\n  // output: 3\n\n  // $left = [1, 2, 3, 4, 5, 6];\n \
    \ // $right = [2, 3, 4, 5, 6, 7];\n  // echo 'left: ' . implode(', ', $left) .\
    \ '<br>';\n  // echo 'right: ' . implode(', ', $right) . '<br>';\n  // output:\
    \ 3\n\n  $left = [1, 1, 1, 1, 1, 1];\n  $right = [1, 1, 1, 1, 1, 1];\n  echo 'left:\
    \ ' . implode(', ', $left) . '<br>';\n  echo 'right: ' . implode(', ', $right)\
    \ . '<br>';\n  // output: 15\n\n  // $left = [1, 2, 3, 4, 5, 6];\n  // $right\
    \ = [4, 5, 6, 7, 8, 9];\n  // echo 'left: ' . implode(', ', $left) . '<br>';\n\
    \  // echo 'right: ' . implode(', ', $right) . '<br>';\n  // output: 0\n\n  $count\
    \ = 0;\n  $right = array_reverse($right);\n  // echo 'right: ' . implode(', ',\
    \ $right) . '<br>';\n  foreach ($left as $key => $value) {\n    if ($value >=\
    \ $right[$key]) {\n      $count++;\n    }\n  }\n  return $count;\n}\necho car_race_collision(6);\n",
  "\treturn $n*($n-1)/2;\n}\n", "    // assume that n >= 1.\n    //\n    // Assume\
    \ that there are 2 cars.  In this case, the problem is to decide\n    // whether\
    \ the two cars collide.  The two cars collide if and only if\n    // one of the\
    \ cars is moving to the right and the other one is moving to the left.\n    //\
    \ This is true if and only if car #1 is moving to the right and car #2 is moving\
    \ to the left,\n    // or car #1 is moving to the left and car #2 is moving to\
    \ the right.\n    // This is true if and only if (car #1 is moving to the right\
    \ and car #2 is moving to the left)\n    // or (car #1 is moving to the left and\
    \ car #2 is moving to the right).\n    // So there are 2 collisions if and only\
    \ if the first car is moving to the right or\n    // if the second car is moving\
    \ to the right, which happens with probability 1/2.\n    // This is true if and\
    \ only if there are n cars.  Can you generalize the argument above?\n    // If\
    \ there are 2 cars and they both collide, then the cars are either both moving\n\
    \    // right to left or both moving left to right.  With n cars, there are n!/2\
    \ collisions\n    // if and only if the cars are either all moving right to left\
    \ or all moving left to right.\n    // So the answer is n!/2, which is the same\
    \ as n! divided by 2.\n    // So the answer is:\n    // The answer is equal to\
    \ n! divided by 2, which is the same as the\n    // floor of n! divided by 2.\n\
    \    return floor(factorial($n) / 2);\n}", "  // this problem is equivalent to\
    \ finding the number of inversions in a series of\n  // $n numbers\n  // the run\
    \ time is O(n log n)\n  $cars_left = range(1, $n);\n  $cars_right = range($n +\
    \ 1, 2 * $n);\n  $cnt = 0;\n  // not using array_merge\n  for ($i = 0; $i < $n;\
    \ $i++) {\n    // use two pointers\n    $left = 0;\n    $right = 0;\n    while\
    \ ($left < $n - $i && $right < $n - $i) {\n      if ($cars_left[$left] < $cars_right[$right])\
    \ {\n        $left++;\n      } else {\n        $cnt += $n - $i - $left;\n    \
    \    $right++;\n      }\n    }\n    array_shift($cars_left);\n    array_pop($cars_right);\n\
    \  }\n  return $cnt;\n}\n\nvar_dump(car_race_collision(5));", "    $car_a = array();\n\
    \    $car_b = array();\n    for ($i = 0; $i < $n; $i++) {\n        $car_a[$i]\
    \ = rand(0, 100);\n        $car_b[$i] = rand(0, 100);\n    }\n    $total_car_a\
    \ = 0;\n    $total_car_b = 0;\n    for ($i = 0; $i < $n; $i++) {\n        $total_car_a\
    \ += $car_a[$i];\n        $total_car_b += $car_b[$i];\n    }\n    $a_start = 0;\n\
    \    $b_start = $total_car_a;\n    $collision = 0;\n    while ($a_start < $total_car_a)\
    \ {\n        if ($a_start == $b_start) {\n            $collision++;\n        }\n\
    \        $a_start++;\n        $b_start--;\n    }\n    return $collision;\n}\n",
  "    return $n ** 2;\n}", "    $output = 0;\n    for ($i = 0; $i < $n; $i++) {\n\
    \        for ($j = 0; $j < $n; $j++) {\n            $output++;\n        }\n  \
    \  }\n    return $output;\n}\n", "    // Your solution goes here\n}", "  // TODO(you):\
    \ Implement it.\n}", "\t\n\t// This is a competitive programming problem.  The\
    \ time complexity and space complexity\n\t// are both O(n).\n\t$left_to_right\
    \ = array();\n\t$right_to_left = array();\n\t$counter = 0;\n\t\n\t// Fill the\
    \ $left_to_right and $right_to_left arrays\n\tfor ($i = 0; $i < $n; $i++) {\n\t\
    \tarray_push($left_to_right, $i);\n\t\tarray_push($right_to_left, $n - $i - 1);\n\
    \t}\n\t\n\t// This for loop might seem counterintuitive.  It's a simple solution\
    \ but\n\t// is probably not the best solution to this problem.\n\tfor ($i = 0;\
    \ $i < $n; $i++) {\n\t\tfor ($j = 0; $j < $n; $j++) {\n\t\t\tif ($left_to_right[$i]\
    \ == $right_to_left[$j]) {\n\t\t\t\t$counter++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn\
    \ $counter;\n}\n\necho car_race_collision(2);", "    // $n cars driving left to\
    \ right and $n cars driving right to left\n    // so total number of cars is 2*$n\n\
    \    // each car has its own position in the road, therefore it must have a number\n\
    \    // the first set of cars (driving left to right) start on the road at $n\n\
    \    // the second set of cars (driving right to left) start at $n * $n\n    //\
    \ moving in the same speed, the position of a car is predictable\n    // the first\
    \ set of cars will always move to the right by 1; the second set\n    // will\
    \ always move to the left by 1\n    // if at any point of time the current position\
    \ of a car from the first set\n    // is the same as that of a car from the second\
    \ set, then there is a collision\n    // because the cars continue moving in their\
    \ trajectory and remain at the same\n    // position, collisions are counted only\
    \ once\n\n    // for the first set of cars, the current position is predictable,\
    \ therefore\n    // it is possible to find the position of the car in the second\
    \ set that the\n    // first set car will collide with\n    // by the time the\
    \ first set of cars cross the first set of cars, the second\n    // set will have\
    \ moved back by 1\n    // by the time the first set of cars cross the second set\
    \ of cars, the second\n    // set will have moved back by 2\n    // by the time\
    \ the first set of cars cross the third set of cars, the second\n    // set will\
    \ have moved back by 3\n    // and so on\n    // as a result, the position of\
    \ a car in the second set that the first set car\n    // will collide with is\
    \ predictable\n    // by the time the first set of cars cross the first set of\
    \ cars, the second\n    // set will have moved back by $n\n    // by the time\
    \ the first set of cars cross the second set of cars, the second\n    // set will\
    \ have moved back by $n * $n\n    // by the time the first set of cars cross the\
    \ third set of cars, the second\n    // set will have moved back by $n * $n *\
    \ $n\n    // and so on\n    // as a result, the number of collisions is predictable\n\
    \    $collisions = 0;\n    for ($i = 1;", "    $left = $right = 0;\n    for ($i\
    \ = 0; $i < $n; $i++) {\n        $left += $i;\n        $right += $n - $i - 1;\n\
    \    }\n    return $left + $right;\n}\n\necho car_race_collision(1) . \"\\n\"\
    ; // 0\necho car_race_collision(2) . \"\\n\"; // 1\necho car_race_collision(3)\
    \ . \"\\n\"; // 3\necho car_race_collision(4) . \"\\n\"; // 6\necho car_race_collision(5)\
    \ . \"\\n\"; // 10\necho car_race_collision(6) . \"\\n\"; // 15\necho car_race_collision(7)\
    \ . \"\\n\"; // 21\necho car_race_collision(8) . \"\\n\"; // 28\necho car_race_collision(9)\
    \ . \"\\n\"; // 36\necho car_race_collision(10) . \"\\n\"; // 45\necho car_race_collision(11)\
    \ . \"\\n\"; // 55\necho car_race_collision(12) . \"\\n\"; // 66\necho car_race_collision(13)\
    \ . \"\\n\"; // 78\necho car_race_collision(14) . \"\\n\"; // 91\necho car_race_collision(15)\
    \ . \"\\n\"; // 105\necho car_race_collision(16) . \"\\n\"; // 120\necho car_race_collision(17)\
    \ . \"\\n\"; // 136\necho car_race_collision(18) . \"\\n\"; // 153\necho car_race_collision(19)\
    \ . \"\\n\"; // 171\necho car_race_collision(20) . \"\\n\"; // 190\necho car_race_collision(21)\
    \ . \"\\n\"; // 210\necho car_race_collision(22) . \"\\n\"; // 231\necho car_race_collision(23)\
    \ . \"\\n\"; // 253\necho car_race_collision(24) . \"\\n\"; // 276\necho car_race_collision(25)\
    \ . \"\\n\"; // 300\necho car_race_collision(26) . \"\\n\"; // 325\necho car_race_",
  "  // Your code here\n}\n", "    $collisions = 0;\n    for ($i = 0; $i < $n; $i++)\
    \ {\n        for ($j = 0; $j < $n; $j++) {\n            $collisions++;\n     \
    \   }\n    }\n    return $collisions;\n}\n", "\t$count = 0;\n\t// left to right\
    \ cars\n\tfor ($i = 0; $i < $n; $i++) {\n\t\tfor ($j = $i+1; $j < $n; $j++) {\n\
    \t\t\t$count++;\n\t\t}\n\t}\n\t// right to left cars\n\tfor ($i = 0; $i < $n;\
    \ $i++) {\n\t\tfor ($j = $i+1; $j < $n; $j++) {\n\t\t\t$count++;\n\t\t}\n\t}\n\
    \treturn $count;\n}", "  $middle_car = floor($n / 2);\n\n  // $left_to_right_cars\
    \ -> [0, $middle_car, 1]\n  $left_to_right_cars = range(0, $middle_car, 1);\n\
    \  $right_to_left_cars = range($middle_car, $n, 1);\n\n  $collisions = 0;\n  foreach\
    \ ($left_to_right_cars as $left_to_right_car) {\n    foreach ($right_to_left_cars\
    \ as $right_to_left_car) {\n      if ($left_to_right_car > $right_to_left_car)\
    \ {\n        $collisions++;\n      }\n    }\n  }\n\n  return $collisions;\n}\n",
  "   return $n * ($n - 1) / 2;\n}\n", "  $start_left_to_right = range(1, $n);\n \
    \ $start_right_to_left = range($n, 1);\n  $left_to_right = [];\n  $right_to_left\
    \ = [];\n  foreach ($start_left_to_right as $car) {\n    $left_to_right[$car]\
    \ = $car;\n  }\n  foreach ($start_right_to_left as $car) {\n    $right_to_left[$car]\
    \ = $car;\n  }\n  $collisions = 0;\n  while (!empty($left_to_right) && !empty($right_to_left))\
    \ {\n    $collisions += count(array_intersect_key($left_to_right, $right_to_left));\n\
    \    foreach ($left_to_right as $car => $x) {\n      $left_to_right[$car] += 1;\n\
    \    }\n    foreach ($right_to_left as $car => $x) {\n      $right_to_left[$car]\
    \ -= 1;\n    }\n    foreach ($left_to_right as $car => $x) {\n      if ($x > $n)\
    \ {\n        unset($left_to_right[$car]);\n      }\n    }\n    foreach ($right_to_left\
    \ as $car => $x) {\n      if ($x < 1) {\n        unset($right_to_left[$car]);\n\
    \      }\n    }\n  }\n  return $collisions;\n}\necho car_race_collision(4) . \"\
    \\n\";", "  // SOLUTION GOES HERE.\n  // n = the number of cars driving left to\
    \ right\n  // for each iteration of a left-driving car, a collision can only occur\
    \ if the\n  // left-driving car's index is greater than or equal to the\n  //\
    \ right-driving car's index\n  // the left-driving car's index = the number of\
    \ left-driving cars that already moved\n  // the right-driving car's index = the\
    \ number of right-driving cars that already moved\n  // # of collisions = n(n+1)/2\n\
    \n  // key insight: car_race_collision(n) = car_race_collision(n-1) + n\n\n  //\
    \ similar to the triangle examples above\n\n  if($n==0){\n    return 0;\n  }\n\
    \  return car_race_collision($n-1) + $n;\n}\n", "\t// Write your code here\n}\n\
    \n$tests = array(\n\tarray(\n\t\t\"input\" => 1,\n\t\t\"solution\" => 0\n\t),\n\
    \tarray(\n\t\t\"input\" => 2,\n\t\t\"solution\" => 1\n\t),\n\tarray(\n\t\t\"input\"\
    \ => 3,\n\t\t\"solution\" => 2\n\t),\n\tarray(\n\t\t\"input\" => 4,\n\t\t\"solution\"\
    \ => 3\n\t),\n\tarray(\n\t\t\"input\" => 5,\n\t\t\"solution\" => 4\n\t),\n\tarray(\n\
    \t\t\"input\" => 6,\n\t\t\"solution\" => 5\n\t),\n\tarray(\n\t\t\"input\" => 7,\n\
    \t\t\"solution\" => 6\n\t),\n\tarray(\n\t\t\"input\" => 8,\n\t\t\"solution\" =>\
    \ 7\n\t),\n\tarray(\n\t\t\"input\" => 9,\n\t\t\"solution\" => 8\n\t),\n\tarray(\n\
    \t\t\"input\" => 10,\n\t\t\"solution\" => 9\n\t),\n\tarray(\n\t\t\"input\" =>\
    \ 11,\n\t\t\"solution\" => 10\n\t),\n\tarray(\n\t\t\"input\" => 12,\n\t\t\"solution\"\
    \ => 11\n\t),\n\tarray(\n\t\t\"input\" => 13,\n\t\t\"solution\" => 12\n\t),\n\t\
    array(\n\t\t\"input\" => 14,\n\t\t\"solution\" => 13\n\t),\n\tarray(\n\t\t\"input\"\
    \ => 15,\n\t\t\"solution\" => 14\n\t),\n\tarray(\n\t\t\"input\" => 16,\n\t\t\"\
    solution\" => 15\n\t),\n\tarray(\n\t\t\"input\" => 17,\n\t\t\"solution\" => 16\n\
    \t),\n\tarray(\n\t\t\"input\" => 18,\n\t\t\"solution\" => 17\n\t),\n\tarray(\n\
    \t\t\"input\" => 19,\n\t\t\"solution\" => 18\n\t),\n\tarray(\n\t\t\"input\" =>\
    \ 20,\n\t\t\"solution\" =>", "    $left_cars = range(1, $n);\n    $right_cars\
    \ = range($n + 1, 2 * $n);\n    $count = 0;\n    for ($i = 0; $i < $n; $i++) {\n\
    \        $left_car = $left_cars[$i];\n        $right_car = $right_cars[$i];\n\
    \        if ($left_car < $right_car) {\n            $count++;\n        }\n   \
    \ }\n    return $count;\n}\n\necho car_race_collision(1);\necho \"<br>\";\necho\
    \ car_race_collision(2);\necho \"<br>\";\necho car_race_collision(3);\necho \"\
    <br>\";\necho car_race_collision(4);\necho \"<br>\";\necho car_race_collision(5);\n\
    echo \"<br>\";\necho car_race_collision(6);\necho \"<br>\";\necho car_race_collision(7);\n\
    echo \"<br>\";\necho car_race_collision(8);\necho \"<br>\";\necho car_race_collision(9);\n\
    echo \"<br>\";\necho car_race_collision(10);\necho \"<br>\";\necho car_race_collision(11);\n\
    echo \"<br>\";\necho car_race_collision(12);\necho \"<br>\";\necho car_race_collision(13);\n\
    echo \"<br>\";\necho car_race_collision(14);\necho \"<br>\";\necho car_race_collision(15);\n\
    echo \"<br>\";\necho car_race_collision(16);\necho \"<br>\";\necho car_race_collision(17);\n\
    echo \"<br>\";\necho car_race_collision(18);\necho \"<br>\";\necho car_race_collision(19);\n\
    echo \"<br>\";\necho car_race_collision(20);\necho \"<br>\";\necho car_race_collision(21);\n\
    echo \"<br>\";\necho car_race_collision(22);\necho \"<br>\";\necho car_race_collision(23);\n\
    echo \"<br>\";", "    $collisions = 0;\n    for ($i = 0; $i < $n; $i++) {\n  \
    \      for ($j = 0; $j < $n; $j++) {\n            $collisions += ($i < $j);\n\
    \        }\n    }\n    return $collisions;\n}\n", "\t// For each car that's moving\
    \ right to left\n\t// we want to know how many cars are moving left to right\n\
    \t// and have not yet collided with it.\n\t// So we'll create a variable called\
    \ 'car_count' that\n\t// keeps track of that.\n\t$car_count = 0;\n\t// Create\
    \ variable to hold the number of collisions.\n\t$collision_count = 0;\n\t// Traverse\
    \ all the cars moving right to left.\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t//\
    \ Traverse all the cars moving left to right.\n\t\tfor ($j = 0; $j < $n; $j++)\
    \ {\n\t\t\t// If the car has not yet collided with a car moving right to left.\n\
    \t\t\tif ($car_count < $j) {\n\t\t\t\t// Increment the number of collisions.\n\
    \t\t\t\t$collision_count++;\n\t\t\t}\n\t\t}\n\t\t// Decrement car_count as this\
    \ car moving right to left\n\t\t// has already collided with cars moving left\
    \ to right.\n\t\t$car_count--;\n\t}\n\t// Return the collision count.\n\treturn\
    \ $collision_count;\n}\n", "    if (is_int($n) && $n > 0) {\n        $collisions\
    \ = 0;\n        $left_cars = [];\n        $right_cars = [];\n        // Arrange\
    \ $n cars into the left_cars array\n        for ($i = 0; $i < $n; $i++) {\n  \
    \          array_push($left_cars, $i);\n        }\n        // Arrange $n cars\
    \ into the right_cars array\n        for ($i = 0; $i < $n; $i++) {\n         \
    \   array_push($right_cars, $i);\n        }\n        // Start the race\n     \
    \   while (!empty($left_cars) && !empty($right_cars)) {\n            $curr_left_car\
    \ = $left_cars[0];\n            $curr_right_car = $right_cars[0];\n          \
    \  if ($curr_left_car > $curr_right_car) {\n                // The left car is\
    \ at the right of the right car\n                $collisions++;\n            \
    \    // The right car will not move any further, so\n                // pop it\
    \ out\n                array_shift($right_cars);\n            } else if ($curr_left_car\
    \ < $curr_right_car) {\n                // The left car is at the left of the\
    \ right car\n                // The left car will not move any further, so\n \
    \               // pop it out\n                array_shift($left_cars);\n    \
    \        } else {\n                // The left car is at the same position as\
    \ the right car\n                // pop both cars\n                array_shift($left_cars);\n\
    \                array_shift($right_cars);\n            }\n        }\n       \
    \ return $collisions;\n    } else {\n        throw new Exception(\"Please input\
    \ a positive integer.\");\n    }\n}\n", "  $crashes = 0;\n  for ($i = 0; $i <\
    \ $n; $i++) {\n    for ($j = 0; $j < $n; $j++) {\n      $crashes++;\n    }\n \
    \ }\n  return $crashes;\n}\n", "    if ( $n < 2 ) {\n        return 0;\n    }\n\
    \n    $array1 = range(1, $n);\n    $array2 = range($n, 1);\n\n    $len = count($array1);\n\
    \    $collision = 0;\n\n    for ( $i = 0; $i < $len; $i++ ) {\n        for ( $j\
    \ = 0; $j < $len; $j++ ) {\n            if ( $array1[$i] == $array2[$j] ) {\n\
    \                $collision++;\n            }\n        }\n    }\n\n    return\
    \ $collision;\n}\n\n$n = 5;\necho car_race_collision($n);\necho \"\\n\";", " \
    \   $cars = range(1, $n);\n\n    $left_to_right = [];\n    $right_to_left = [];\n\
    \n    foreach ($cars as $car) {\n        $left_to_right[] = $car;\n        $right_to_left[]\
    \ = $car;\n    }\n\n    $matches = 0;\n\n    while (count($left_to_right) > 0\
    \ && count($right_to_left) > 0) {\n        $left_car = array_shift($left_to_right);\n\
    \        $right_car = array_shift($right_to_left);\n\n        if ($left_car ==\
    \ $right_car) {\n            $matches++;\n        }\n    }\n\n    return $matches;\n\
    }\n\n$n = 5;\n\necho car_race_collision($n);", "    //Assume that we don't care\
    \ about overlapping collisions.\n    return $n;\n}\n\nclass car_race_collision_test\
    \ extends PHPUnit_Framework_TestCase {\n    public function test() {\n       \
    \ $this->assertTrue(true);\n    }\n}", "\tif($n == 0) return 0;\n\telse if($n\
    \ == 1) return 0;\n\telse return $n + car_race_collision($n-1);\n}\necho car_race_collision(4);",
  "  $total = 0;\n  for ($i = 0; $i < $n; $i++) {\n    $total += $i;\n  }\n  return\
    \ $total;\n}\n\necho car_race_collision(3) . \"\\n\";\n", "\tif ($n <= 1) {\n\t\
    \treturn 0;\n\t}\n\t$count = 0;\n\t$first = 1;\n\t$last = $n;\n\twhile ($first\
    \ < $last) {\n\t\t$count += $last - $first;\n\t\t$first++;\n\t\t$last--;\n\t}\n\
    \treturn $count;\n}\n", "  $nLeft = $n;\n  $nRight = $n;\n  $collisions = 0;\n\
    \  while ($nLeft > 0 && $nRight > 0) {\n    if ($nLeft == $nRight) {\n      //\
    \ As all cars are moving at the same speed, they all move 1 unit at a time.\n\
    \      // Then the number of collisions is the same as the number of cars on one\
    \ side.\n      $collisions += $nLeft;\n      $nLeft = 0;\n      $nRight = 0;\n\
    \    } else if ($nLeft > $nRight) {\n      // Then nLeft cars are still on their\
    \ way and nRight have all met with cars from the other side.\n      // We have\
    \ nRight collisions so far.\n      $collisions += $nRight;\n      $nLeft -= $nRight;\n\
    \      $nRight = 0;\n    } else {\n      // Then nRight cars are still on their\
    \ way and nLeft have all met with cars from the other side.\n      // We have\
    \ nLeft collisions so far.\n      $collisions += $nLeft;\n      $nRight -= $nLeft;\n\
    \      $nLeft = 0;\n    }\n  }\n  return $collisions;\n}\n", "    $collisions\
    \ = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            $collisions++;\n        }\n    }\n    return $collisions;\n}\n",
  "    $collisions = 0;\n    $right_to_left = range(1, $n);\n    $left_to_right =\
    \ range($n, 1);\n    foreach ($right_to_left as $car) {\n        if ($car == end($left_to_right))\
    \ {\n            $collisions++;\n        }\n    }\n    return $collisions;\n}\n\
    \necho car_race_collision(5); // 4\necho \"\\n\";\necho car_race_collision(100);\
    \ // 99\necho \"\\n\";\necho car_race_collision(10000); // 9999\necho \"\\n\"\
    ;\n", "    $left = range(1, $n);\n    $right = range($n, 1);\n    $count = 0;\n\
    \    while ($left && $right) {\n        $collide = array_shift($left) - array_shift($right);\n\
    \        if ($collide > 0) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}\n", "    $left_to_right = [];\n    $right_to_left = [];\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        $left_to_right[] = 0;\n        $right_to_left[]\
    \ = 0;\n    }\n    $n_collisions = 0;\n    while (count($left_to_right) > 0 &&\
    \ count($right_to_left) > 0) {\n        $car_left_to_right = array_shift($left_to_right);\n\
    \        $car_right_to_left = array_shift($right_to_left);\n        if ($car_left_to_right\
    \ == $car_right_to_left) {\n            $n_collisions++;\n        } else if ($car_left_to_right\
    \ < $car_right_to_left) {\n            $left_to_right[] = $car_left_to_right +\
    \ 1;\n            $right_to_left[] = $car_right_to_left;\n        } else {\n \
    \           $left_to_right[] = $car_left_to_right;\n            $right_to_left[]\
    \ = $car_right_to_left + 1;\n        }\n    }\n    return $n_collisions;\n}\n",
  "    $res = 0;\n    // The left-moving car is at position $x, and the right-moving\
    \ car is at position $y.\n    // We start at $x=1, $y=1 because we want the car\
    \ at position 0 to be included.\n    // $i is the index of the car.  Cars at index\
    \ 0 will be at position 1, cars at index 1 will be at position 2, etc.\n    for\
    \ ($x = 1, $y = 1, $i = 0; $i < $n; $x++, $y++, $i++) {\n        // The number\
    \ of collisions involving the left-moving car at position $x is ($x-1).\n    \
    \    // For example, if a car at position 1 (index 0) is moving left, it collides\
    \ with\n        // all the cars on its left, which are at position 0 (index 0)\
    \ and -1 (index 1).\n        // If a car at position 2 (index 1) is moving left,\
    \ it collides with\n        // all the cars on its left, which are at position\
    \ 1 (index 0) and 0 (index 1).\n        // In general, a car at position $x (index\
    \ $i) collides with all the cars on its left,\n        // which are at position\
    \ $x-1 (index $i) and $x-2 (index $i+1).\n        $res += $x - 1;\n        //\
    \ The number of collisions involving the right-moving car at position $y is ($n-$y).\n\
    \        // For example, if a car at position 1 (index 0) is moving right, it\
    \ collides with\n        // all the cars on its right, which are at position 2\
    \ (index 0) and 3 (index 1).\n        // If a car at position 2 (index 1) is moving\
    \ right, it collides with\n        // all the cars on its right, which are at\
    \ position 3 (index 0) and 4 (index 1).\n        // In general, a car at position\
    \ $y (index $i) collides with all the cars on its right,\n        // which are\
    \ at position $y+1 (index $i) and $y+2 (index $i+1).\n        $res += $n - $y;\n\
    \    }\n    return $res;\n}\n?", "    return 1 + $n;\n}", "    $i = 0;\n    $j\
    \ = 0;\n    $k = 0;\n    while ($i < $n && $j < $n) {\n        if ($i - $j ==\
    \ $k) {\n            $k++;\n            $i++;\n            $j++;\n        } elseif\
    \ ($i - $j > $k) {\n            $j++;\n        } else {\n            $i++;\n \
    \       }\n    }\n    return $k;\n}\n\nassert(car_race_collision(1) == 0);\nassert(car_race_collision(2)\
    \ == 1);\nassert(car_race_collision(3) == 2);\nassert(car_race_collision(4) ==\
    \ 4);\nassert(car_race_collision(5) == 6);\nassert(car_race_collision(6) == 9);\n\
    assert(car_race_collision(7) == 13);\nassert(car_race_collision(8) == 17);\nassert(car_race_collision(9)\
    \ == 22);\nassert(car_race_collision(10) == 28);\nassert(car_race_collision(11)\
    \ == 35);\nassert(car_race_collision(12) == 43);\nassert(car_race_collision(13)\
    \ == 52);\nassert(car_race_collision(14) == 62);\nassert(car_race_collision(15)\
    \ == 73);\n", "  return ($n*($n-1))/2;\n}\n", "  if ($n == 0) {\n    return 0;\n\
    \  }\n  if ($n == 1) {\n    return 0;\n  }\n  return ($n * ($n - 1)) / 2;\n}\n",
  "    $collisions = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            $collisions += i == j ? 0 : 1;\n        }\n    }\n\
    \    return $collisions;\n}\n\necho car_race_collision(3);\necho car_race_collision(4);\n\
    echo car_race_collision(6);", "  // TODO: Please fill in the code here.\n  $left_to_right\
    \ = range(1, $n);\n  $right_to_left = range($n, 1);\n  $collision = 0;\n  for\
    \ ($i = 0; $i < $n; $i++) {\n    for ($j = 0; $j < $n; $j++) {\n      if ($left_to_right[$i]\
    \ == $right_to_left[$j]) {\n        $collision++;\n      }\n    }\n  }\n  return\
    \ $collision;\n}\n", "    $left_to_right = [];\n    $right_to_left = [];\n   \
    \ for ($i = 0; $i < $n; $i++) {\n        $left_to_right[] = $i;\n        $right_to_left[]\
    \ = $i;\n    }\n    $collisions = 0;\n    for ($i = 0; $i < $n; $i++) {\n    \
    \    $x = array_pop($left_to_right);\n        $y = array_pop($right_to_left);\n\
    \        if ($x === $y) {\n            $collisions++;\n        }\n    }\n    return\
    \ $collisions;\n}\n\necho car_race_collision(2) . \"\\n\";\necho car_race_collision(3)\
    \ . \"\\n\";\necho car_race_collision(4) . \"\\n\";\necho car_race_collision(5)\
    \ . \"\\n\";\necho car_race_collision(6) . \"\\n\";\necho car_race_collision(10)\
    \ . \"\\n\";\necho car_race_collision(100) . \"\\n\";\necho car_race_collision(1000)\
    \ . \"\\n\";\necho car_race_collision(1000000) . \"\\n\";\necho car_race_collision(100000000)\
    \ . \"\\n\";\necho car_race_collision(10000000000) . \"\\n\";\n", "    $cars_left_to_right\
    \ = [];\n    $cars_right_to_left = [];\n    for ($i = 0; $i < $n; $i++) {\n  \
    \      $cars_left_to_right[] = $i;\n        $cars_right_to_left[] = $i;\n    }\n\
    \    $num_collisions = 0;\n    while (sizeof($cars_left_to_right) > 0 && sizeof($cars_right_to_left)\
    \ > 0) {\n        $left = array_shift($cars_left_to_right);\n        $right =\
    \ array_shift($cars_right_to_left);\n        if ($left == $right) {\n        \
    \    $num_collisions++;\n        }\n    }\n    return $num_collisions;\n}", " \
    \ // your code goes here\n}\n", "    // your code here\n    $collisions = 0;\n\
    \    for ($leftCar=1; $leftCar<=$n; $leftCar++) {\n        for ($rightCar=$n;\
    \ $rightCar>=$leftCar; $rightCar--) {\n            if ($leftCar == $rightCar)\
    \ {\n                continue;\n            }\n            $collisions += $leftCar\
    \ * $rightCar;\n        }\n    }\n    return $collisions;\n}\n", "    $collisions\
    \ = 0;\n    $left_to_right = [];\n    $right_to_left = [];\n    for ($i = 0; $i\
    \ < $n; $i++) {\n        $left_to_right[] = $i;\n        $right_to_left[] = $n\
    \ - $i - 1;\n    }\n    $left_to_right_index = 0;\n    $right_to_left_index =\
    \ 0;\n    while ($left_to_right_index < $n && $right_to_left_index < $n) {\n \
    \       if ($left_to_right[$left_to_right_index] < $right_to_left[$right_to_left_index])\
    \ {\n            $left_to_right_index++;\n        } else if ($left_to_right[$left_to_right_index]\
    \ > $right_to_left[$right_to_left_index]) {\n            $right_to_left_index++;\n\
    \        } else {\n            $collisions++;\n            $left_to_right_index++;\n\
    \            $right_to_left_index++;\n        }\n    }\n    return $collisions;\n\
    }\n\necho \"Car race collisions:\\n\";\necho \"0: \" . car_race_collision(0) .\
    \ \"\\n\";\necho \"1: \" . car_race_collision(1) . \"\\n\";\necho \"2: \" . car_race_collision(2)\
    \ . \"\\n\";\necho \"3: \" . car_race_collision(3) . \"\\n\";\necho \"4: \" .\
    \ car_race_collision(4) . \"\\n\";\necho \"5: \" . car_race_collision(5) . \"\\\
    n\";\necho \"6: \" . car_race_collision(6) . \"\\n\";\necho \"7: \" . car_race_collision(7)\
    \ . \"\\n\";\necho \"8: \" . car_race_collision(8) . \"\\n\";\necho \"9: \" .\
    \ car_race_collision(9) . \"\\n\";\necho \"10: \" . car_race_collision(10) . \"\
    \\n\";\necho", "    // your code goes here.\n    return \"\";\n}\n\necho car_race_collision(1)\
    \ . PHP_EOL; //1\necho car_race_collision(2) . PHP_EOL; //3\necho car_race_collision(3)\
    \ . PHP_EOL; //5\necho car_race_collision(4) . PHP_EOL; //7\necho car_race_collision(5)\
    \ . PHP_EOL; //9\necho car_race_collision(15) . PHP_EOL; //31\necho car_race_collision(100)\
    \ . PHP_EOL; //199\necho car_race_collision(1000) . PHP_EOL; //1999\necho car_race_collision(1000000)\
    \ . PHP_EOL; //1999999\n", "    // Just as in a binary tree, we can do this in\
    \ O(n log n) time.  We do this by\n    // merging the right-to-left and left-to-right\
    \ cars in sorted order.\n    //\n    // Now, this problem is often set up as follows:\n\
    \    //  We assume the right-to-left cars have an index 0 through n-1.\n    //\
    \  We assume the left-to-right cars have an index n through 2n-1.\n    //  We\
    \ assume the cars are perfectly evenly spaced at unit distance apart,\n    //\
    \    so that the left-to-right car at index 2n-1 is at a distance 2n-1 from the\n\
    \    //    left-to-right car at index n.\n    //  The speed of each car is assumed\
    \ to be 1, so the total distance it travels is\n    //    just the absolute value\
    \ of its position.\n    //  We assume the total distance traveled is a sum of\n\
    \    //    the distances traveled by each car.\n    //\n    // We will solve this\
    \ problem in a slightly different way, because I think it's a little\n    // more\
    \ natural.  We will assume that we have n cars going right to left and n cars\
    \ going\n    // left to right, each at an arbitrary starting point, and each of\
    \ arbitrary speed.\n    //\n    // Since all cars have the same speed, this is\
    \ the same as saying that we have n cars going\n    // right to left and n cars\
    \ going left to right, each at an arbitrary starting point, and each\n    // of\
    \ speed 1.\n    //\n    // Let's assume the right-to-left cars have an index 0\
    \ through n-1.\n    // Let's assume the left-to-right cars have an index n through\
    \ 2n-1.\n    //\n    // Let's say the left-to-right car at index i has an x coordinate\
    \ of x_i.\n    // Let's say the right-to-left car at index i has an x coordinate\
    \ of y_i.\n    //\n    // In this setup, we can say the following:\n    //  x_i\
    \ = total_distance_left_to_right - y_i\n    //  y_i = total_distance_right_to_left\
    \ - x_i", "    // find the closest distance between right and left cars\n    //\
    \ take the minimum of the left and right\n    // if it is the right one, find\
    \ the closest right car to it\n    // if it is the left one, find the closest\
    \ left car to it\n    // compare their distance and check if they collide, then\
    \ increase collision count\n    $left = [];\n    $right = [];\n    $collision\
    \ = 0;\n    for ($i = 0; $i < $n; $i++) {\n        $left[$i] = mt_rand(1, 100000);\n\
    \        $right[$i] = mt_rand(1, 100000);\n    }\n    asort($left);\n    asort($right);\n\
    \    $left = array_values($left);\n    $right = array_values($right);\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        $left_min = $left[$i];\n        $right_min\
    \ = $right[$i];\n        if ($left_min > $right_min) {\n            $closest_right\
    \ = $right[$i + 1];\n            if ($closest_right - $left_min < 0) {\n     \
    \           $collision++;\n            }\n        } else {\n            $closest_left\
    \ = $left[$i + 1];\n            if ($right_min - $closest_left < 0) {\n      \
    \          $collision++;\n            }\n        }\n    }\n    return $collision;\n\
    }\n\necho car_race_collision(2);", "  $cars_left_to_right = array();\n  $cars_right_to_left\
    \ = array();\n  for ($i = 0; $i < $n; $i++) {\n    $cars_left_to_right[] = $i;\n\
    \    $cars_right_to_left[] = $i;\n  }\n  $collisions = 0;\n  while(sizeof($cars_left_to_right)\
    \ > 0) {\n    $car_a = array_pop($cars_left_to_right);\n    $car_b = array_pop($cars_right_to_left);\n\
    \    if ($car_a == $car_b) {\n      $collisions++;\n    }\n  }\n  return $collisions;\n\
    }", "    $collisions = 0;\n    $left_cars = array();\n    $right_cars = array();\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $left_cars[$i] = $i;\n        $right_cars[$i]\
    \ = $i;\n    }\n    $left_cars_counter = 0;\n    $right_cars_counter = 0;\n  \
    \  $total_left_cars = $n;\n    $total_right_cars = $n;\n    while ($total_left_cars\
    \ > 0 || $total_right_cars > 0) {\n        if ($total_left_cars > 0) {\n     \
    \       // We have at least one left to right car\n            $left_car = $left_cars[$left_cars_counter];\n\
    \            if ($total_right_cars > 0) {\n                // We have at least\
    \ one right to left car\n                // Check if left car is greater than\
    \ right car; in that case, a collision occurred\n                $right_car =\
    \ $right_cars[$right_cars_counter];\n                if ($left_car > $right_car)\
    \ {\n                    $collisions++;\n                }\n            }\n  \
    \          // If we got here, then we increment the left cars counter, and decrement\
    \ the number of left cars\n            $left_cars_counter++;\n            $total_left_cars--;\n\
    \        } else {\n            // No more left to right cars, decrement right\
    \ cars counter, and decrement number of right cars\n            $right_cars_counter++;\n\
    \            $total_right_cars--;\n        }\n    }\n    return $collisions;\n\
    }", "    $collisions = 0;\n    $times = [];\n    $event_id = 1;\n\n    for ($i\
    \ = 0; $i < $n; $i++) {\n        // Each \"car\" is a hash that stores when it\
    \ will start its journey\n        // and when it will finish its journey.\n  \
    \      $start_time = rand(0, 9999999);\n        $end_time = $start_time + rand(0,\
    \ 9999999);\n        $times[] = [\n            'car' => [\n                'start_time'\
    \ => $start_time,\n                'end_time' => $end_time,\n            ],\n\
    \            'event_id' => $event_id++,\n        ];\n    }\n\n    usort($times,\
    \ function ($a, $b) {\n        return $a['car']['start_time'] - $b['car']['start_time'];\n\
    \    });\n\n    $pending_left_to_right = $times;\n    $pending_right_to_left =\
    \ array_reverse($times);\n\n    $left_to_right = [];\n    $right_to_left = [];\n\
    \n    // While there are cars that have left and have not arrived yet,\n    //\
    \ there is a chance of collision.\n    // We'll try to \"simulate\" the race in\
    \ this for loop.\n    for ($time = 0; count($pending_left_to_right) > 0 || count($pending_right_to_left)\
    \ > 0; $time++) {\n        // Check if any car has left and has not arrived yet.\n\
    \        if (count($pending_left_to_right) > 0) {\n            $closest_left_to_right\
    \ = $pending_left_to_right[0];\n            if ($closest_left_to_right['car']['start_time']\
    \ <= $time) {\n                // If a car has left, we add it to the active list.\n\
    \                $left_to_right[] = $closest_left_to_right;\n                array_shift($pending_left_to_right);\n\
    \            }\n        }\n\n        if (count($pending_right_to_left) > 0"]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
