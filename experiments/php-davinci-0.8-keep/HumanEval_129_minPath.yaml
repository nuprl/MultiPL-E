name: HumanEval_129_minPath
language: php
prompt: "<?php\n// Given a grid with N rows and N columns (N >= 2) and a positive\
  \ integer k, \n// each cell of the grid contains a value. Every integer in the range\
  \ [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You\
  \ have to find the minimum path of length k in the grid. You can start\n// from\
  \ any cell, and in each step you can move to any of the neighbor cells,\n// in other\
  \ words, you can go to cells which share an edge with you current\n// cell.\n//\
  \ Please note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered lists of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered list of the values on the cells that the minimum\
  \ path go through.\n// Examples:\n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]],\
  \ k = 3\n// Output: [1, 2, 1]\n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k\
  \ = 1\n// Output: [1]\nfunction minPath($grid, $k) {\n"
tests: "function candidate(...$args) {\n    return minPath(...$args);\n}\n\nfunction\
  \ test(): void {\n    if (candidate(array(array(1, 2, 3), array(4, 5, 6), array(7,\
  \ 8, 9)), 3) !== array(1, 2, 1)) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(array(array(5, 9, 3), array(4, 1, 6), array(7, 8, 2)), 1) !== array(1))\
  \ { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(array(1, 2,\
  \ 3, 4), array(5, 6, 7, 8), array(9, 10, 11, 12), array(13, 14, 15, 16)), 4) !==\
  \ array(1, 2, 1, 2)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(array(6,\
  \ 4, 13, 10), array(5, 7, 12, 1), array(3, 16, 11, 15), array(8, 14, 9, 2)), 7)\
  \ !== array(1, 10, 1, 10, 1, 10, 1)) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(array(array(8, 14, 9, 2), array(6, 4, 13, 15), array(5, 7, 1,\
  \ 12), array(3, 10, 11, 16)), 5) !== array(1, 7, 1, 7, 1)) { throw new Exception(\"\
  Test failed!\"); }\n    if (candidate(array(array(11, 8, 7, 2), array(5, 16, 14,\
  \ 4), array(9, 3, 15, 6), array(12, 13, 10, 1)), 9) !== array(1, 6, 1, 6, 1, 6,\
  \ 1, 6, 1)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(array(12,\
  \ 13, 10, 1), array(9, 3, 15, 6), array(5, 16, 14, 4), array(11, 8, 7, 2)), 12)\
  \ !== array(1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6)) { throw new Exception(\"Test failed!\"\
  ); }\n    if (candidate(array(array(2, 7, 4), array(3, 1, 5), array(6, 8, 9)), 8)\
  \ !== array(1, 3, 1, 3, 1, 3, 1, 3)) { throw new Exception(\"Test failed!\"); }\n\
  \    if (candidate(array(array(6, 1, 5), array(3, 8, 9), array(2, 7, 4)), 8) !==\
  \ array(1, 5, 1, 5, 1, 5, 1, 5)) { throw new Exception(\"Test failed!\"); }\n  \
  \  if (candidate(array(array(1, 2), array(3, 4)), 10) !== array(1, 2, 1, 2, 1, 2,\
  \ 1, 2, 1, 2)) { throw new Exception(\"Test failed!\"); }\n    if (candidate(array(array(1,\
  \ 3), array(3, 2)), 10) !== array(1, 3, 1, 3, 1, 3, 1, 3, 1, 3)) { throw new Exception(\"\
  Test failed!\"); }\n}\n\ntest();"
completions: ["    $row = count($grid);\n    $col = count($grid[0]);\n    $dp = array_fill(0,\
    \ $row, array_fill(0, $col, []));\n    $dp[0][0][$grid[0][0]] = true;\n    for\
    \ ($i = 0; $i < $row; $i++) {\n        for ($j = 0; $j < $col; $j++) {\n     \
    \       for ($t = 0; $t < $k; $t++) {\n                if ($i > 0) {\n       \
    \             $dp[$i][$j] = minPathHelper($dp[$i][$j], $dp[$i - 1][$j], $grid[$i][$j]);\n\
    \                }\n                if ($j > 0) {\n                    $dp[$i][$j]\
    \ = minPathHelper($dp[$i][$j], $dp[$i][$j - 1], $grid[$i][$j]);\n            \
    \    }\n            }\n        }\n    }\n    $res = [];\n    minPathHelperBacktrack($dp,\
    \ $res, $row - 1, $col - 1, $k);\n    return $res;\n}", "    if (count($grid)\
    \ === 0 || count($grid[0]) === 0) {\n        return [];\n    }\n    $N = count($grid);\n\
    \    $minPaths = [];\n    $minPaths[0] = array_fill(0, $N, array_fill(0, $N, []));\n\
    \    $minPaths[0][0][0] = $grid[0][0];\n    for ($i = 1; $i < $N; $i++) {\n  \
    \      $minPaths[0][$i][0] = $minPaths[0][$i - 1][0] < $grid[0][$i] ? $minPaths[0][$i\
    \ - 1][0] : $grid[0][$i];\n        $minPaths[0][0][$i] = $minPaths[0][0][$i -\
    \ 1] < $grid[0][$i] ? $minPaths[0][0][$i - 1] : $grid[0][$i];\n    }\n    for\
    \ ($i = 1; $i < $N; $i++) {\n        for ($j = 1; $j < $N; $j++) {\n         \
    \   $minPaths[0][$i][$j] = $minPaths[0][$i - 1][$j] < $minPaths[0][$i][$j - 1]\
    \ ? $minPaths[0][$i - 1][$j] : $minPaths[0][$i][$j - 1];\n            $minPaths[0][$i][$j]\
    \ = $minPaths[0][$i][$j] < $grid[$i][$j] ? $minPaths[0][$i][$j] : $grid[$i][$j];\n\
    \        }\n    }\n    if ($k <= 0) {\n        return [];\n    }\n    if ($k ===\
    \ 1) {\n        return [$minPaths[0][$N - 1][$N - 1]];\n    }\n    $maxCycle =\
    \ (int)floor($k / $N);\n    $maxCycle = $maxCycle >= count($minPaths) ?", "  \
    \  $m = count($grid);\n    $n = count($grid[0]);\n    $dp = array_fill(0, $m *\
    \ $n, null);\n    $dp[0] = [[$grid[0][0], 0, 0]];\n    $visited = array_fill(0,\
    \ $m * $n, false);\n    for ($i = 0; $i < $k; $i++) {\n        $dp_temp = array_fill(0,\
    \ $m * $n, null);\n        for ($l = 0; $l < $m * $n; $l++) {\n            if\
    \ (!isset($dp[$l])) {\n                continue;\n            }\n            $j\
    \ = count($dp[$l]) - 1;\n            $v = $dp[$l][$j][0];\n            $v_row\
    \ = $dp[$l][$j][1];\n            $v_col = $dp[$l][$j][2];\n            if ($v_row\
    \ - 1 >= 0 && !$visited[($v_row - 1) * $n + $v_col]) {\n                $visited[($v_row\
    \ - 1) * $n + $v_col] = true;\n                $dp_temp[($v_row - 1) * $n + $v_col]\
    \ = $dp[$l];\n                $dp_temp[($v_row - 1) * $n + $v_col][] = [$grid[$v_row\
    \ - 1][$v_col], $v_row - 1, $v_col];\n            }\n            if ($v_row +\
    \ 1 < $m && !$visited[($v_row + 1) * $n + $v_col]) {\n                $visited[($v_row\
    \ + 1) * $n + $v_col] = true;\n                $dp_temp[($v_row + 1) * $n + $v_col]\
    \ = $dp[$l];\n                $dp_temp[($v_row + 1) * $n + $v_col][] = [$grid[$v_row\
    \ + 1][$v_col], $v_row + 1, $", "    // Write your code here\n}\n", "    $m =\
    \ count($grid);\n    $n = count($grid[0]);\n    $res = [];\n    $dp = [];\n  \
    \  for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n    \
    \        $dp[$i][$j] = [];\n            for ($l = 0; $l < $k; $l++) {\n      \
    \          $dp[$i][$j][$l] = [];\n            }\n        }\n    }\n    for ($i\
    \ = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if\
    \ ($i == 0 && $j == 0) {\n                $dp[$i][$j][0][$grid[$i][$j]] = true;\n\
    \            } elseif ($i == 0) {\n                for ($l = 0; $l < $k; $l++)\
    \ {\n                    foreach ($dp[$i][$j - 1][$l] as $v => $used) {\n    \
    \                    $dp[$i][$j][$l][$v] = true;\n                    }\n    \
    \            }\n                $dp[$i][$j][0][$grid[$i][$j]] = true;\n      \
    \      } elseif ($j == 0) {\n                for ($l = 0; $l < $k; $l++) {\n \
    \                   foreach ($dp[$i - 1][$j][$l] as $v => $used) {\n         \
    \               $dp[$i][$j][$l][$v] = true;\n                    }\n         \
    \       }\n                $dp[$i][$j][0][$grid[$i][$j]] = true;\n           \
    \ } else {\n                for ($l = 0; $l < $k; $l++) {\n                  \
    \  foreach ($dp[$i - 1][$j][$l] as $v => $used) {\n                        $dp[$i][$j][$l][$v]\
    \ = true;\n                    }\n                    foreach ($dp[$i][$j - 1][$l]\
    \ as $v => $used) {\n                        $", "    $N = count($grid);\n   \
    \ $distance = [];\n    $q = new SplQueue();\n    $q->enqueue(['cost' => 0, 'r'\
    \ => 0, 'c' => 0, 'path' => [$grid[0][0]]]);\n    while (!$q->isEmpty()) {\n \
    \       $cur = $q->dequeue();\n        if ($cur['cost'] == $k) {\n           \
    \ return $cur['path'];\n        }\n        if (isset($distance[$cur['r']][$cur['c']][$cur['cost']]))\
    \ {\n            continue;\n        }\n        $distance[$cur['r']][$cur['c']][$cur['cost']]\
    \ = true;\n        $nextCost = $cur['cost'] + 1;\n        if ($cur['r'] + 1 <\
    \ $N) {\n            $nextRow = $cur['r'] + 1;\n            $nextCol = $cur['c'];\n\
    \            $nextPath = $cur['path'];\n            $nextPath[] = $grid[$nextRow][$nextCol];\n\
    \            $q->enqueue(['cost' => $nextCost, 'r' => $nextRow, 'c' => $nextCol,\
    \ 'path' => $nextPath]);\n        }\n        if ($cur['c'] + 1 < $N) {\n     \
    \       $nextRow = $cur['r'];\n            $nextCol = $cur['c'] + 1;\n       \
    \     $nextPath = $cur['path'];\n            $nextPath[] = $grid[$nextRow][$nextCol];\n\
    \            $q->enqueue(['cost' => $nextCost, 'r' => $nextRow, 'c' => $nextCol,\
    \ 'path' => $nextPath]);\n        }\n        if ($cur['r'] - 1 >= 0) {\n     \
    \       $nextRow = $cur['r'] - 1;\n            $nextCol = $cur['c'];\n       \
    \     $nextPath = $cur['path'];\n            $nextPath[] = $grid[$nextRow][$nextCol];\n\
    \            $q->enqueue(['cost' => $nextCost, 'r' => $nextRow, 'c' =>", "   \
    \ $n = count($grid);\n    $minLst = [];\n    $minSum = PHP_INT_MAX;\n    $board\
    \ = [];\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            $board[$i][$j] = ['val' => $grid[$i][$j], 'visited' => false];\n\
    \        }\n    }\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            minPathHelper($board, $i, $j, $k, $minLst, $minSum);\n\
    \        }\n    }\n    return $minLst;\n}", "    $m = count($grid);\n    $n =\
    \ count($grid[0]);\n    // D[i][j][l] = min( D[i-1][j][l-1], D[i+1][j][l-1], D[i][j-1][l-1],\
    \ D[i][j+1][l-1] )\n    $D = [];\n    for ($i = 0; $i < $m; $i++) {\n        for\
    \ ($j = 0; $j < $n; $j++) {\n            for ($l = 0; $l < $k; $l++) {\n     \
    \           $D[$i][$j][$l] = 0;\n            }\n        }\n    }\n    for ($i\
    \ = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            $D[$i][$j][0]\
    \ = $grid[$i][$j];\n        }\n    }\n    for ($l = 1; $l < $k; $l++) {\n    \
    \    for ($i = 0; $i < $m; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n\
    \                $up = ($i - 1 >= 0) ? $D[$i - 1][$j][$l - 1] : 99999;\n     \
    \           $down = ($i + 1 < $m) ? $D[$i + 1][$j][$l - 1] : 99999;\n        \
    \        $left = ($j - 1 >= 0) ? $D[$i][$j - 1][$l - 1] : 99999;\n           \
    \     $right = ($j + 1 < $n) ? $D[$i][$j + 1][$l - 1] : 99999;\n             \
    \   $min = min($up, $down, $left, $right);\n                $D[$i][$j][$l] = $min;\n\
    \            }\n        }\n    }\n    $res = [];\n    $i = 0;\n    $j = 0;\n \
    \   $l = $k - 1;\n    while ($l >= 0) {\n        $res[] =", "    $res = [];\n\
    \    $n = count($grid);\n    $queue = [[0, 0, $grid[0][0]]];\n    $visited = array_fill(0,\
    \ $n, array_fill(0, $n, false));\n    $visited[0][0] = true;\n    $minPath = PHP_INT_MAX;\n\
    \    $path = [];\n    while (!empty($queue)) {\n        [$row, $col, $sum] = array_shift($queue);\n\
    \        if ($sum > $minPath) {\n            continue;\n        }\n        if\
    \ ($sum >= $k) {\n            if ($sum < $minPath) {\n                $minPath\
    \ = $sum;\n                $path = [];\n            }\n            $path[] = $grid[$row][$col];\n\
    \            continue;\n        }\n        $dirs = [[-1, 0], [1, 0], [0, -1],\
    \ [0, 1]];\n        foreach ($dirs as [$di, $dj]) {\n            $i = $row + $di;\n\
    \            $j = $col + $dj;\n            if ($i < 0 || $i >= $n || $j < 0 ||\
    \ $j >= $n || $visited[$i][$j]) {\n                continue;\n            }\n\
    \            $visited[$i][$j] = true;\n            $queue[] = [$i, $j, $sum +\
    \ $grid[$i][$j]];\n        }\n    }\n    return $path;\n}\n", "    if (count($grid)\
    \ == 0 || count($grid[0]) == 0) {\n        return [];\n    }\n    $numRow = count($grid);\n\
    \    $numCol = count($grid[0]);\n    $minPath = [];\n    for ($row = 0; $row <\
    \ $numRow; $row++) {\n        for ($col = 0; $col < $numCol; $col++) {\n     \
    \       if ($k == 1) {\n                return [$grid[$row][$col]];\n        \
    \    }\n            $path = minPathRecur($grid, $k - 1, $row, $col);\n       \
    \     if (count($minPath) == 0 || comparePath($path, $minPath) < 0) {\n      \
    \          $minPath = $path;\n            }\n        }\n    }\n    return $minPath;\n\
    }", "    $n = count($grid);\n    $visited = array_fill(0, $n, array_fill(0, $n,\
    \ false));\n    $path = array();\n    $minPath = [];\n    $minSum = INF;\n   \
    \ for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n     \
    \       $path = [];\n            $sum = 0;\n            dfs($grid, $visited, $n,\
    \ $i, $j, $path, $sum, $k, $minPath, $minSum);\n        }\n    }\n    return $minPath;\n\
    }", "    $result = [];\n    $n = count($grid);\n    $queue = new SplQueue();\n\
    \    $visited = [];\n    $queue->enqueue([0, 0, 0]);\n    $visited[] = [0, 0];\n\
    \    while (!$queue->isEmpty()) {\n        $cur = $queue->dequeue();\n       \
    \ $x = $cur[0];\n        $y = $cur[1];\n        $len = $cur[2];\n        if ($len\
    \ == $k) {\n            $result[] = $grid[$x][$y];\n            break;\n     \
    \   }\n        if ($x > 0 && !in_array([$x - 1, $y], $visited)) {\n          \
    \  $queue->enqueue([$x - 1, $y, $len + 1]);\n            $visited[] = [$x - 1,\
    \ $y];\n        }\n        if ($x < $n - 1 && !in_array([$x + 1, $y], $visited))\
    \ {\n            $queue->enqueue([$x + 1, $y, $len + 1]);\n            $visited[]\
    \ = [$x + 1, $y];\n        }\n        if ($y > 0 && !in_array([$x, $y - 1], $visited))\
    \ {\n            $queue->enqueue([$x, $y - 1, $len + 1]);\n            $visited[]\
    \ = [$x, $y - 1];\n        }\n        if ($y < $n - 1 && !in_array([$x, $y + 1],\
    \ $visited)) {\n            $queue->enqueue([$x, $y + 1, $len + 1]);\n       \
    \     $visited[] = [$x, $y + 1];\n        }\n    }\n    return $result;\n}\n$grid\
    \ = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n$k = 3;\necho json_encode(minPath($grid,\
    \ $k)) . PHP_EOL;\n\n$grid = [\n    [5, 9, 3],\n    [4, 1, 6],\n    [7,", "  \
    \  $m = count($grid);\n    $n = count($grid[0]);\n    $paths = [];\n    // Do\
    \ BFS to find all paths of length k.\n    for ($i = 0; $i < $m; $i++) {\n    \
    \    for ($j = 0; $j < $n; $j++) {\n            $paths = array_merge($paths, BFS($grid,\
    \ $i, $j, $k));\n        }\n    }\n    // Compare the paths to get the minimum\
    \ path.\n    $minPath = $paths[0];\n    for ($i = 1; $i < count($paths); $i++)\
    \ {\n        $path = $paths[$i];\n        if (less($path, $minPath)) {\n     \
    \       $minPath = $path;\n        }\n    }\n    return $minPath;\n}", "    if\
    \ ($k === 0) {\n        return [];\n    }\n    if ($k === 1) {\n        return\
    \ [$grid[0][0]];\n    }\n    $table = [];\n    $table[0][0] = [$grid[0][0]];\n\
    \    $start = min($grid[0][0], $grid[0][1]);\n    $table[0][1] = [$start, $grid[0][1]];\n\
    \    for ($i = 1; $i < count($grid); $i++) {\n        $table[$i][0] = [$grid[$i][0]];\n\
    \        $start = min($grid[$i][0], $grid[$i-1][0]);\n        $table[$i-1][0]\
    \ = [$start, $grid[$i-1][0]];\n    }\n    for ($i = 1; $i < count($grid); $i++)\
    \ {\n        for ($j = 1; $j < count($grid); $j++) {\n            $up = $table[$i-1][$j];\n\
    \            $left = $table[$i][$j-1];\n            $path = [];\n            $iUp\
    \ = 0;\n            $iLeft = 0;\n            while ($iUp < count($up) && $iLeft\
    \ < count($left)) {\n                if ($up[$iUp] < $left[$iLeft]) {\n      \
    \              $path[] = $up[$iUp];\n                    $iUp++;\n           \
    \     } else if ($up[$iUp] > $left[$iLeft]) {\n                    $path[] = $left[$iLeft];\n\
    \                    $iLeft++;\n                } else {\n                   \
    \ $path[] = $up[$iUp];\n                    $iUp++;\n                    $iLeft++;\n\
    \                }\n            }\n            while ($iUp < count($up)) {\n \
    \               $path[] = $up[$iUp];\n                $iUp++;\n            }\n\
    \            while ($iLeft < count($left)) {\n                $path[] = $left[$iLeft];\n\
    \                $iLeft++;\n            }\n            if (count($path) < $k)\
    \ {\n               ", "    if ($k <= 0) {\n        return [];\n    }\n    $n\
    \ = count($grid);\n    if ($n == 0) {\n        return [];\n    }\n    $hash =\
    \ new Heap();\n    $path = [];\n    $hash->add(['', 0], $grid[0][0]);\n    while\
    \ (count($path) < $k) {\n        $node = $hash->pop();\n        $key = $node['key'];\n\
    \        $path[] = $node['value'];\n        $i = (int)substr($key, 0, -1);\n \
    \       $j = (int)substr($key, -1);\n        if ($i + 1 < $n) {\n            $hash->add($key\
    \ . ($j . '1'), $grid[$i + 1][$j]);\n        }\n        if ($j + 1 < $n) {\n \
    \           $hash->add($key . ($j . '2'), $grid[$i][$j + 1]);\n        }\n   \
    \ }\n    return $path;\n}\n\n$grid = [\n    [1,2,3],\n    [4,5,6],\n    [7,8,9]\n\
    ];\n$k = 3;\n$output = minPath($grid, $k);\nprint_r($output);\n\n$grid = [\n \
    \   [5,9,3],\n    [4,1,6],\n    [7,8,2]\n];\n$k = 1;\n$output = minPath($grid,\
    \ $k);\nprint_r($output);", "    $n = count($grid);\n    $start = [0, 0];\n  \
    \  $x = $start[0];\n    $y = $start[1];\n    $path = [];\n    $minPath = [];\n\
    \    $min = PHP_INT_MAX;\n    helper($grid, $x, $y, $k, $start, $n, $path, $minPath,\
    \ $min);\n    return $minPath;\n}", "    $size = count($grid);\n    // dp[i][j][k]\
    \ refers to the minimum list of the values on the cells that\n    // a path of\
    \ length k go through, starting from cell (i, j).\n    $dp = [];\n    // The maximum\
    \ integer used in this grid.\n    $maxVal = $size * $size;\n    // Initialization.\n\
    \    for ($i = 0; $i < $size; $i++) {\n        for ($j = 0; $j < $size; $j++)\
    \ {\n            $dp[$i][$j][0] = [$grid[$i][$j]];\n        }\n    }\n    // Answer.\n\
    \    $ans = [];\n    for ($step = 1; $step <= $k; $step++) {\n        for ($i\
    \ = 0; $i < $size; $i++) {\n            for ($j = 0; $j < $size; $j++) {\n   \
    \             $dp[$i][$j][$step] = [$maxVal];\n                $neighbors = getNeighbors($i,\
    \ $j, $size);\n                foreach ($neighbors as $neighbor) {\n         \
    \           list($ii, $jj) = $neighbor;\n                    $curr = $dp[$ii][$jj][$step\
    \ - 1];\n                    $curr[] = $grid[$i][$j];\n                    if\
    \ (less($curr, $dp[$i][$j][$step])) {\n                        $dp[$i][$j][$step]\
    \ = $curr;\n                    }\n                }\n                if ($step\
    \ == $k) {\n                    if (less($dp[$i][$j][$step], $ans)) {\n      \
    \                  $ans = $dp[$i][$j][$step];\n                    }\n       \
    \         }\n            }\n        }\n    }\n    return $ans;\n}", "    if ($k\
    \ <= 0) {\n        return [];\n    }\n    $n = count($grid);\n    if ($n == 0)\
    \ {\n        return [];\n    }\n    if ($k >= $n * $n) {\n        return range(1,\
    \ $n * $n);\n    }\n    $path = [];\n    $visited = [];\n    for ($i = 0; $i <\
    \ $n; $i++) {\n        $visited[] = array_fill(0, $n, false);\n    }\n    $minPath\
    \ = array_fill(0, $k, -1);\n    $minPathLen = PHP_INT_MAX;\n    for ($i = 0; $i\
    \ < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            $path = [];\n\
    \            _minPathHelper($grid, $i, $j, $k, $n, $visited, $path, 0, $minPath,\
    \ $minPathLen);\n        }\n    }\n    return $minPath;\n}", "    if ($k == 0)\
    \ {\n        return [];\n    }\n    if ($k == 1) {\n        return [$grid[0][0]];\n\
    \    }\n    $dict = [];\n    for ($i = 0; $i < count($grid); $i++) {\n       \
    \ for ($j = 0; $j < count($grid[0]); $j++) {\n            $dict[$grid[$i][$j]]\
    \ = [$i, $j];\n        }\n    }\n    $min_grid = $grid;\n    for ($i = 0; $i <\
    \ count($grid); $i++) {\n        for ($j = 0; $j < count($grid[0]); $j++) {\n\
    \            $min_grid[$i][$j] = 0;\n        }\n    }\n    $d = [0, 0, 0, 1, -1];\n\
    \    $min_grid[0][0] = $grid[0][0];\n    for ($i = 1; $i < $k; $i++) {\n     \
    \   $curr_min = PHP_INT_MAX;\n        for ($l = 0; $l < count($d); $l++) {\n \
    \           $x = $dict[$min_grid[$i - 1][0]][0] + $d[$l];\n            $y = $dict[$min_grid[$i\
    \ - 1][0]][1] + $d[$l + 1];\n            if ($x >= 0 && $x < count($grid) && $y\
    \ >= 0 && $y < count($grid[0])) {\n                $num = $grid[$x][$y];\n   \
    \             if ($num < $curr_min) {\n                    $curr_min = $num;\n\
    \                }\n            }\n        }\n        $min_grid[$i][0] = $curr_min;\n\
    \    }\n    for ($i = 1; $i < $k; $i++) {\n        $curr_min = PHP_INT_MAX;\n\
    \        for ($l = 0; $l < count($d); $l++) {\n            $x = $dict[$min_grid[0][$i\
    \ - 1]][0] + $", "    $dp = [];\n    $rows = count($grid);\n    $cols = count($grid[0]);\n\
    \    $dp[0][0] = [$grid[0][0]];\n    for ($i = 1; $i < $rows; $i++) {\n      \
    \  $dp[$i][0] = array_merge($dp[$i - 1][0], [$grid[$i][0]]);\n    }\n    for ($j\
    \ = 1; $j < $cols; $j++) {\n        $dp[0][$j] = array_merge($dp[0][$j - 1], [$grid[0][$j]]);\n\
    \    }\n    for ($i = 1; $i < $rows; $i++) {\n        for ($j = 1; $j < $cols;\
    \ $j++) {\n            $dp[$i][$j] = array_merge($dp[$i - 1][$j], [$grid[$i][$j]]);\n\
    \            if (compare($dp[$i][$j - 1], $dp[$i][$j]) == -1) {\n            \
    \    $dp[$i][$j] = array_merge($dp[$i][$j - 1], [$grid[$i][$j]]);\n          \
    \  }\n        }\n    }\n    return $dp[$rows - 1][$cols - 1];\n}", "    $N = count($grid);\n\
    \    $index = -1;\n    $values = [];\n    $min = INF;\n    for ($i = 0; $i < $N;\
    \ $i++) {\n        for ($j = 0; $j < $N; $j++) {\n            $sum = helper($grid,\
    \ $i, $j, $k, $N, $values);\n            if ($sum < $min) {\n                $min\
    \ = $sum;\n                $index = count($values) - 1;\n            }\n     \
    \   }\n    }\n    return array_slice($values, 0, $index + 1);\n}", "    if ($k\
    \ <= 0) {\n        return [];\n    }\n    $rows = count($grid);\n    $cols = count($grid[0]);\n\
    \    $nums = [];\n    $result = [];\n    for ($i = 0; $i < $rows; $i++) {\n  \
    \      for ($j = 0; $j < $cols; $j++) {\n            $nums[] = $grid[$i][$j];\n\
    \        }\n    }\n    sort($nums);\n    $visited = [];\n    $len = count($nums);\n\
    \    for ($i = 0; $i < $len; $i++) {\n        $visited[$nums[$i]] = false;\n \
    \   }\n    $cur_row = 0;\n    $cur_col = 0;\n    $total = 0;\n    while ($cur_row\
    \ >= 0 && $cur_row < $rows && $cur_col >= 0 && $cur_col < $cols) {\n        $result[]\
    \ = $grid[$cur_row][$cur_col];\n        $visited[$grid[$cur_row][$cur_col]] =\
    \ true;\n        $total++;\n        $next_row = $cur_row;\n        $next_col =\
    \ $cur_col;\n        if ($cur_row + 1 < $rows && ($visited[$grid[$cur_row + 1][$cur_col]]\
    \ || $grid[$cur_row + 1][$cur_col] < $grid[$next_row][$next_col])) {\n       \
    \     $next_row = $cur_row + 1;\n            $next_col = $cur_col;\n        }\n\
    \        if ($cur_row - 1 >= 0 && ($visited[$grid[$cur_row - 1][$cur_col]] ||\
    \ $grid[$cur_row - 1][$cur_col] < $grid[$next_row][$next_col])) {\n          \
    \  $next_row = $cur_row - 1;\n            $next_col = $cur_col;\n        }\n \
    \       if ($cur_col + 1 < $cols && ($visited[$grid[$cur_row][$", "    // Initialize\
    \ minPath and minVal\n    $minPath = [];\n    $minVal = INF;\n    // Process every\
    \ cell\n    for ($i = 0; $i < sizeof($grid); $i++) {\n        for ($j = 0; $j\
    \ < sizeof($grid[$i]); $j++) {\n            // Recursively try paths starting\
    \ from this cell\n            $path = findMinPath([$i, $j], $grid, $k);\n    \
    \        // If path is of right length, check minVal and minPath\n           \
    \ if (sizeof($path) == $k) {\n                if ($path[0] < $minVal) {\n    \
    \                $minVal = $path[0];\n                    $minPath = $path;\n\
    \                }\n            }\n        }\n    }\n    return $minPath;\n}",
  "    $size = count($grid);\n    $visited = [];\n    $queue = new SplQueue();\n \
    \   $queue->enqueue([$grid[0][0], 0, 0]);\n    $visited[0][0] = true;\n    $minPath\
    \ = [];\n    $currentPath = [];\n    $step = 0;\n    while (!$queue->isEmpty())\
    \ {\n        $temp = $queue->dequeue();\n        $value = $temp[0];\n        $x\
    \ = $temp[1];\n        $y = $temp[2];\n        $currentPath[] = $value;\n    \
    \    if ($step == $k - 1) {\n            if ($value < $minPath[$k - 1] || count($minPath)\
    \ == 0) {\n                $minPath = $currentPath;\n            }\n         \
    \   $currentPath = [];\n            $step = 0;\n        } else {\n           \
    \ $step++;\n        }\n        $neighbors = [[$x + 1, $y], [$x - 1, $y], [$x,\
    \ $y + 1], [$x, $y - 1]];\n        foreach ($neighbors as $neighbor) {\n     \
    \       $x = $neighbor[0];\n            $y = $neighbor[1];\n            if ($x\
    \ >= 0 && $x < $size && $y >= 0 && $y < $size && !$visited[$x][$y]) {\n      \
    \          $visited[$x][$y] = true;\n                $queue->enqueue([$grid[$x][$y],\
    \ $x, $y]);\n            }\n        }\n    }\n    return $minPath;\n}\n$grid =\
    \ [ [1,2,3], [4,5,6], [7,8,9]];\n$k = 3;\n$grid = [ [5,9,3], [4,1,6], [7,8,2]];\n\
    $k = 1;\n$grid = [ [3,5,9], [4,1,6], [7,8,2]];\n$k = 1;\necho json_encode(minPath($grid,\
    \ $k)) . PHP_EOL", "    $n = count($grid);\n    $vals = [];\n    $precompute =\
    \ [];\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            $val = $grid[$i][$j];\n            $vals[$val] = [$i, $j];\n\
    \            $precompute[$i][$j] = [$val];\n        }\n    }\n    for ($k = 2;\
    \ $k <= $n * $n; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for\
    \ ($j = 0; $j < $n; $j++) {\n                $val = $vals[$k][0];\n          \
    \      $val2 = $vals[$k][1];\n                $prev_1 = $precompute[$i][$j][0];\n\
    \                $prev_2 = $precompute[$i][$j][1];\n                $prev_3 =\
    \ $precompute[$i][$j][2];\n                $new_1 = $val;\n                $new_2\
    \ = $val2;\n                $new_3 = $prev_3;\n                if ($prev_3 < $k\
    \ - 1) {\n                    $new_3 = $prev_3 + 1;\n                }\n     \
    \           if ($i > 0 && $precompute[$i - 1][$j][0] === $prev_1 && $precompute[$i\
    \ - 1][$j][1] === $prev_2 && $precompute[$i - 1][$j][2] + 1 === $prev_3) {\n \
    \                   $new_1 = $val;\n                    $new_2 = $val2;\n    \
    \                $new_3 = $prev_3;\n                }\n                if ($i\
    \ < $n - 1 && $precompute[$i + 1][$j][0] === $prev_1 && $precompute[$i + 1][$j][1]\
    \ === $prev_2 && $precompute[$i + 1][$j][2] + 1 === $prev_3) {\n             \
    \       $new", "    $path = [];\n    $n = count($grid);\n    $canVisit = [1];\n\
    \    $path[] = $grid[0][0];\n    findNextStep($grid, $n, $canVisit, $path, $k);\n\
    \    return $path;\n}", "    if ($k == 0) {\n        return [];\n    }\n    if\
    \ ($k == 1) {\n        return [$grid[0][0]];\n    }\n    $visited = [];\n    for\
    \ ($i = 0; $i < count($grid); $i++) {\n        $visited[] = array_fill(0, count($grid),\
    \ false);\n    }\n    $best = [];\n    for ($i = 0; $i < count($grid); $i++) {\n\
    \        for ($j = 0; $j < count($grid); $j++) {\n            $best[] = PHP_INT_MAX;\n\
    \        }\n    }\n    $q = [];\n    $q[] = [0, 0, 0];\n    $visited[0][0] = true;\n\
    \    $best[0][0] = $grid[0][0];\n    while (!empty($q)) {\n        $cur = array_shift($q);\n\
    \        $row = $cur[0];\n        $col = $cur[1];\n        $depth = $cur[2];\n\
    \        if ($depth == $k - 1) {\n            continue;\n        }\n        $neighbors\
    \ = [];\n        if ($row > 0) {\n            $neighbors[] = [$row - 1, $col];\n\
    \        }\n        if ($row < count($grid) - 1) {\n            $neighbors[] =\
    \ [$row + 1, $col];\n        }\n        if ($col > 0) {\n            $neighbors[]\
    \ = [$row, $col - 1];\n        }\n        if ($col < count($grid) - 1) {\n   \
    \         $neighbors[] = [$row, $col + 1];\n        }\n        foreach ($neighbors\
    \ as $n) {\n            $nrow = $n[0];\n            $ncol = $n[1];\n         \
    \   if ($visited[$nrow][$ncol]) {\n                continue;\n            }\n\
    \            $visited[$nrow][$ncol] = true;\n            $best[$nrow][$ncol] =\
    \ $best[$row][$col] + $grid[$nrow][$ncol];", "    // BFS traversal\n    $x = $y\
    \ = 0;\n    $len = count($grid);\n    $visited = [];\n    $queue = new SplQueue();\n\
    \    $queue->enqueue([$x, $y, [$grid[$x][$y]]]);\n    $visited[$x][$y] = true;\n\
    \    while (!$queue->isEmpty()) {\n        list($x, $y, $path) = $queue->dequeue();\n\
    \        if (count($path) === $k) {\n            return $path;\n        }\n  \
    \      // try to move the x-coordinate\n        if ($x - 1 >= 0 && !$visited[$x\
    \ - 1][$y]) {\n            $queue->enqueue([$x - 1, $y, array_merge($path, [$grid[$x\
    \ - 1][$y]])]);\n            $visited[$x - 1][$y] = true;\n        }\n       \
    \ if ($x + 1 < $len && !$visited[$x + 1][$y]) {\n            $queue->enqueue([$x\
    \ + 1, $y, array_merge($path, [$grid[$x + 1][$y]])]);\n            $visited[$x\
    \ + 1][$y] = true;\n        }\n        // try to move the y-coordinate\n     \
    \   if ($y - 1 >= 0 && !$visited[$x][$y - 1]) {\n            $queue->enqueue([$x,\
    \ $y - 1, array_merge($path, [$grid[$x][$y - 1]])]);\n            $visited[$x][$y\
    \ - 1] = true;\n        }\n        if ($y + 1 < $len && !$visited[$x][$y + 1])\
    \ {\n            $queue->enqueue([$x, $y + 1, array_merge($path, [$grid[$x][$y\
    \ + 1]])]);\n            $visited[$x][$y + 1] = true;\n        }\n    }\n}\n$grid\
    \ = [\n    [1,2,3],\n    [4,5,6],\n   ", "    $n = count($grid);\n    if ($n ==\
    \ 0) {\n        return [];\n    }\n    if ($k <= 0) {\n        return [];\n  \
    \  }\n    $m = count($grid[0]);\n    $found = false;\n    $result = [];\n    $lists\
    \ = [];\n    $lists[0] = [0, -1];\n    while (!$found && count($lists) > 0) {\n\
    \        $size = count($lists);\n        $listsNext = [];\n        for ($i = 0;\
    \ $i < $size; $i++) {\n            $list = $lists[$i];\n            if (count($list)\
    \ == $k) {\n                $found = true;\n                $result = $list;\n\
    \                break;\n            }\n            $last = $list[count($list)\
    \ - 1];\n            $row = intdiv($last, $m);\n            $col = $last % $m;\n\
    \            $neighbors = [$row * $m + $col + 1, ($row + 1) * $m + $col, $row\
    \ * $m + $col - 1, ($row - 1) * $m + $col];\n            $neighborsNew = [];\n\
    \            foreach ($neighbors as $neighbor) {\n                if (in_array($neighbor,\
    \ $list)) {\n                    continue;\n                }\n              \
    \  if ($neighbor < 0 || $neighbor >= $n * $m) {\n                    continue;\n\
    \                }\n                $rowNeighbor = intdiv($neighbor, $m);\n  \
    \              $colNeighbor = $neighbor % $m;\n                if ($rowNeighbor\
    \ < 0 || $rowNeighbor >= $n || $colNeighbor < 0 || $colNeighbor >= $m) {\n   \
    \                 continue;\n                }\n                $neighborsNew[]\
    \ = $neighbor;\n            }\n            foreach ($neighborsNew as $neighbor)\
    \ {\n                $listNew = $list;\n                $listNew[] = $neighbor;\n\
    \                $listsNext[] = $listNew;\n            }\n        }\n        $lists\
    \ = $listsNext;\n    }\n    if (!$found)", "    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    if ($k == 1) {\n        return [$grid[0][0]];\n    }\n    if ($k == $m *\
    \ $n) {\n        return range(1, $m * $n);\n    }\n    $i = 0;\n    $j = 0;\n\
    \    $minPaths = [];\n    while (true) {\n        list($i, $j) = getMin($grid,\
    \ $m, $n, $i, $j);\n        $minPaths[] = $grid[$i][$j];\n        if (count($minPaths)\
    \ == $k) {\n            return $minPaths;\n        }\n        if ($i == $m - 1\
    \ && $j == $n - 1) {\n            break;\n        }\n    }\n    $maxPaths = [];\n\
    \    $i = $m - 1;\n    $j = $n - 1;\n    while (true) {\n        list($i, $j)\
    \ = getMax($grid, $m, $n, $i, $j);\n        $maxPaths[] = $grid[$i][$j];\n   \
    \     if (count($maxPaths) == $k - count($minPaths)) {\n            return array_merge($minPaths,\
    \ array_reverse($maxPaths));\n        }\n        if ($i == 0 && $j == 0) {\n \
    \           break;\n        }\n    }\n}", "    if ($k <= 0) {\n        return\
    \ [];\n    }\n    if ($k == 1) {\n        return [$grid[0][0]];\n    }\n    $n\
    \ = count($grid);\n    $bestValue = INF;\n    $bestPath = [];\n    $isVisited\
    \ = array_fill(0, $n, array_fill(0, $n, false));\n    $q = new SplQueue();\n \
    \   $q->enqueue([0, 0, 0, []]);\n    while (!$q->isEmpty()) {\n        list($i,\
    \ $j, $cost, $path) = $q->dequeue();\n        if ($cost > $k) {\n            continue;\n\
    \        }\n        if ($i < 0 || $i >= $n || $j < 0 || $j >= $n) {\n        \
    \    continue;\n        }\n        if ($isVisited[$i][$j]) {\n            continue;\n\
    \        }\n        $path[] = $grid[$i][$j];\n        if ($cost == $k) {\n   \
    \         if ($path[0] < $bestValue) {\n                $bestValue = $path[0];\n\
    \                $bestPath = $path;\n            }\n            continue;\n  \
    \      }\n        $isVisited[$i][$j] = true;\n        $q->enqueue([$i - 1, $j,\
    \ $cost + 1, $path]);\n        $q->enqueue([$i + 1, $j, $cost + 1, $path]);\n\
    \        $q->enqueue([$i, $j - 1, $cost + 1, $path]);\n        $q->enqueue([$i,\
    \ $j + 1, $cost + 1, $path]);\n    }\n    return $bestPath;\n}\n$grid = [\n  \
    \  [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n$k = 3;\necho implode(', ',\
    \ minPath($grid, $k)) . PHP_EOL;\n$grid = [\n    [5, 9, 3],\n    [4, 1, 6],\n\
    \    [7, 8, 2]\n];\n$", "    $m = count($grid);\n    $n = count($grid[0]);\n \
    \   $visited = [];\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            $visited[$i][$j] = false;\n        }\n    }\n   \
    \ $q = new SplQueue();\n    $q->enqueue([0, 0, 0, $grid[0][0]]);\n    $minPath\
    \ = null;\n    while (!$q->isEmpty()) {\n        $item = $q->dequeue();\n    \
    \    $i = $item[0];\n        $j = $item[1];\n        $curLength = $item[2];\n\
    \        $curPath = $item[3];\n        $visited[$i][$j] = true;\n        if ($curLength\
    \ === $k) {\n            if ($minPath === null) {\n                $minPath =\
    \ $curPath;\n            } else {\n                if ($curPath < $minPath) {\n\
    \                    $minPath = $curPath;\n                }\n            }\n\
    \        } else {\n            if ($i - 1 >= 0 && !$visited[$i - 1][$j]) {\n \
    \               $curPathArr = str_split($curPath);\n                $curPathArr[]\
    \ = $grid[$i - 1][$j];\n                $q->enqueue([$i - 1, $j, $curLength +\
    \ 1, implode($curPathArr)]);\n            }\n            if ($i + 1 < $m && !$visited[$i\
    \ + 1][$j]) {\n                $curPathArr = str_split($curPath);\n          \
    \      $curPathArr[] = $grid[$i + 1][$j];\n                $q->enqueue([$i + 1,\
    \ $j, $curLength + 1, implode($curPathArr)]);\n            }\n            if ($j\
    \ - 1 >= 0 && !$visited[$i][$j - 1]) {\n                $curPathArr = str_split($curPath);\n\
    \                $curPathArr[] = $grid[$i][", "    $res = [];\n    for ($i = 0;\
    \ $i < $k; $i++) {\n        $res[] = minPathStep($grid, $res, $k - $i);\n    }\n\
    \    return $res;\n}\n", "    $colSize = count($grid);\n    $rowSize = count($grid[0]);\n\
    \    $minPath = [];\n    $gridMap = [];\n    for ($i = 0; $i < $colSize; $i++)\
    \ {\n        for ($j = 0; $j < $rowSize; $j++) {\n            $gridMap[$grid[$i][$j]]\
    \ = [$i, $j];\n        }\n    }\n    for ($i = 1; $i <= $colSize * $rowSize; $i++)\
    \ {\n        $col = $gridMap[$i][0];\n        $row = $gridMap[$i][1];\n      \
    \  $newPath = [];\n        for ($j = 0; $j < $k; $j++) {\n            if ($j ==\
    \ 0) {\n                $newPath = [$i];\n            } else {\n             \
    \   $path = $newPath;\n                $newPath = [];\n                foreach\
    \ ($path as $val) {\n                    $newPath[] = $val;\n                \
    \    $curCol = $gridMap[$val][0];\n                    $curRow = $gridMap[$val][1];\n\
    \                    // left\n                    if ($curRow - 1 >= 0 && \n \
    \                       $grid[$curCol][$curRow - 1] < $grid[$curCol][$curRow])\
    \ {\n                        $newPath[] = $grid[$curCol][$curRow - 1];\n     \
    \               }\n                    // right\n                    if ($curRow\
    \ + 1 < $rowSize && \n                        $grid[$curCol][$curRow + 1] < $grid[$curCol][$curRow])\
    \ {\n                        $newPath[] = $grid[$curCol][$curRow + 1];\n     \
    \               }\n                    // up\n                    if ($curCol\
    \ - 1 >= 0 && \n                        $grid[$curCol - 1][$curRow] < $grid[$curCol][$curRow])\
    \ {\n                        $newPath[] = $grid[$curCol - 1][$curRow];\n     \
    \               }\n                    // down\n                    if ($curCol\
    \ + 1 < $colSize && \n                        $grid[$curCol + 1][$curRow] < $grid[$cur",
  "    $min = [];\n    for ($row = 0; $row < count($grid); $row++) {\n        for\
    \ ($col = 0; $col < count($grid[$row]); $col++) {\n            $cur = [];\n  \
    \          $dfs($row, $col, $cur, $k);\n            if (count($cur) > 0 && (count($min)\
    \ == 0 || $cur < $min)) {\n                $min = $cur;\n            }\n     \
    \   }\n    }\n    return $min;\n}\n", "    if ($k <= 0) {\n        return [];\n\
    \    }\n    if ($k == 1) {\n        return [$grid[0][0]];\n    }\n    $c = count($grid);\n\
    \    if ($c == 1) {\n        return [$grid[0][0]];\n    }\n    $cost = [];\n \
    \   $cost[0][0] = $grid[0][0];\n    for ($i = 1; $i < $c; $i++) {\n        $cost[0][$i]\
    \ = $cost[0][$i - 1] + $grid[0][$i];\n    }\n    for ($i = 1; $i < $c; $i++) {\n\
    \        $cost[$i][0] = $cost[$i - 1][0] + $grid[$i][0];\n    }\n    for ($i =\
    \ 1; $i < $c; $i++) {\n        for ($j = 1; $j < $c; $j++) {\n            $cost[$i][$j]\
    \ = min($cost[$i - 1][$j], $cost[$i][$j - 1]) + $grid[$i][$j];\n        }\n  \
    \  }\n    if ($cost[$c - 1][$c - 1] < $k) {\n        return [];\n    }\n    $row\
    \ = $c - 1;\n    $col = $c - 1;\n    $path = [];\n    $path[] = $grid[$row][$col];\n\
    \    while ($row > 0 || $col > 0) {\n        if ($row > 0 && $col > 0) {\n   \
    \         if ($cost[$row - 1][$col] < $cost[$row][$col - 1]) {\n             \
    \   $row--;\n            } else {\n                $col--;\n            }\n  \
    \      } else if ($row > 0) {\n            $row--;\n        } else {\n       \
    \     $col--;\n        }\n        $path[] = $grid[$row][$col];\n    }\n    $path\
    \ = array_reverse($path);\n    $len = count($path);\n    if ($len > $k) {\n  \
    \      $path", "    $N = count($grid);\n    $res = [];\n    if ($k > $N * $N)\
    \ {\n        return $res;\n    }\n    $visited = array_fill(0, $N, array_fill(0,\
    \ $N, 0));\n    $grid[0][0] > $grid[$N - 1][$N - 1] ? $min = $grid[$N - 1][$N\
    \ - 1] : $min = $grid[0][0];\n    for ($i = 0; $i < $N; $i++) {\n        for ($j\
    \ = 0; $j < $N; $j++) {\n            if ($grid[$i][$j] < $min) {\n           \
    \     $min = $grid[$i][$j];\n            }\n        }\n    }\n    dfs($grid, $N,\
    \ 0, 0, 0, $visited, $k, [], [], $min);\n    foreach ($result as $item) {\n  \
    \      $res[] = $item;\n    }\n    return $res;\n}\n", "    $rows = count($grid);\n\
    \    $cols = count($grid[0]);\n    $minPath = [];\n    $path = [];\n    $minSum\
    \ = INF;\n    $min = INF;\n    $sum = 0;\n    for ($i = 0; $i < $rows; $i++) {\n\
    \        for ($j = 0; $j < $cols; $j++) {\n            $sum = $grid[$i][$j];\n\
    \            $path = [];\n            $path[] = $grid[$i][$j];\n            $minPath\
    \ = [];\n            $min = INF;\n            $minPath[] = $grid[$i][$j];\n  \
    \          minPathHelper($grid, $k - 1, $i, $j, $rows, $cols, $path, $sum, $min,\
    \ $minPath);\n            if ($sum < $minSum) {\n                $minSum = $sum;\n\
    \                $minPath = $path;\n            }\n        }\n    }\n    return\
    \ $minPath;\n}", "\tif (empty($grid) || empty($grid[0])) {\n\t\treturn [];\n\t\
    }\n\t$path = [];\n\t$min = INF;\n\t$m = count($grid);\n\t$n = count($grid[0]);\n\
    \tfor ($i = 0; $i < $m; $i++) {\n\t\tfor ($j = 0; $j < $n; $j++) {\n\t\t\t$path[]\
    \ = [\n\t\t\t\t[$i, $j],\n\t\t\t\t[$grid[$i][$j]]\n\t\t\t];\n\t\t}\n\t}\n\twhile\
    \ ($k-- > 0) {\n\t\t$next = [];\n\t\tforeach ($path as $item) {\n\t\t\tlist($path,\
    \ $val) = $item;\n\t\t\t$x = $path[count($path) - 1][0];\n\t\t\t$y = $path[count($path)\
    \ - 1][1];\n\t\t\t$steps = [\n\t\t\t\t[$x + 1, $y],\n\t\t\t\t[$x - 1, $y],\n\t\
    \t\t\t[$x, $y + 1],\n\t\t\t\t[$x, $y - 1]\n\t\t\t];\n\t\t\tforeach ($steps as\
    \ $step) {\n\t\t\t\tif (valid($step, $m, $n)) {\n\t\t\t\t\t$copy = $path;\n\t\t\
    \t\t\t$copy[] = $step;\n\t\t\t\t\t$val2 = $val;\n\t\t\t\t\t$val2[] = $grid[$step[0]][$step[1]];\n\
    \t\t\t\t\t$next[] = [$copy, $val2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$path = $next;\n\
    \t}\n\tforeach ($path as $item) {\n\t\tlist($path, $val) = $item;\n\t\t$count\
    \ = count($val);\n\t\tfor ($i = 0; $i < $count; $i++) {\n\t\t\tif ($val[$i] <\
    \ $min) {\n\t\t\t\t$min =", "    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $seen = [];\n    $queue = new SplQueue();\n    $queue->enqueue([0, 0, [$grid[0][0]]]);\n\
    \    $best = null;\n    while (!$queue->isEmpty()) {\n        list($i, $j, $path)\
    \ = $queue->dequeue();\n        $u = $i * $n + $j;\n        if (isset($seen[$u]))\
    \ {\n            continue;\n        }\n        $seen[$u] = true;\n        $path[]\
    \ = $grid[$i][$j];\n        if (count($path) > $k) {\n            continue;\n\
    \        }\n        if (count($path) == $k) {\n            if ($best === null\
    \ || $path < $best) {\n                $best = $path;\n            }\n       \
    \     continue;\n        }\n        $neighbors = [];\n        if ($i > 0) {\n\
    \            $neighbors[] = [$i - 1, $j];\n        }\n        if ($i < $m - 1)\
    \ {\n            $neighbors[] = [$i + 1, $j];\n        }\n        if ($j > 0)\
    \ {\n            $neighbors[] = [$i, $j - 1];\n        }\n        if ($j < $n\
    \ - 1) {\n            $neighbors[] = [$i, $j + 1];\n        }\n        foreach\
    \ ($neighbors as $neighbor) {\n            list($ii, $jj) = $neighbor;\n     \
    \       $queue->enqueue([$ii, $jj, $path]);\n        }\n    }\n    return $best;\n\
    }", "    // TODO\n}\n", "    $n = count($grid);\n    $m = count($grid[0]);\n \
    \   // we will keep track of the visited cells so that we don't repeat visiting\n\
    \    // cells\n    $visited = [];\n    for ($i = 0; $i < $n; $i++) {\n       \
    \ for ($j = 0; $j < $m; $j++) {\n            $visited[$i][$j] = false;\n     \
    \   }\n    }\n    // we will keep track of the paths in a queue\n    $queue =\
    \ new SplQueue();\n    // if we start at the cell at row 0 and column 0\n    $queue->enqueue([0,\
    \ 0, [$grid[0][0]]]);\n    // we will keep track of the minimum path in this variable\n\
    \    $minPath = null;\n    while (!$queue->isEmpty()) {\n        // get the first\
    \ path from the queue\n        $path = $queue->dequeue();\n        // get the\
    \ coordinates of the last node from the path\n        $curX = $path[0];\n    \
    \    $curY = $path[1];\n        // make sure that the path is of length k\n  \
    \      if (count($path[2]) === $k) {\n            // if minPath is null, we found\
    \ the first path of length k,\n            // make the minPath equal to this path\n\
    \            if ($minPath === null) {\n                $minPath = $path[2];\n\
    \            } else {\n                // we need to compare the current path\
    \ with the minPath\n                // get the last node's value of the current\
    \ path\n                $curVal = $path[2][$k - 1];\n                // get the\
    \ last node's value of the minPath\n                $minVal = $minPath[$k - 1];\n\
    \                // if the last node's value of the current path is less than\n\
    \                // the last node's value of the minPath, the current path is\n\
    \                // less than the minPath\n                if ($curVal < $minVal)\
    \ {\n                    $minPath = $path[2];\n                } else if ($curVal\
    \ === $minVal) {\n                    // if the last node's value of the current\
    \ path is equal to\n                    // the last node's value of the minPath",
  "\t$len = count($grid);\n\t$start = null;\n\tforeach ($grid as $i => $row) {\n\t\
    \tforeach ($row as $j => $item) {\n\t\t\tif ($item == 1) {\n\t\t\t\t$start = [$i,\
    \ $j];\n\t\t\t\tbreak 2;\n\t\t\t}\n\t\t}\n\t}\n\t$minPath = [];\n\t$path = [$start];\n\
    \t$visited = [];\n\t$visited[$start[0]][$start[1]] = true;\n\tdfs($grid, $len,\
    \ $k, $start, $path, $visited, $minPath);\n\treturn $minPath;\n}", "    $minPath\
    \ = $grid[0][0];\n    $k--;\n    $row = 0;\n    $col = 0;\n    while ($k > 0)\
    \ {\n        if ($row === 0 && $col === 0) {\n            $row++;\n          \
    \  $col++;\n            if ($grid[$row][$col] < $grid[$row][$col - 1]) {\n   \
    \             $minPath = $grid[$row][$col];\n            } else {\n          \
    \      $minPath = $grid[$row][$col - 1];\n            }\n        } elseif ($row\
    \ === 0) {\n            $row++;\n            if ($grid[$row][$col] < $grid[$row\
    \ - 1][$col]) {\n                $minPath = $grid[$row][$col];\n            }\
    \ else {\n                $minPath = $grid[$row - 1][$col];\n            }\n \
    \       } elseif ($col === 0) {\n            $col++;\n            if ($grid[$row][$col]\
    \ < $grid[$row][$col - 1]) {\n                $minPath = $grid[$row][$col];\n\
    \            } else {\n                $minPath = $grid[$row][$col - 1];\n   \
    \         }\n        } else {\n            if ($grid[$row][$col] < $grid[$row\
    \ - 1][$col] && $grid[$row][$col] < $grid[$row][$col - 1]) {\n               \
    \ $minPath = $grid[$row][$col];\n            } elseif ($grid[$row - 1][$col] <\
    \ $grid[$row][$col - 1]) {\n                $minPath = $grid[$row - 1][$col];\n\
    \            } else {\n                $minPath = $grid[$row][$col - 1];\n   \
    \         }\n        }\n        $k--;\n    }\n    return $minPath;\n}", "    $n\
    \ = count($grid);\n    if ($n < 2 || $k < 1) {\n        return [];\n    }\n  \
    \  $neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    $visited = [];\n    $minPath\
    \ = null;\n    $minPathCount = PHP_INT_MAX;\n    $minPathSum = PHP_INT_MAX;\n\
    \    function dfs($grid, $i, $j, $k, $currPath, $pathCount, $pathSum) {\n    \
    \    global $neighbors, $visited, $minPath, $minPathCount, $minPathSum;\n    \
    \    if ($pathCount > $minPathCount) {\n            return;\n        }\n     \
    \   if ($pathCount > $k) {\n            return;\n        }\n        if ($pathCount\
    \ === $k) {\n            if ($pathCount < $minPathCount || ($pathCount === $minPathCount\
    \ && $pathSum < $minPathSum)) {\n                $minPath = $currPath;\n     \
    \           $minPathCount = $pathCount;\n                $minPathSum = $pathSum;\n\
    \            }\n            return;\n        }\n        foreach ($neighbors as\
    \ $neighbor) {\n            $newI = $i + $neighbor[0];\n            $newJ = $j\
    \ + $neighbor[1];\n            if ($newI < 0 || $newI >= count($grid) || $newJ\
    \ < 0 || $newJ >= count($grid) || $visited[$newI][$newJ]) {\n                continue;\n\
    \            }\n            $visited[$newI][$newJ] = true;\n            dfs($grid,\
    \ $newI, $newJ, $k, array_merge($currPath, [$grid[$newI][$newJ]]), $pathCount\
    \ + 1, $pathSum + $grid[$newI][$newJ]);\n            $visited[$newI][$newJ] =\
    \ false;\n        }\n    }\n    for ($i = 0; $i < $n; $i++) {\n        for ($j\
    \ = 0; $j < $", "    if ($k == 0) {\n        return [];\n    }\n    if ($k ==\
    \ 1) {\n        return [$grid[0][0]];\n    }\n    if ($k == 2) {\n        return\
    \ [$grid[0][0], $grid[0][1]];\n    }\n    if ($k == 3) {\n        return [$grid[0][0],\
    \ $grid[0][1], $grid[0][0]];\n    }\n    if ($k == 4) {\n        return [$grid[0][0],\
    \ $grid[0][1], $grid[0][0], $grid[1][0]];\n    }\n    return [$grid[0][0], $grid[0][1],\
    \ $grid[0][0], $grid[1][0], $grid[0][0]];\n}", "    $m = count($grid);\n    $n\
    \ = count($grid[0]);\n    $vals = [];\n    for ($i = 0; $i < $m; $i++) {\n   \
    \     for ($j = 0; $j < $n; $j++) {\n            $vals[$grid[$i][$j]] = [$i, $j];\n\
    \        }\n    }\n    $dp = [];\n    for ($i = 1; $i <= $m * $n; $i++) {\n  \
    \      $dp[$i] = [INT_MAX, INT_MAX];\n    }\n    for ($i = 1; $i <= $m * $n; $i++)\
    \ {\n        $r = $vals[$i][0];\n        $c = $vals[$i][1];\n        $prev = [];\n\
    \        if ($r > 0) {\n            $prev[] = $grid[$r - 1][$c];\n        }\n\
    \        if ($r < $m - 1) {\n            $prev[] = $grid[$r + 1][$c];\n      \
    \  }\n        if ($c > 0) {\n            $prev[] = $grid[$r][$c - 1];\n      \
    \  }\n        if ($c < $n - 1) {\n            $prev[] = $grid[$r][$c + 1];\n \
    \       }\n        for ($j = 0; $j < count($prev); $j++) {\n            $prev_i\
    \ = $prev[$j];\n            if ($dp[$prev_i][0] + 1 < $dp[$i][0]) {\n        \
    \        $dp[$i] = [$dp[$prev_i][0] + 1, $prev_i];\n            } else if ($dp[$prev_i][0]\
    \ + 1 == $dp[$i][0]) {\n                if ($prev_i < $dp[$i][1]) {\n        \
    \            $dp[$i] = [$dp[$prev_i][0] + 1, $prev_i];\n                }\n  \
    \          }\n        }\n    }\n    $curr = $m * $n;\n    $result = [];\n    while\
    \ ($k-- > 0) {\n       ", "    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $minPath = [];\n    $minPath[0] = 0;\n    for ($i = 0; $i < $m; $i++) {\n\
    \        for ($j = 0; $j < $n; $j++) {\n            if ($grid[$i][$j] < $minPath[0])\
    \ {\n                $minPath[0] = $grid[$i][$j];\n                $minPath[1]\
    \ = [$i, $j];\n            }\n        }\n    }\n    for ($i = 2; $i <= $k; $i++)\
    \ {\n        $temp = INF;\n        $nextPath = [];\n        if ($minPath[$i -\
    \ 1][0] - 1 >= 0 && $grid[$minPath[$i - 1][0] - 1][$minPath[$i - 1][1]] < $temp)\
    \ {\n            $temp = $grid[$minPath[$i - 1][0] - 1][$minPath[$i - 1][1]];\n\
    \            $nextPath = [$minPath[$i - 1][0] - 1, $minPath[$i - 1][1]];\n   \
    \     }\n        if ($minPath[$i - 1][0] + 1 < $m && $grid[$minPath[$i - 1][0]\
    \ + 1][$minPath[$i - 1][1]] < $temp) {\n            $temp = $grid[$minPath[$i\
    \ - 1][0] + 1][$minPath[$i - 1][1]];\n            $nextPath = [$minPath[$i - 1][0]\
    \ + 1, $minPath[$i - 1][1]];\n        }\n        if ($minPath[$i - 1][1] - 1 >=\
    \ 0 && $grid[$minPath[$i - 1][0]][$minPath[$i - 1][1] - 1] < $temp) {\n      \
    \      $temp = $grid[$minPath[$i - 1][0]][$minPath[$i - 1][1] - 1];\n        \
    \    $nextPath = [$minPath[", "    if (empty($grid) || empty($grid[0])) {\n  \
    \      return [];\n    }\n    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $dp = [];\n    $k = min($k, $m * $n);\n    $curr = [];\n    $next = [];\n\
    \    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n  \
    \          if ($i == 0 && $j == 0) {\n                $dp[$i][$j] = [$grid[$i][$j]];\n\
    \            } else {\n                $paths = [];\n                if ($i >\
    \ 0) {\n                    $paths[] = $dp[$i - 1][$j];\n                }\n \
    \               if ($j > 0) {\n                    $paths[] = $dp[$i][$j - 1];\n\
    \                }\n                $paths = getMinPaths($paths, $grid[$i][$j]);\n\
    \                $dp[$i][$j] = $paths[0];\n            }\n            if (count($dp[$i][$j])\
    \ < $k) {\n                $curr[] = [$i, $j];\n            }\n        }\n   \
    \ }\n    while (!empty($curr)) {\n        foreach ($curr as $pos) {\n        \
    \    $i = $pos[0];\n            $j = $pos[1];\n            if ($i > 0) {\n   \
    \             $paths = getMinPaths([$dp[$i - 1][$j]], $grid[$i][$j]);\n      \
    \          if (count($paths[0]) < $k) {\n                    $next[] = [$i - 1,\
    \ $j];\n                }\n                if ($paths[0] < $dp[$i][$j]) {\n  \
    \                  $dp[$i][$j] = $paths[0];\n                }\n            }\n\
    \            if ($j > 0) {\n                $paths = getMinPaths([$dp[$i][$j -\
    \ 1]], $grid[$i][$j]);\n", "    // TODO: implement it\n}", "    // $minPath =\
    \ [];\n    // $minVal = PHP_INT_MAX;\n    // $count = 0;\n    // $rowLen = count($grid);\n\
    \    // $colLen = count($grid[0]);\n    // $visited = [];\n    // $minVal = PHP_INT_MAX;\n\
    \    // for ($i = 0; $i < $rowLen; $i++) {\n    //     for ($j = 0; $j < $colLen;\
    \ $j++) {\n    //         for ($i = 0; $i < $rowLen; $i++) {\n    //         \
    \    for ($j = 0; $j < $colLen; $j++) {\n    //                 $visited = [];\n\
    \    //                 minPathHelper($grid, $k, $i, $j, $visited, $minPath, $minVal);\n\
    \    //             }\n    //         }\n    //     }\n    // }\n    // // minPathHelper($grid,\
    \ $k, 0, 0, $visited, $minPath, $minVal);\n    // print_r($minPath);\n    // echo\
    \ \"minVal=$minVal\";\n    // return $minPath;\n    $grid = [ [1,2,3], [4,5,6],\
    \ [7,8,9]];\n    $k = 3;\n    $paths = [[[0,0]],[[0,1]],[[0,2]],[[1,0]],[[1,1]],[[1,2]],[[2,0]],[[2,1]],[[2,2]]];\n\
    \    print_r($paths);\n    $paths = findMinPath($grid, $paths, $k, 0);\n    echo\
    \ \"finalPaths\\n\";\n    print_r($paths);\n    return $paths;\n}\n", "    $result\
    \ = [];\n    $n = count($grid);\n    $path = [];\n    $min = [];\n    $currNum\
    \ = $n * $n;\n    dfs($grid, $n, $k, $path, $result, $min, $currNum);\n    return\
    \ $result;\n}", "\t$m = count($grid);\n\t$n = count($grid[0]);\n\t$minPath = [];\n\
    \t$visited = [];\n\tfor ($i = 0; $i < $m; $i++) {\n\t\tfor ($j = 0; $j < $n; $j++)\
    \ {\n\t\t\t$visited[$i][$j] = false;\n\t\t}\n\t}\n\tdfs($grid, $visited, $k, 0,\
    \ 0, $minPath, [$grid[0][0]]);\n\treturn $minPath;\n}", "    $n = count($grid);\n\
    \    $path = [];\n    $visited = [];\n    for ($i = 0; $i < $n; $i++) {\n    \
    \    $visited[$i] = array_fill(0, $n, false);\n    }\n    $min_sum = PHP_INT_MAX;\n\
    \    $target = $n * $n;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j =\
    \ 0; $j < $n; $j++) {\n            $sum = 0;\n            $curr_path = [];\n \
    \           minPathUtil($grid, $i, $j, $k, $sum, $curr_path, $min_sum, $visited,\
    \ $target);\n            if ($sum < $min_sum) {\n                $min_sum = $sum;\n\
    \                $path = $curr_path;\n            }\n        }\n    }\n    return\
    \ $path;\n}", "    $path = [];\n    $min = null;\n    $n = count($grid);\n   \
    \ $dirs = [[0,1], [0,-1], [1,0], [-1,0]];\n    $visited = array_fill(0, $n, array_fill(0,\
    \ $n, false));\n    $dfs(0, 0, $k, $grid, $dirs, $visited, $path, $min);\n   \
    \ return $min;\n}\n", "    $r = count($grid);\n    $c = count($grid[0]);\n   \
    \ $m = $r * $c;\n    if ($k > $m) {\n        return null;\n    }\n    $indices\
    \ = [];\n    $visited = [];\n    for ($i = 0; $i < $r; $i++) {\n        for ($j\
    \ = 0; $j < $c; $j++) {\n            $indices[$grid[$i][$j]] = [$i, $j];\n   \
    \         $visited[$i][$j] = false;\n        }\n    }\n    $q = new SplQueue();\n\
    \    $res = [];\n    for ($i = 1; $i <= $m; $i++) {\n        $cur = $indices[$i];\n\
    \        $path = [$i];\n        $q->enqueue($cur);\n        $visited[$cur[0]][$cur[1]]\
    \ = true;\n        while (!$q->isEmpty()) {\n            $size = $q->count();\n\
    \            while ($size-- > 0) {\n                $cur = $q->dequeue();\n  \
    \              $path[] = $grid[$cur[0]][$cur[1]];\n                if (count($path)\
    \ == $k) {\n                    $res[] = $path;\n                    break 2;\n\
    \                }\n                $dx = [0, 0, 1, -1];\n                $dy\
    \ = [1, -1, 0, 0];\n                for ($j = 0; $j < 4; $j++) {\n           \
    \         $x = $cur[0] + $dx[$j];\n                    $y = $cur[1] + $dy[$j];\n\
    \                    if ($x >= 0 && $x < $r && $y >= 0 && $y < $c && !$visited[$x][$y])\
    \ {\n                        $q->enqueue([$x, $y]);\n                        $visited[$x][$y]\
    \ = true;\n                    }\n                }\n            }\n        }\n\
    \    }\n    $min = min($res);\n    return $min;\n}", "    $matrix = new Matrix($grid);\n\
    \    return $matrix->findMinPathOfLength($k);\n}\nclass Matrix {\n    private\
    \ $grid;\n    private $rows;\n    private $cols;\n    private $visited;\n    private\
    \ $minPath;\n    public function __construct($grid) {\n        $this->grid = $grid;\n\
    \        $this->rows = count($grid);\n        $this->cols = count($grid[0]);\n\
    \        $this->visited = array_fill(0, $this->rows, array_fill(0, $this->cols,\
    \ 0));\n        $this->minPath = [];\n    }\n    public function findMinPathOfLength($k)\
    \ {\n        $this->findMinPathOfLengthHelper(0, 0, $k, [$this->grid[0][0]]);\n\
    \        return $this->minPath;\n    }\n    private function findMinPathOfLengthHelper($row,\
    \ $col, $k, $path) {\n        $this->visited[$row][$col] = 1;\n        if ($k\
    \ === 1) {\n            if (empty($this->minPath) || $path < $this->minPath) {\n\
    \                $this->minPath = $path;\n            }\n        } else {\n  \
    \          $this->validate(0, 1, $k, $path);\n            $this->validate(0, -1,\
    \ $k, $path);\n            $this->validate(1, 0, $k, $path);\n            $this->validate(-1,\
    \ 0, $k, $path);\n        }\n        $this->visited[$row][$col] = 0;\n    }\n\
    \    private function validate($rowDelta, $colDelta, $k, $path) {\n        $nextRow\
    \ = $rowDelta + $row;\n        $nextCol = $colDelta + $col;\n        if ($this->valid($nextRow,\
    \ $nextCol) && !$this->visited[$nextRow][$nextCol]) {\n            $this->findMinPathOfLengthHelper($nextRow,\
    \ $nextCol, $k - 1, array_merge($path, [$this->grid[$", "    $size = count($grid);\n\
    \    $nums = [];\n    for ($i = 0; $i < $size; $i++) {\n        for ($j = 0; $j\
    \ < $size; $j++) {\n            $nums[] = $grid[$i][$j];\n        }\n    }\n \
    \   sort($nums);\n    $path = [];\n    $path[] = $nums[0];\n    $minV = $nums[0];\n\
    \    $k--;\n    while ($k > 0) {\n        $next = INF;\n        $nextP = null;\n\
    \        for ($i = 0; $i < $size; $i++) {\n            for ($j = 0; $j < $size;\
    \ $j++) {\n                if ($grid[$i][$j] <= $minV) {\n                   \
    \ continue;\n                }\n                if ($grid[$i][$j] > $next) {\n\
    \                    continue;\n                }\n                if ($i > 0\
    \ && $grid[$i - 1][$j] == $minV) {\n                    $next = $grid[$i][$j];\n\
    \                    $nextP = [$i, $j];\n                }\n                if\
    \ ($i < $size - 1 && $grid[$i + 1][$j] == $minV) {\n                    $next\
    \ = $grid[$i][$j];\n                    $nextP = [$i, $j];\n                }\n\
    \                if ($j > 0 && $grid[$i][$j - 1] == $minV) {\n               \
    \     $next = $grid[$i][$j];\n                    $nextP = [$i, $j];\n       \
    \         }\n                if ($j < $size - 1 && $grid[$i][$j + 1] == $minV)\
    \ {\n                    $next = $grid[$i][$j];\n                    $nextP =\
    \ [$i, $j];\n                }\n            }\n        }\n        $path[] = $next;\n\
    \        $minV = $next;\n        $k--;\n    }\n    return $path;\n}\n\n$grid =\
    \ [ [1,2,3], [4,5,6", "    $output = [];\n    $rows = count($grid);\n    $cols\
    \ = count($grid[0]);\n    $visited = [];\n    $start = [0, 0];\n    $current =\
    \ $start;\n    $walked = 0;\n    while ($walked < $k) {\n        $next = nextCell($current,\
    \ $grid, $rows, $cols, $visited);\n        $visited[$current[0]][$current[1]]\
    \ = true;\n        if ($next === null) {\n            return null;\n        }\n\
    \        $output[] = $grid[$next[0]][$next[1]];\n        $current = $next;\n \
    \       $walked++;\n    }\n    return $output;\n}\n", "    $best = [];\n    $N\
    \ = count($grid);\n    $visited = [];\n    foreach ($grid as $r => $row) {\n \
    \       foreach ($row as $c => $val) {\n            if ($k == 1) {\n         \
    \       $best = [$val];\n                break;\n            }\n            $visited[$r][$c]\
    \ = true;\n            if ($r > 0 && !isset($visited[$r - 1][$c])) {\n       \
    \         $newPath = minPath($grid, $k - 1, $r - 1, $c, $best, $visited);\n  \
    \              if (empty($best) || $newPath < $best) {\n                    $best\
    \ = $newPath;\n                }\n            }\n            if ($r < $N - 1 &&\
    \ !isset($visited[$r + 1][$c])) {\n                $newPath = minPath($grid, $k\
    \ - 1, $r + 1, $c, $best, $visited);\n                if (empty($best) || $newPath\
    \ < $best) {\n                    $best = $newPath;\n                }\n     \
    \       }\n            if ($c > 0 && !isset($visited[$r][$c - 1])) {\n       \
    \         $newPath = minPath($grid, $k - 1, $r, $c - 1, $best, $visited);\n  \
    \              if (empty($best) || $newPath < $best) {\n                    $best\
    \ = $newPath;\n                }\n            }\n            if ($c < $N - 1 &&\
    \ !isset($visited[$r][$c + 1])) {\n                $newPath = minPath($grid, $k\
    \ - 1, $r, $c + 1, $best, $visited);\n                if (empty($best) || $newPath\
    \ < $best) {\n                    $best = $newPath;\n                }\n     \
    \       }\n            unset($visited[$r][$c]);\n        }\n    }\n    return\
    \ array_merge([$grid[$r][$c]], $best);\n}", "    if (!isset($grid[0][0])) {\n\
    \        return [];\n    }\n    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $visited = array_fill(0, $m, array_fill(0, $n, false));\n    $queue = new\
    \ \\Ds\\Queue();\n    $queue->push([[0, 0], $grid[0][0], [$grid[0][0]]]);\n  \
    \  $visited[0][0] = true;\n    $minPath = [];\n    while (!$queue->isEmpty())\
    \ {\n        list($p, $num, $path) = $queue->pop();\n        if (count($path)\
    \ == $k) {\n            if (empty($minPath) || $path < $minPath) {\n         \
    \       $minPath = $path;\n            }\n            continue;\n        }\n \
    \       list($x, $y) = $p;\n        $next = [\n            [$x + 1, $y],\n   \
    \         [$x - 1, $y],\n            [$x, $y + 1],\n            [$x, $y - 1],\n\
    \        ];\n        foreach ($next as $p) {\n            list($x, $y) = $p;\n\
    \            if ($x < 0 || $x >= $m || $y < 0 || $y >= $n || $visited[$x][$y])\
    \ {\n                continue;\n            }\n            $visited[$x][$y] =\
    \ true;\n            $queue->push([$p, $grid[$x][$y], array_merge($path, [$grid[$x][$y]])]);\n\
    \        }\n    }\n    return $minPath;\n}", "    $r = count($grid);\n    $c =\
    \ count($grid[0]);\n    $dp = [];\n    for ($i = 0; $i < $r; $i++) {\n       \
    \ for ($j = 0; $j < $c; $j++) {\n            $dp[$i][$j] = ['cost' => $grid[$i][$j],\
    \ 'path' => [[$i, $j]]];\n        }\n    }\n    for ($l = 1; $l < $k; $l++) {\n\
    \        for ($i = 0; $i < $r; $i++) {\n            for ($j = 0; $j < $c; $j++)\
    \ {\n                $cost = $dp[$i][$j]['cost'];\n                $path = $dp[$i][$j]['path'];\n\
    \                $dp[$i][$j] = ['cost' => PHP_INT_MAX, 'path' => []];\n      \
    \          $moves = [\n                    [$i - 1, $j],\n                   \
    \ [$i + 1, $j],\n                    [$i, $j - 1],\n                    [$i, $j\
    \ + 1],\n                ];\n                foreach ($moves as $move) {\n   \
    \                 if ($move[0] < 0 || $move[0] >= $r || $move[1] < 0 || $move[1]\
    \ >= $c) {\n                        continue;\n                    }\n       \
    \             $newCost = $dp[$move[0]][$move[1]]['cost'] + $cost;\n          \
    \          $newPath = array_merge($dp[$move[0]][$move[1]]['path'], $path);\n \
    \                   if ($newCost < $dp[$i][$j]['cost']) {\n                  \
    \      $dp[$i][$j] = ['cost' => $newCost, 'path' => $newPath];\n             \
    \       } else if ($newCost == $dp[$i][$j]['cost']) {\n                      \
    \  $newPathLex = implode(',', $newPath);\n                        $curPathLex\
    \ = implode(',', $dp[$i][$j]['path']);\n                        if ($new", " \
    \   $size = count($grid);\n    $cells = $size * $size;\n    if ($cells < $k) return\
    \ -1;\n    $A = array_fill(0, $size, array_fill(0, $size, PHP_INT_MAX));\n   \
    \ $B = array_fill(0, $size, array_fill(0, $size, PHP_INT_MAX));\n    $prev = array_fill(0,\
    \ $size, array_fill(0, $size, 0));\n    $next = array_fill(0, $size, array_fill(0,\
    \ $size, 0));\n    $n = 0;\n    while ($n < $cells) {\n        $i = floor($n /\
    \ $size);\n        $j = $n % $size;\n        if ($i > 0) {\n            $A[$i][$j]\
    \ = $grid[$i][$j] + $A[$i - 1][$j];\n            $B[$i][$j] = $grid[$i][$j] +\
    \ $B[$i - 1][$j];\n            $prev[$i][$j] = 1;\n        } else {\n        \
    \    $A[$i][$j] = $grid[$i][$j];\n            $B[$i][$j] = $grid[$i][$j];\n  \
    \      }\n        if ($j > 0) {\n            $A[$i][$j] = min($A[$i][$j], $grid[$i][$j]\
    \ + $A[$i][$j - 1]);\n            $B[$i][$j] = min($B[$i][$j], $grid[$i][$j] +\
    \ $B[$i][$j - 1]);\n            if ($A[$i][$j] == $grid[$i][$j] + $A[$i][$j -\
    \ 1]) {\n                $prev[$i][$j] = 2;\n            }\n        }\n      \
    \  $n++;\n    }\n    $k--;\n    $res = [];\n    $i = $size - 1;\n    $j = $size\
    \ - 1;\n   ", "    $count = 0;\n    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $visited = [];\n    $dist = [];\n    $lst = [];\n    $result = PHP_INT_MAX;\n\
    \    $resultLst = [];\n    $queue = new SplQueue();\n    $queue->enqueue([0, 0]);\n\
    \    $dist[0][0] = 0;\n    $visited[0][0] = true;\n    while (!$queue->isEmpty())\
    \ {\n        list($a, $b) = $queue->dequeue();\n        $count++;\n        if\
    \ ($count == $k) {\n            if ($grid[$a][$b] < $result) {\n             \
    \   $result = $grid[$a][$b];\n                $resultLst = $lst;\n           \
    \ }\n            continue;\n        }\n        $lst[] = $grid[$a][$b];\n     \
    \   if ($a + 1 < $m && !$visited[$a + 1][$b]) {\n            $visited[$a + 1][$b]\
    \ = true;\n            $dist[$a + 1][$b] = $dist[$a][$b] + 1;\n            $queue->enqueue([$a\
    \ + 1, $b]);\n        }\n        if ($a - 1 >= 0 && !$visited[$a - 1][$b]) {\n\
    \            $visited[$a - 1][$b] = true;\n            $dist[$a - 1][$b] = $dist[$a][$b]\
    \ + 1;\n            $queue->enqueue([$a - 1, $b]);\n        }\n        if ($b\
    \ + 1 < $n && !$visited[$a][$b + 1]) {\n            $visited[$a][$b + 1] = true;\n\
    \            $dist[$a][$b + 1] = $dist[$a][$b] + 1;\n            $queue->enqueue([$a,\
    \ $b + 1]);\n        }\n        if ($b - 1 >= 0 && !$visited[$a][$b - 1]) {\n\
    \            $visited[", "    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $minPath = array_map(function($x) {return $x;}, $grid[0]);\n    $visited\
    \ = array_fill(0, $m, array_fill(0, $n, false));\n    $dfs = function($i, $j,\
    \ $k, $visited, $path) use (&$minPath, $m, $n, &$dfs) {\n        if ($k == 0)\
    \ {\n            if ($path < $minPath) {\n                $minPath = $path;\n\
    \            }\n            return;\n        }\n        $deltaI = [0, 1, 0, -1];\n\
    \        $deltaJ = [1, 0, -1, 0];\n        for ($d = 0; $d < 4; $d++) {\n    \
    \        $nextI = $i + $deltaI[$d];\n            $nextJ = $j + $deltaJ[$d];\n\
    \            if ($nextI >= 0 && $nextI < $m && $nextJ >= 0 && $nextJ < $n && !$visited[$nextI][$nextJ])\
    \ {\n                $visited[$nextI][$nextJ] = true;\n                $dfs($nextI,\
    \ $nextJ, $k - 1, $visited, array_merge($path, [$grid[$nextI][$nextJ]]));\n  \
    \              $visited[$nextI][$nextJ] = false;\n            }\n        }\n \
    \   };\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            $visited[$i][$j] = true;\n            $dfs($i, $j, $k - 1, $visited,\
    \ [$grid[$i][$j]]);\n            $visited[$i][$j] = false;\n        }\n    }\n\
    \    return $minPath;\n}", "    $n = count($grid);\n    if ($n == 0) {\n     \
    \   return null;\n    }\n    if ($k == 0) {\n        return [];\n    }\n    $ret\
    \ = [];\n    $visited = [];\n    $min_path = PHP_INT_MAX;\n    $min_path_arr =\
    \ [];\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            $tmp = dfs($grid, $i, $j, $k, $visited, $ret);\n            if\
    \ ($tmp < $min_path) {\n                $min_path = $tmp;\n                $min_path_arr\
    \ = $ret;\n            }\n            $ret = [];\n            $visited = [];\n\
    \        }\n    }\n    return $min_path_arr;\n}", "    // return the value of\
    \ the first cell in the grid if k is 1\n    if ($k == 1) {\n        return [$grid[0][0]];\n\
    \    }\n    // store the number of rows and the number of columns\n    $rows =\
    \ count($grid);\n    $cols = count($grid[0]);\n    // build an 2D array containing\
    \ the minimum path to any cell given a distance limit\n    $paths = [];\n    //\
    \ create the path to the first cell by its value\n    $paths[0][0] = [$grid[0][0]];\n\
    \    // create the path to the other cells in the first row\n    for ($i = 1;\
    \ $i < $cols; $i++) {\n        // create a copy of the path of the left neighbor\
    \ and add the value of the current cell\n        $paths[0][$i] = $paths[0][$i\
    \ - 1];\n        $paths[0][$i][] = $grid[0][$i];\n    }\n    // create the path\
    \ to the other cells in the first column\n    for ($i = 1; $i < $rows; $i++) {\n\
    \        // create a copy of the path of the upper neighbor and add the value\
    \ of the current cell\n        $paths[$i][0] = $paths[$i - 1][0];\n        $paths[$i][0][]\
    \ = $grid[$i][0];\n    }\n    // create the path to the other cells\n    for ($i\
    \ = 1; $i < $rows; $i++) {\n        for ($j = 1; $j < $cols; $j++) {\n       \
    \     // if the minimum path of the left neighbor is lexicographically less than\
    \ the minimum path of the upper neighbor, create a copy of it and add the value\
    \ of the current cell, otherwise create a copy of the path of the upper neighbor\
    \ and add the value of the current cell\n            $paths[$i][$j] = $paths[$i][$j\
    \ - 1] < $paths[$i - 1][$j] ? $paths[$i][$j - 1] : $paths[$i - 1][$j];\n     \
    \       $paths[$i", "    $n = count($grid);\n    if ($n == 0) {\n        return\
    \ [];\n    }\n    if ($k == 0) {\n        return [];\n    }\n    $path = [];\n\
    \    $queue = new SplQueue();\n    $queue->enqueue([0, 0, 0]);\n    while (!$queue->isEmpty())\
    \ {\n        list($i, $j, $len) = $queue->dequeue();\n        if ($len == $k)\
    \ {\n            array_push($path, $grid[$i][$j]);\n            break;\n     \
    \   }\n        $current = $grid[$i][$j];\n        if ($i + 1 < $n && $grid[$i\
    \ + 1][$j] > $current) {\n            $queue->enqueue([$i + 1, $j, $len + 1]);\n\
    \        }\n        if ($i - 1 >= 0 && $grid[$i - 1][$j] > $current) {\n     \
    \       $queue->enqueue([$i - 1, $j, $len + 1]);\n        }\n        if ($j +\
    \ 1 < $n && $grid[$i][$j + 1] > $current) {\n            $queue->enqueue([$i,\
    \ $j + 1, $len + 1]);\n        }\n        if ($j - 1 >= 0 && $grid[$i][$j - 1]\
    \ > $current) {\n            $queue->enqueue([$i, $j - 1, $len + 1]);\n      \
    \  }\n    }\n    return $path;\n}\n$grid = [ [1,2,3], [4,5,6], [7,8,9]];\n$k =\
    \ 3;\necho implode(', ', minPath($grid, $k)) . PHP_EOL;\n$grid = [ [5,9,3], [4,1,6],\
    \ [7,8,2]];\n$k = 1;\necho implode(', ', minPath($grid, $k)) . PHP_EOL;", "  \
    \  $path = [];\n    $visited = array_fill(0, count($grid), array_fill(0, count($grid),\
    \ 0));\n    dfs($grid, $k, 0, 0, $path, $visited);\n    return $path;\n}", " \
    \   if (empty($grid) || $k <= 0) {\n        return [];\n    }\n    $res = [];\n\
    \    $len = count($grid);\n    $visited = [];\n    for ($i = 0; $i < $len; $i++)\
    \ {\n        for ($j = 0; $j < $len; $j++) {\n            $visited[$i][$j] = 0;\n\
    \        }\n    }\n    for ($i = 0; $i < $len; $i++) {\n        for ($j = 0; $j\
    \ < $len; $j++) {\n            $count = 0;\n            $cur = [];\n         \
    \   $visited[$i][$j] = 1;\n            dfs($grid, $i, $j, $visited, $k, $count,\
    \ $cur, $res);\n            $visited[$i][$j] = 0;\n        }\n    }\n    return\
    \ $res;\n}", "\t//take k, find all paths of k, then return the smallest\n\t$minPath\
    \ = [];\n\t$paths = allPaths($grid, $k);\n\tfor ($i = 0; $i < count($paths); $i++)\
    \ {\n\t\tif ($i == 0) {\n\t\t\t$minPath = $paths[$i];\n\t\t} else {\n\t\t\t$minPath\
    \ = lessThan($minPath, $paths[$i]);\n\t\t}\n\t}\n\treturn $minPath;\n}\n", " \
    \   $visited = [];\n    $n = count($grid);\n    for ($i = 0; $i < $n; $i++) {\n\
    \        for ($j = 0; $j < $n; $j++) {\n            $visited[$i][$j] = -1;\n \
    \       }\n    }\n    $min = PHP_INT_MAX;\n    $path = [];\n    $ans = [];\n \
    \   $visited[0][0] = 0;\n    $dfs($grid, $k, $visited, $min, $path, $ans, 0, 0,\
    \ $n);\n    return $ans;\n}", "    // Time: O(n^2)\n    // Space: O(n^2)\n   \
    \ $lst = [];\n    // find first value less than $k,\n    // and then use that\
    \ to find that next value\n    // and then the one after that\n    // and so on\
    \ until get to $k\n    $n = count($grid);\n    $v = 0;\n    for ($i = 0; $i <\
    \ $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($grid[$i][$j]\
    \ < $k) {\n                $v = $grid[$i][$j];\n                $lst[] = $v;\n\
    \                $grid[$i][$j] = PHP_INT_MAX;\n                break 2;\n    \
    \        }\n        }\n    }\n    $total = 1;\n    while ($total < $k) {\n   \
    \     $next = PHP_INT_MAX;\n        if ($i > 0 && $grid[$i-1][$j] < $next) {\n\
    \            $next = $grid[$i-1][$j];\n            $nx = $i-1;\n            $ny\
    \ = $j;\n        }\n        if ($i < $n-1 && $grid[$i+1][$j] < $next) {\n    \
    \        $next = $grid[$i+1][$j];\n            $nx = $i+1;\n            $ny =\
    \ $j;\n        }\n        if ($j > 0 && $grid[$i][$j-1] < $next) {\n         \
    \   $next = $grid[$i][$j-1];\n            $nx = $i;\n            $ny = $j-1;\n\
    \        }\n        if ($j < $n-1 && $grid[$i][$j+1] < $next) {\n            $next\
    \ = $grid[$i][$j+1];\n            $nx = $i;\n            $ny = $j+1;\n       \
    \ }\n        $lst[] = $next;\n        $grid[$nx][$ny] = PHP_INT_MAX;\n       \
    \ $i", "    // $matches = [];\n    // $result = [];\n    // for ($i = 0; $i <\
    \ count($grid); $i++) {\n    //     for ($j = 0; $j < count($grid[$i]); $j++)\
    \ {\n    //         array_push($matches, findMatch($grid, $i, $j, $k));\n    //\
    \     }\n    // }\n    // // var_dump($matches);\n    // $min = $matches[0];\n\
    \    // for ($m = 1; $m < count($matches); $m++) {\n    //     if (compare($matches[$m],\
    \ $min) < 0) {\n    //         $min = $matches[$m];\n    //     }\n    // }\n\
    \    // return $min;\n    $matches = [];\n    $min = [];\n    for ($i = 0; $i\
    \ < count($grid); $i++) {\n        for ($j = 0; $j < count($grid[$i]); $j++) {\n\
    \            $match = findMatch($grid, $i, $j, $k);\n            if (count($match)\
    \ > 0) {\n                array_push($matches, $match);\n                if (count($min)\
    \ === 0 || compare($match, $min) < 0) {\n                    $min = $match;\n\
    \                }\n            }\n        }\n    }\n    // var_dump($matches);\n\
    \    return $min;\n}", "    // assume grid is N x N\n    $N = count($grid);\n\
    \    $numOfVisited = $N * $N;\n    $targets = $grid;\n    $targetMask = array_fill(0,\
    \ $N, array_fill(0, $N, false));\n    $targetCount = $numOfVisited;\n    $queues\
    \ = [$targets];\n    $queueMask = [$targetMask];\n    $queueCount = [$targetCount];\n\
    \    for ($i = 0; $i < $k; $i++) {\n        $newQueues = [];\n        $newQueueMask\
    \ = [];\n        $newQueueCount = [];\n        $newQueueValues = [];\n       \
    \ for ($q = 0; $q < count($queues); $q++) {\n            $targets = $queues[$q];\n\
    \            $targetMask = $queueMask[$q];\n            $targetCount = $queueCount[$q];\n\
    \            $r = 0;\n            while ($r < $N && ($targetCount > 0 || $i ==\
    \ 0)) {\n                $c = 0;\n                while ($c < $N && ($targetCount\
    \ > 0 || $i == 0)) {\n                    if ($targetMask[$r][$c]) {\n       \
    \                 if ($i == 0) {\n                            return [$targets[$r][$c]];\n\
    \                        }\n                        $targetMask[$r][$c] = false;\n\
    \                        $targetCount--;\n                        $newTargets\
    \ = $targets;\n                        $newTargetMask = [];\n                \
    \        for ($r2 = 0; $r2 < $N; $r2++) {\n                            $newTargetMask[$r2]\
    \ = $targetMask[$r2];\n                        }\n                        if ($r\
    \ > 0) {\n                            $newTargetMask[$r - 1][$c] = true;\n   \
    \                     }\n                        if ($r < $N - 1) {\n        \
    \                    $newTargetMask[$r + 1][$c] = true;\n                    \
    \    }\n                        if ($c > 0) {\n                            $newTargetMask[$r][$c\
    \ - 1] = true;\n                        }\n                        if ($c", " \
    \   // TODO: Implement this function\n}", "    if (empty($grid) || empty($grid[0]))\
    \ {\n        return [];\n    }\n    $size = count($grid);\n    if ($k < 1 || $k\
    \ > $size * $size) {\n        return [];\n    }\n    $visited = [];\n    $start\
    \ = 0;\n    $minSeq = [$grid[0][0]];\n    $minVal = PHP_INT_MAX;\n    $directions\
    \ = [\n        [-1, 0],\n        [1, 0],\n        [0, -1],\n        [0, 1],\n\
    \    ];\n    $minPathDFS($grid, $visited, $start, $size, $directions, $k, $minSeq,\
    \ $minVal);\n    return $minSeq;\n}", "    $rows = count($grid);\n    $cols =\
    \ count($grid[0]);\n    // dp[i][j][t] = minimum path of length t starting from\
    \ (i, j)\n    $dp = [];\n    // Let's fill out dp[i][j][1]\n    for ($i = 0; $i\
    \ < $rows; $i++) {\n        for ($j = 0; $j < $cols; $j++) {\n            $dp[$i][$j][1]\
    \ = $grid[$i][$j];\n        }\n    }\n    // Now let's fill out dp[i][j][t] for\
    \ t > 1\n    for ($t = 2; $t <= $k; $t++) {\n        for ($i = 0; $i < $rows;\
    \ $i++) {\n            for ($j = 0; $j < $cols; $j++) {\n                $up =\
    \ ($i - 1 >= 0) ? $dp[$i - 1][$j][$t - 1] : PHP_INT_MAX;\n                $down\
    \ = ($i + 1 < $rows) ? $dp[$i + 1][$j][$t - 1] : PHP_INT_MAX;\n              \
    \  $left = ($j - 1 >= 0) ? $dp[$i][$j - 1][$t - 1] : PHP_INT_MAX;\n          \
    \      $right = ($j + 1 < $cols) ? $dp[$i][$j + 1][$t - 1] : PHP_INT_MAX;\n  \
    \              $dp[$i][$j][$t] = $grid[$i][$j] + min($up, $down, $left, $right);\n\
    \            }\n        }\n    }\n    // Find the minimum path\n    $minValue\
    \ = PHP_INT_MAX;\n    $minRow = -1;\n    $minCol = -1;\n    for ($i = 0; $i <\
    \ $rows; $i++) {\n        for ($j = 0; $j < $cols; $j++) {\n            if ($dp[$i][$j][$k]\
    \ < $minValue) {\n                $minValue = $dp[$i][$", "    $rows = count($grid);\n\
    \    $cols = count($grid[0]);\n    $minPath = [];\n    $queue = new SplQueue();\n\
    \    $grid[0][0]['visited'] = true;\n    $queue->enqueue([0, 0]);\n    $k--;\n\
    \    while ($k > 0) {\n        $queueSize = $queue->count();\n        for ($i\
    \ = 0; $i < $queueSize; $i++) {\n            $cur = $queue->dequeue();\n     \
    \       $curR = $cur[0];\n            $curC = $cur[1];\n            $candidates\
    \ = [];\n            if ($curR + 1 < $rows && !$grid[$curR + 1][$curC]['visited'])\
    \ {\n                $candidates[] = [$curR + 1, $curC];\n            }\n    \
    \        if ($curR - 1 >= 0 && !$grid[$curR - 1][$curC]['visited']) {\n      \
    \          $candidates[] = [$curR - 1, $curC];\n            }\n            if\
    \ ($curC + 1 < $cols && !$grid[$curR][$curC + 1]['visited']) {\n             \
    \   $candidates[] = [$curR, $curC + 1];\n            }\n            if ($curC\
    \ - 1 >= 0 && !$grid[$curR][$curC - 1]['visited']) {\n                $candidates[]\
    \ = [$curR, $curC - 1];\n            }\n            $min = PHP_INT_MAX;\n    \
    \        $minCandidate = null;\n            foreach ($candidates as $c) {\n  \
    \              if ($grid[$c[0]][$c[1]]['val'] < $min) {\n                    $min\
    \ = $grid[$c[0]][$c[1]]['val'];\n                    $minCandidate = $c;\n   \
    \             }\n            }\n            if ($minCandidate !== null) {\n  \
    \              $queue->enqueue($minCandidate);\n                $grid[$minCandidate[0]][$minCandidate[1]]['visited']\
    \ = true;\n", "    $rows = count($grid);\n    $cols = count($grid[0]);\n    $minPath\
    \ = new MinPath($rows, $cols, $k);\n    $minPath->parseGrid($grid);\n    return\
    \ $minPath->findPath();\n}\nclass MinPath {\n    public $minPath;\n    public\
    \ $rows;\n    public $cols;\n    public $k;\n    public $mapping;\n    public\
    \ $visited;\n    public $target;\n    public function __construct($rows, $cols,\
    \ $k) {\n        $this->rows = $rows;\n        $this->cols = $cols;\n        $this->k\
    \ = $k;\n        $this->mapping = [];\n        $this->visited = [];\n        $this->target\
    \ = range(1, $rows * $cols);\n    }\n    public function parseGrid($grid) {\n\
    \        for ($r = 0; $r < $this->rows; $r++) {\n            for ($c = 0; $c <\
    \ $this->cols; $c++) {\n                $this->mapping[$grid[$r][$c]] = [$r, $c];\n\
    \            }\n        }\n    }\n    public function findPath() {\n        $this->dfs(0,\
    \ $this->k, new Path([1]));\n        return $this->minPath->path;\n    }\n   \
    \ public function dfs($pos, $k, $path) {\n        if ($k == 0) {\n           \
    \ if ($this->minPath == null) {\n                $this->minPath = $path;\n   \
    \         } else {\n                $this->minPath = min($this->minPath, $path);\n\
    \            }\n            return;\n        }\n        $neighbors = $this->getNeighbors($pos);\n\
    \        for ($next = 0; $next < count($neighbors); $next++) {\n            $idx\
    \ = $neighbors[$next];\n            if (isset($this->visited[$idx])) {\n     \
    \           continue;\n            }\n            $this->visited[$idx] = true;\n\
    \            $nextPos = $this->target", "    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $count = 0;\n    $visited = [];\n    $values = [];\n    $min = [];\n    $minPath\
    \ = [];\n    $queue = new SplQueue();\n    $queue->enqueue([0, 0]);\n    while\
    \ (!$queue->isEmpty()) {\n        list($i, $j) = $queue->dequeue();\n        $val\
    \ = $grid[$i][$j];\n        $visited[$i][$j] = true;\n        $values[] = $val;\n\
    \        $count++;\n        if ($count == $k) {\n            $key = implode('_',\
    \ $values);\n            if (!isset($min[$key])) {\n                $min[$key]\
    \ = $values;\n            }\n            $visited[$i][$j] = false;\n         \
    \   array_pop($values);\n            $count--;\n            continue;\n      \
    \  }\n        if ($i + 1 < $m && !$visited[$i + 1][$j]) {\n            $queue->enqueue([$i\
    \ + 1, $j]);\n        }\n        if ($j + 1 < $n && !$visited[$i][$j + 1]) {\n\
    \            $queue->enqueue([$i, $j + 1]);\n        }\n        if ($i - 1 >=\
    \ 0 && !$visited[$i - 1][$j]) {\n            $queue->enqueue([$i - 1, $j]);\n\
    \        }\n        if ($j - 1 >= 0 && !$visited[$i][$j - 1]) {\n            $queue->enqueue([$i,\
    \ $j - 1]);\n        }\n        $visited[$i][$j] = false;\n        array_pop($values);\n\
    \        $count--;\n    }\n    foreach ($min as $key => $values) {\n        $minPath\
    \ = empty($minPath) ? $values : minPathHelper($minPath, $values);\n    }\n   \
    \ return $minPath;\n}", "    $N = count($grid);\n    $shortestPaths = [];\n  \
    \  for ($x = 0; $x < $N; $x++) {\n        for ($y = 0; $y < $N; $y++) {\n    \
    \        $path = [];\n            $visited = [];\n            $queue = new SplQueue();\n\
    \            $queue->enqueue([$x, $y]);\n            while (!$queue->isEmpty())\
    \ {\n                list($x, $y) = $queue->dequeue();\n                if (isset($visited[$x][$y]))\
    \ {\n                    continue;\n                }\n                $visited[$x][$y]\
    \ = 1;\n                $path[] = $grid[$x][$y];\n                if (count($path)\
    \ >= $k) {\n                    $shortestPaths[] = $path;\n                  \
    \  break;\n                }\n                if ($x + 1 < $N) {\n           \
    \         $queue->enqueue([$x + 1, $y]);\n                }\n                if\
    \ ($x - 1 >= 0) {\n                    $queue->enqueue([$x - 1, $y]);\n      \
    \          }\n                if ($y + 1 < $N) {\n                    $queue->enqueue([$x,\
    \ $y + 1]);\n                }\n                if ($y - 1 >= 0) {\n         \
    \           $queue->enqueue([$x, $y - 1]);\n                }\n            }\n\
    \        }\n    }\n    return min($shortestPaths);\n}\n\n$grid = [ [1,2,3], [4,5,6],\
    \ [7,8,9]];\n$k = 3;\n$ret = minPath($grid, $k);\nprint_r($ret);", "    if ($k\
    \ === 0) {\n        return [];\n    }\n    $n = count($grid);\n    $m = count($grid[0]);\n\
    \    // dp[i][j][x] means the minimum path start from (i, j) and has length x.\n\
    \    $dp = [];\n    // parent[i][j][x] is used to construct the path.\n    $parent\
    \ = [];\n    // dp[i][j][x] = min(dp[i][j][x - 1], dp[i - 1][j][x - 1], dp[i +\
    \ 1][j][x - 1], dp[i][j - 1][x - 1], dp[i][j + 1][x - 1])\n    for ($i = 0; $i\
    \ < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n            $dp[$i][$j][0]\
    \ = [$grid[$i][$j]];\n            $parent[$i][$j][0] = null;\n        }\n    }\n\
    \    for ($x = 1; $x < $k; $x++) {\n        for ($i = 0; $i < $n; $i++) {\n  \
    \          for ($j = 0; $j < $m; $j++) {\n                $min = [];\n       \
    \         if ($i > 0) {\n                    $min = $dp[$i - 1][$j][$x - 1];\n\
    \                    $parent[$i][$j][$x] = [$i - 1, $j, $x - 1];\n           \
    \     }\n                if ($i < $n - 1 && count($min) === 0 ||\n           \
    \         $i < $n - 1 && count($dp[$i + 1][$j][$x - 1]) > 0 && $dp[$i + 1][$j][$x\
    \ - 1] < $min) {\n                    $min = $dp[$i + 1][$j][$x - 1];\n      \
    \              $parent[$i][$j][$x] = [$i + 1, $j, $x - 1];\n                }\n\
    \                if ($j > 0 && count($min) === 0", "    if ($k == 0) {\n     \
    \   return [0];\n    }\n    $len = count($grid);\n    $map = [];\n    for ($i\
    \ = 0; $i < $len; $i++) {\n        for ($j = 0; $j < $len; $j++) {\n         \
    \   $value = $grid[$i][$j];\n            $map[$value] = [$i, $j];\n        }\n\
    \    }\n    $value = 1;\n    $result = [$value];\n    for ($n = 0; $n < $k - 1;\
    \ $n++) {\n        $cur = $map[$value];\n        $next = INF;\n        for ($i\
    \ = $cur[0] - 1; $i <= $cur[0] + 1; $i++) {\n            for ($j = $cur[1] - 1;\
    \ $j <= $cur[1] + 1; $j++) {\n                if ($i >= 0 && $i < $len && $j >=\
    \ 0 && $j < $len) {\n                    $value = $grid[$i][$j];\n           \
    \         if ($value < $next) {\n                        $next = $value;\n   \
    \                 }\n                }\n            }\n        }\n        $result[]\
    \ = $next;\n    }\n    return $result;\n}", "    $M = count($grid);\n    $N =\
    \ count($grid[0]);\n    $min = [];\n    for ($i = 0; $i < $M; $i++) {\n      \
    \  for ($j = 0; $j < $N; $j++) {\n            $min[$i][$j] = PHP_INT_MAX;\n  \
    \      }\n    }\n    for ($i = 0; $i < $M; $i++) {\n        for ($j = 0; $j <\
    \ $N; $j++) {\n            if ($k === 1) {\n                if ($min[$i][$j] >\
    \ $grid[$i][$j]) {\n                    $min[$i][$j] = $grid[$i][$j];\n      \
    \          }\n            } else {\n                if ($i > 0) {\n          \
    \          if ($min[$i][$j] > $grid[$i][$j] + $min[$i - 1][$j]) {\n          \
    \              $min[$i][$j] = $grid[$i][$j] + $min[$i - 1][$j];\n            \
    \        }\n                }\n                if ($j > 0) {\n               \
    \     if ($min[$i][$j] > $grid[$i][$j] + $min[$i][$j - 1]) {\n               \
    \         $min[$i][$j] = $grid[$i][$j] + $min[$i][$j - 1];\n                 \
    \   }\n                }\n            }\n        }\n    }\n    $result = PHP_INT_MAX;\n\
    \    $minPath = [];\n    for ($i = 0; $i < $M; $i++) {\n        for ($j = 0; $j\
    \ < $N; $j++) {\n            if ($result > $min[$i][$j]) {\n                $result\
    \ = $min[$i][$j];\n                $minPath = [$i, $j];\n            }\n     \
    \   }\n    }\n    $path = [];\n    $path[] = $grid[$minPath[0]][$minPath[1]];\n\
    \    while ($k-- > 1) {\n        if ($minPath[0]", "    $rows = count($grid);\n\
    \    $cols = count($grid[0]);\n    $minPath = null;\n    $minPathVal = INF;\n\
    \    for ($i = 0; $i < $rows; $i++) {\n        for ($j = 0; $j < $cols; $j++)\
    \ {\n            $path = [];\n            findPath($grid, $k, $i, $j, $path, $minPath,\
    \ $minPathVal);\n        }\n    }\n    return $minPath;\n}\n", "    // todo\n}",
  "    $n = count($grid);\n    $m = count($grid[0]);\n    $min = getMinPath($grid,\
    \ $n, $m, $k);\n    return $min;\n}", "    $n = count($grid);\n    $visited =\
    \ array_fill(0, $n, array_fill(0, $n, false));\n    $path = array();\n    $minPath\
    \ = minPathHelper($grid, $k, 0, 0, $visited, $path);\n    return $minPath;\n}\n",
  "  if ($k === 0) {\n    return [];\n  }\n  if ($k === 1) {\n    return [$grid[0][0]];\n\
    \  }\n  $maxRow = count($grid);\n  $maxCol = count($grid[0]);\n  $offsets = [[-1,\
    \ 0], [0, -1], [1, 0], [0, 1]];\n  // We keep a list of all the k-paths we have\
    \ encountered so far.\n  $visitedPaths = [];\n  // We keep track of the minimum\
    \ k-path so far.\n  $minPath = [];\n  $visited = [];\n  for ($i = 0; $i < $maxRow;\
    \ $i++) {\n    $visited[$i] = [];\n    for ($j = 0; $j < $maxCol; $j++) {\n  \
    \    $visited[$i][$j] = false;\n    }\n  }\n  $curPath = [];\n  $visited[0][0]\
    \ = true;\n  dfs(0, 0, $k, $visited, $curPath, $visitedPaths, $minPath, $grid);\n\
    \  return $minPath;\n}", "    if (count($grid) == 0 || count($grid[0]) == 0) {\n\
    \        return [];\n    }\n    $rowCount = count($grid);\n    $colCount = count($grid[0]);\n\
    \    $paths = [];\n    for ($i = 0; $i < $rowCount; $i++) {\n        for ($j =\
    \ 0; $j < $colCount; $j++) {\n            $newPath = [];\n            $newPath[]\
    \ = $grid[$i][$j];\n            $paths[] = $newPath;\n        }\n    }\n    for\
    \ ($l = 1; $l < $k; $l++) {\n        $nextPaths = [];\n        foreach ($paths\
    \ as $path) {\n            $row = $path[$l - 1] % $rowCount;\n            $col\
    \ = $path[$l - 1] / $rowCount;\n            if ($row > 0) {\n                $p\
    \ = $path;\n                $p[] = $grid[$row - 1][$col];\n                $nextPaths[]\
    \ = $p;\n            }\n            if ($row < $rowCount - 1) {\n            \
    \    $p = $path;\n                $p[] = $grid[$row + 1][$col];\n            \
    \    $nextPaths[] = $p;\n            }\n            if ($col > 0) {\n        \
    \        $p = $path;\n                $p[] = $grid[$row][$col - 1];\n        \
    \        $nextPaths[] = $p;\n            }\n            if ($col < $colCount -\
    \ 1) {\n                $p = $path;\n                $p[] = $grid[$row][$col +\
    \ 1];\n                $nextPaths[] = $p;\n            }\n        }\n        $paths\
    \ = $nextPaths;\n    }\n    $minPath = $paths[0];\n    for ($i = 1; $i < count($paths);\
    \ $i++) {\n        if (pathLessThan($paths[$i], $minPath)) {\n            $minPath\
    \ = $paths[$i];\n        }\n    }\n    return $minPath;\n}", "\n}", "    if ($k\
    \ == 0) {\n        return [];\n    }\n    if ($k == 1) {\n        return [1];\n\
    \    }\n    $length = count($grid);\n    $col = count($grid[0]);\n    $visited\
    \ = [];\n    for ($i = 0; $i < $length; $i++) {\n        for ($j = 0; $j < $col;\
    \ $j++) {\n            $visited[$i][$j] = false;\n        }\n    }\n    $minResult\
    \ = null;\n    $minPath = null;\n    for ($i = 0; $i < $length; $i++) {\n    \
    \    for ($j = 0; $j < $col; $j++) {\n            dfs($grid, $i, $j, $visited,\
    \ $k, [], $minResult, $minPath);\n        }\n    }\n    return $minPath;\n}",
  "    $n = count($grid);\n    if ($n === 0) {\n        return [];\n    }\n    if\
    \ ($k <= 0) {\n        return [];\n    }\n    $m = count($grid[0]);\n    $result\
    \ = [];\n    $visited = [];\n    for ($i = 0; $i < $n; $i++) {\n        $visited[]\
    \ = array_fill(0, $m, false);\n    }\n    $res = [];\n    for ($i = 0; $i < $n;\
    \ $i++) {\n        for ($j = 0; $j < $m; $j++) {\n            $res[] = [$grid[$i][$j],\
    \ [$i, $j]];\n        }\n    }\n    usort($res, function($a, $b) {\n        return\
    \ $a[0] - $b[0];\n    });\n    $q = new \\Ds\\PriorityQueue();\n    for ($i =\
    \ 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n            $q->push([$grid[$i][$j],\
    \ [$i, $j]]);\n        }\n    }\n    while (!$q->isEmpty()) {\n        $value\
    \ = $q->pop();\n        list($c, $l) = $value;\n        list($x, $y) = $l;\n \
    \       if ($k === 1) {\n            return [$c];\n        }\n        for ($i\
    \ = 0; $i < 4; $i++) {\n            $nx = $x + $i[0];\n            $ny = $y +\
    \ $i[1];\n            if ($nx < 0 || $nx >= $n || $ny < 0 || $ny >= $m || $visited[$nx][$ny])\
    \ {\n                continue;\n            }\n            $visited[$nx][$ny]\
    \ = true;\n            list($c, $l) = $q->pop();\n            $newL = array_merge($l,\
    \ [[$x, $y]]);\n            $q->push([$c, $newL]);\n        }", "    $n = count($grid);\n\
    \    $visited = array_fill(0, $n, array_fill(0, $n, false));\n    $res = [];\n\
    \    $best_res = [];\n    dfs($grid, $n, 0, 0, $k, $visited, $res, $best_res);\n\
    \    return $best_res;\n}\n", "    $result = [];\n    $len = count($grid);\n \
    \   if ($len < 2 || $k < 1) {\n        return $result;\n    }\n    $width = count($grid[0]);\n\
    \    if ($width < 2 || $k < 1) {\n        return $result;\n    }\n    $visited\
    \ = array_fill(0, $len, array_fill(0, $width, false));\n    $visited[0][0] = true;\n\
    \    $result = [$grid[0][0]];\n    if ($k === 1) {\n        return $result;\n\
    \    }\n    $memo = [];\n    dfs($grid, $k, $len, $width, 0, 0, $visited, $result,\
    \ $memo);\n    ksort($memo);\n    return reset($memo);\n}", "    $max = PHP_INT_MIN;\n\
    \    $min = PHP_INT_MAX;\n    $count = count($grid);\n    $gridFlat = [];\n  \
    \  for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++)\
    \ {\n            $gridFlat[] = $grid[$i][$j];\n            $max = max($max, $grid[$i][$j]);\n\
    \            $min = min($min, $grid[$i][$j]);\n        }\n    }\n    $num = count($gridFlat);\n\
    \    $mid = $min + ($max - $min) / 2;\n    $p = array_fill(0, $num, -1);\n   \
    \ $v = array_fill(0, $num, false);\n    $q = array_fill(0, $num, PHP_INT_MAX);\n\
    \    $l = [];\n    $parent = [];\n    $t = array_fill(0, $num, 0);\n    $parent[$k]\
    \ = -1;\n    $t[$k] = true;\n    $p[$k] = 0;\n    $q[$k] = $gridFlat[$k];\n  \
    \  $l[0] = $k;\n    $idx = 0;\n    $head = 0;\n    $tail = 1;\n    while ($head\
    \ < $tail) {\n        $min = PHP_INT_MAX;\n        $u = -1;\n        for ($i =\
    \ $head; $i < $tail; $i++) {\n            $vertex = $l[$i];\n            if ($v[$vertex])\
    \ {\n                continue;\n            }\n            if ($q[$vertex] < $min)\
    \ {\n                $min = $q[$vertex];\n                $u = $vertex;\n    \
    \        }\n        }\n        if ($u == -1) {\n            break;\n        }\n\
    \        $idx++;\n        $v[$u] = true;\n        $pos = (int) floor($u / $count);\n\
    \        $col = $u % $count;\n        if ($pos", "    $rows = count($grid);\n\
    \    $cols = count($grid[0]);\n    if ($k <= 0) {\n        return [];\n    }\n\
    \    if ($k == 1) {\n        return [min_array($grid)];\n    }\n    $map = [];\n\
    \    $queue = [];\n    $set = [];\n    $set[0] = true;\n    $map[0] = [0];\n \
    \   array_push($queue, 0);\n    $i = 0;\n    while ($i < $k) {\n        $size\
    \ = count($queue);\n        while ($size-- > 0) {\n            $v = array_shift($queue);\n\
    \            $r = intdiv($v, $cols);\n            $c = $v % $cols;\n         \
    \   if ($r-1 >= 0 && !isset($set[$v-1])) {\n                $set[$v-1] = true;\n\
    \                $map[$v-1] = $map[$v];\n                array_push($map[$v-1],\
    \ $grid[$r-1][$c]);\n                array_push($queue, $v-1);\n            }\n\
    \            if ($r+1 < $rows && !isset($set[$v+1])) {\n                $set[$v+1]\
    \ = true;\n                $map[$v+1] = $map[$v];\n                array_push($map[$v+1],\
    \ $grid[$r+1][$c]);\n                array_push($queue, $v+1);\n            }\n\
    \            if ($c-1 >= 0 && !isset($set[$v-$cols])) {\n                $set[$v-$cols]\
    \ = true;\n                $map[$v-$cols] = $map[$v];\n                array_push($map[$v-$cols],\
    \ $grid[$r][$c-1]);\n                array_push($queue, $v-$cols);\n         \
    \   }\n            if ($c+1 < $cols && !isset($set[$v+$cols])) {\n           \
    \     $set[$v+$cols] = true;\n                $", "    $n = count($grid);\n  \
    \  $m = count($grid[0]);\n    $dx = [0, 1, 0, -1];\n    $dy = [1, 0, -1, 0];\n\
    \    $result = array_fill(0, $k, PHP_INT_MAX);\n    $min = PHP_INT_MAX;\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n         \
    \   for ($o = 0; $o < 4; $o++) {\n                if (dfs($grid, $i, $j, $k, 0,\
    \ $dx, $dy, $o, $result)) {\n                    $s = implode('', $result);\n\
    \                    if ($s < $min) {\n                        $min = $s;\n  \
    \                  }\n                }\n            }\n        }\n    }\n   \
    \ return explode('', $min);\n}", "    $minPath = [];\n    $rows = count($grid);\n\
    \    $cols = count($grid[0]);\n    $k--;\n    $i = $j = 0;\n    while ($k-- >\
    \ 0) {\n        $minPath[] = $grid[$i][$j];\n        if ($i + 1 < $rows && $grid[$i\
    \ + 1][$j] < $grid[$i][$j + 1]) {\n            $i++;\n        } else {\n     \
    \       $j++;\n        }\n    }\n    $minPath[] = $grid[$i][$j];\n    return $minPath;\n\
    }\n$grid = [ [1,2,3], [4,5,6], [7,8,9]];\n$k = 3;\nprint_r(minPath($grid, $k));",
  "    $N = count($grid);\n    $visited = [];\n    for ($i = 0; $i < $N; $i++) {\n\
    \        for ($j = 0; $j < $N; $j++) {\n            $visited[$i][$j] = false;\n\
    \        }\n    }\n    $minPath = [];\n    $minVal = PHP_INT_MAX;\n    for ($i\
    \ = 0; $i < $N; $i++) {\n        for ($j = 0; $j < $N; $j++) {\n            $row\
    \ = $i;\n            $col = $j;\n            $curPath = [];\n            for ($len\
    \ = 0; $len < $k; $len++) {\n                $visited[$row][$col] = true;\n  \
    \              $curPath[] = $grid[$row][$col];\n                $min = PHP_INT_MAX;\n\
    \                $dir = [];\n                if ($row > 0 && !$visited[$row -\
    \ 1][$col]) {\n                    $min = min($min, $grid[$row - 1][$col]);\n\
    \                    $dir[] = [$row - 1, $col];\n                }\n         \
    \       if ($row < $N - 1 && !$visited[$row + 1][$col]) {\n                  \
    \  $min = min($min, $grid[$row + 1][$col]);\n                    $dir[] = [$row\
    \ + 1, $col];\n                }\n                if ($col > 0 && !$visited[$row][$col\
    \ - 1]) {\n                    $min = min($min, $grid[$row][$col - 1]);\n    \
    \                $dir[] = [$row, $col - 1];\n                }\n             \
    \   if ($col < $N - 1 && !$visited[$row][$col + 1]) {\n                    $min\
    \ = min($min, $grid[$row][$col + 1]);\n                    $dir[] = [$row, $col\
    \ + 1];\n                }\n                $cur = $grid[$row][$col];\n      \
    \          $diff = $min - $cur;\n                for ($x = 0; $x < count($dir);\
    \ $x++) {\n                    $len1", "\t$N = count($grid);\n\tif ($k == 1) {\n\
    \t\treturn [$grid[0][0]];\n\t}\n\t$dp = [];\n\tfor ($i = 0; $i < $N; $i++) {\n\
    \t\tfor ($j = 0; $j < $N; $j++) {\n\t\t\t$dp[$i][$j] = [];\n\t\t}\n\t}\n\tfor\
    \ ($i = 0; $i < $N; $i++) {\n\t\tfor ($j = 0; $j < $N; $j++) {\n\t\t\t$dp[$i][$j][0]\
    \ = [$grid[$i][$j]];\n\t\t}\n\t}\n\tfor ($i = 0; $i < $N; $i++) {\n\t\tfor ($j\
    \ = 0; $j < $N; $j++) {\n\t\t\tfor ($step = 1; $step < $k; $step++) {\n\t\t\t\t\
    if ($i - 1 >= 0) {\n\t\t\t\t\t$temp = array_merge($dp[$i - 1][$j][$step - 1],\
    \ [$grid[$i][$j]]);\n\t\t\t\t\tif (count($dp[$i][$j][$step]) == 0) {\n\t\t\t\t\
    \t\t$dp[$i][$j][$step] = $temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$dp[$i][$j][$step]\
    \ = cmp($dp[$i][$j][$step], $temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($i +\
    \ 1 < $N) {\n\t\t\t\t\t$temp = array_merge($dp[$i + 1][$j][$step - 1], [$grid[$i][$j]]);\n\
    \t\t\t\t\tif (count($dp[$i][$j][$step]) == 0) {\n\t\t\t\t\t\t$dp[$i][$j][$step]\
    \ = $temp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$dp[$i", "    $n = count($grid);\n\
    \    $m = count($grid[0]);\n    $minPath = [];\n    for ($i = 0; $i < $n; $i++)\
    \ {\n        for ($j = 0; $j < $m; $j++) {\n            $dp[$i][$j] = [];\n  \
    \          for ($len = 0; $len < $k; $len++) {\n                $dp[$i][$j][$len]\
    \ = [];\n            }\n        }\n    }\n    for ($i = 0; $i < $n; $i++) {\n\
    \        for ($j = 0; $j < $m; $j++) {\n            if ($i == 0 && $j == 0) {\n\
    \                $dp[$i][$j][0] = [$grid[$i][$j]];\n            } elseif ($i ==\
    \ 0) {\n                if (empty($dp[$i][$j - 1][0])) {\n                   \
    \ $dp[$i][$j][0] = [];\n                } else {\n                    $dp[$i][$j][0]\
    \ = array_merge($dp[$i][$j - 1][0], [$grid[$i][$j]]);\n                }\n   \
    \         } elseif ($j == 0) {\n                if (empty($dp[$i - 1][$j][0]))\
    \ {\n                    $dp[$i][$j][0] = [];\n                } else {\n    \
    \                $dp[$i][$j][0] = array_merge($dp[$i - 1][$j][0], [$grid[$i][$j]]);\n\
    \                }\n            } else {\n                if (empty($dp[$i - 1][$j][0])\
    \ && empty($dp[$i][$j - 1][0])) {\n                    $dp[$i][$j][0] = [];\n\
    \                } elseif (empty($dp[$i - 1][$j][0])) {\n                    $dp[$i][$j][0]\
    \ = array_merge($dp[$i][$j - 1][0], [$grid[$i][$j]]);\n                } elseif\
    \ (empty", "    $m = count($grid);\n    $n = count($grid[0]);\n    $minPath =\
    \ [];\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            $minPath[$i][$j] = [];\n        }\n    }\n    $minPath[0][0][0]\
    \ = $grid[0][0];\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j <\
    \ $n; $j++) {\n            for ($currLen = 1; $currLen <= $k; $currLen++) {\n\
    \                $minPath[$i][$j][$currLen] = INF;\n                if ($i > 0)\
    \ {\n                    $up = $minPath[$i - 1][$j][$currLen - 1];\n         \
    \           if ($up < INF) {\n                        $newPath = $minPath[$i -\
    \ 1][$j][$currLen - 1];\n                        array_push($newPath, $grid[$i][$j]);\n\
    \                        $minPath[$i][$j][$currLen] = $newPath;\n            \
    \        }\n                }\n                if ($j > 0) {\n               \
    \     $left = $minPath[$i][$j - 1][$currLen - 1];\n                    if ($left\
    \ < INF) {\n                        $newPath = $minPath[$i][$j - 1][$currLen -\
    \ 1];\n                        array_push($newPath, $grid[$i][$j]);\n        \
    \                if ($newPath < $minPath[$i][$j][$currLen]) {\n              \
    \              $minPath[$i][$j][$currLen] = $newPath;\n                      \
    \  }\n                    }\n                }\n            }\n        }\n   \
    \ }\n    return $minPath[$m - 1][$n - 1][$k];\n}\n\n$grid = [\n    [1,2,3],\n\
    \    [4,5,6],\n    [7,8,9]\n];\n$k = 3;\nprint_r", "\t$n = count($grid);\n\t$res\
    \ = [];\n\t$visited = [];\n\tfor ($i = 0; $i < $n; $i++) {\n\t\tfor ($j = 0; $j\
    \ < $n; $j++) {\n\t\t\t$visited[$i][$j] = false;\n\t\t}\n\t}\n\t$x = 0;\n\t$y\
    \ = 0;\n\t$visited[$x][$y] = true;\n\t$index = 0;\n\t$min = $grid[$x][$y];\n\t\
    minPathHelper($grid, $x, $y, $n, $k, $res, $index, $visited, $min);\n\treturn\
    \ $res;\n}", "    return null;\n}", "    if ($k === 0) {\n        return [];\n\
    \    }\n    $s = strlen($grid);\n    $t = strlen($grid[0]);\n    // $prev[$i][$j]\
    \ = [$val, $idx] means that the previous node on the path is\n    // the value\
    \ $val at the index $idx.\n    $prev = [];\n    $idx = 0;\n    for ($i = 0; $i\
    \ < $s; $i++) {\n        for ($j = 0; $j < $t; $j++) {\n            $prev[$i][$j]\
    \ = [$grid[$i][$j], $idx++];\n        }\n    }\n    for ($l = 0; $l < $k - 1;\
    \ $l++) {\n        $next = [];\n        for ($i = 0; $i < $s; $i++) {\n      \
    \      for ($j = 0; $j < $t; $j++) {\n                if ($i === 0 && $j === 0)\
    \ {\n                    $new_val = min($prev[$i][$j + 1][0], $prev[$i + 1][$j][0]);\n\
    \                    $new_idx = $prev[$i][$j + 1][0] < $prev[$i + 1][$j][0] ?\n\
    \                        $prev[$i][$j + 1][1] : $prev[$i + 1][$j][1];\n      \
    \          } else if ($i === 0) {\n                    $new_val = min($prev[$i][$j\
    \ - 1][0], $prev[$i][$j + 1][0], $prev[$i + 1][$j][0]);\n                    $new_idx\
    \ = $prev[$i][$j - 1][0] < $prev[$i][$j + 1][0] ?\n                        $prev[$i][$j\
    \ - 1][1] : $prev[$i][$j + 1][1];\n                    if ($prev[$i + 1][$j][0]\
    \ < $new_val) {\n                        $new_val = $prev[$i + 1][$j][0];\n  \
    \                      $new_id", "    $N = count($grid);\n    $min = [];\n   \
    \ $newMin = [];\n    $q = new SplQueue();\n    for ($i = 0; $i < $N; $i++) {\n\
    \        for ($j = 0; $j < $N; $j++) {\n            $visited = [];\n         \
    \   for ($m = 0; $m < $N; $m++) {\n                $visited[$m] = array_fill(0,\
    \ $N, false);\n            }\n            $path = [];\n            $q->enqueue([$i,\
    \ $j]);\n            $visited[$i][$j] = true;\n            while (!$q->isEmpty())\
    \ {\n                list($a, $b) = $q->dequeue();\n                $path[] =\
    \ $grid[$a][$b];\n                $directions = [[-1, 0], [1, 0], [0, -1], [0,\
    \ 1]];\n                foreach ($directions as $direction) {\n              \
    \      $newX = $a + $direction[0];\n                    $newY = $b + $direction[1];\n\
    \                    if ($newX >= 0 && $newX < $N && $newY >= 0 && $newY < $N\
    \ && !$visited[$newX][$newY]) {\n                        $q->enqueue([$newX, $newY]);\n\
    \                        $visited[$newX][$newY] = true;\n                    }\n\
    \                }\n            }\n            if (count($path) >= $k) {\n   \
    \             $newMin[] = array_slice($path, 0, $k);\n            }\n        }\n\
    \    }\n    $min = $newMin[0];\n    for ($i = 1; $i < count($newMin); $i++) {\n\
    \        if (compare($newMin[$i], $min) == -1) {\n            $min = $newMin[$i];\n\
    \        }\n    }\n    return $min;\n}\n", "    $rows = count($grid);\n    $cols\
    \ = count($grid[0]);\n    $visited = array_fill(0, $rows, array_fill(0, $cols,\
    \ false));\n    $values = [];\n    $minPath = PHP_INT_MAX;\n    dfs($grid, $visited,\
    \ $values, $minPath, $k, 0, 0, 0);\n    return $values;\n}", "    $n = count($grid);\n\
    \    $m = count($grid[0]);\n    if ($k == 1) {\n        return [$grid[0][0]];\n\
    \    }\n    $curr = [0, 0];\n    $result = [];\n    $result[] = $grid[0][0];\n\
    \    while ($k > 1) {\n        if (isset($grid[$curr[0]][$curr[1] + 1]) && isset($grid[$curr[0]\
    \ + 1][$curr[1]])) {\n            if ($grid[$curr[0]][$curr[1] + 1] > $grid[$curr[0]\
    \ + 1][$curr[1]]) {\n                $curr[0]++;\n            } else {\n     \
    \           $curr[1]++;\n            }\n        } elseif (isset($grid[$curr[0]][$curr[1]\
    \ + 1])) {\n            $curr[1]++;\n        } elseif (isset($grid[$curr[0] +\
    \ 1][$curr[1]])) {\n            $curr[0]++;\n        }\n        $result[] = $grid[$curr[0]][$curr[1]];\n\
    \        $k--;\n    }\n    return $result;\n}\n$grid = [\n    [5,9,3],\n    [4,1,6],\n\
    \    [7,8,2]\n];\nvar_dump(minPath($grid, 1));", "  $m = count($grid);\n  $n =\
    \ count($grid[0]);\n  $delta = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  $seen =\
    \ array_fill(0, $m, array_fill(0, $n, false));\n  $q = new SplPriorityQueue();\n\
    \  $q->insert([[$grid[0][0]], [0, 0]], ['path' => $grid[0][0], 'position' => 0]);\n\
    \  $seen[0][0] = true;\n  while (!$q->isEmpty()) {\n    $minPath = $q->extract();\n\
    \    $position = $minPath['position'];\n    if (count($minPath['path']) === $k)\
    \ {\n      return $minPath['path'];\n    }\n    foreach ($delta as $i => $d) {\n\
    \      $x = $position[0] + $d[0];\n      $y = $position[1] + $d[1];\n      if\
    \ ($x >= 0 && $x < $m && $y >= 0 && $y < $n && !$seen[$x][$y]) {\n        $newPath\
    \ = $minPath['path'];\n        $newPath[] = $grid[$x][$y];\n        $q->insert([$newPath,\
    \ [$x, $y]], ['path' => $newPath, 'position' => $x]);\n        $seen[$x][$y] =\
    \ true;\n      }\n    }\n  }\n}\necho '<pre>';\nprint_r(minPath([ [1,2,3], [4,5,6],\
    \ [7,8,9]], 3));\necho '</pre>';", "    if (empty($grid) || $k == 0) {\n     \
    \   return [];\n    }\n    $rows = count($grid);\n    $cols = count($grid[0]);\n\
    \    $s = [];\n    $s[0] = [];\n    $s[0][0] = [$grid[0][0]];\n    for ($i = 1;\
    \ $i < $rows; $i++) {\n        $s[$i] = [];\n        $s[$i][0] = $s[$i - 1][0];\n\
    \        $s[$i][0][] = $grid[$i][0];\n    }\n    for ($j = 1; $j < $cols; $j++)\
    \ {\n        $s[0][$j] = $s[0][$j - 1];\n        $s[0][$j][] = $grid[0][$j];\n\
    \    }\n    for ($i = 1; $i < $rows; $i++) {\n        for ($j = 1; $j < $cols;\
    \ $j++) {\n            $s[$i][$j] = $s[$i - 1][$j];\n            if (gridFirst($s[$i][$j],\
    \ $s[$i][$j - 1]) > 0) {\n                $s[$i][$j] = $s[$i][$j - 1];\n     \
    \       }\n            $s[$i][$j][] = $grid[$i][$j];\n        }\n    }\n    $minPath\
    \ = $s[$rows - 1][$cols - 1];\n    while (count($minPath) > $k) {\n        array_pop($minPath);\n\
    \    }\n    return $minPath;\n}", "    $N = count($grid);\n    $vals = [];\n \
    \   for ($i = 0; $i < $N; $i++) {\n        for ($j = 0; $j < $N; $j++) {\n   \
    \         $vals[$grid[$i][$j]] = [$i, $j];\n        }\n    }\n    $dp = array_fill(0,\
    \ $N, array_fill(0, $N, -1));\n    $dp[0][0] = $grid[0][0];\n    $path = [$grid[0][0]];\n\
    \    minPathHelper($grid, $dp, $k - 1, 0, 0, $path, $vals);\n    return $path;\n\
    }", "  $len = count($grid);\n  if ($len == 0) {\n    return [];\n  }\n  if ($k\
    \ == 0) {\n    return [];\n  }\n  if ($k == 1) {\n    return [$grid[0][0]];\n\
    \  }\n  if ($k == $len * $len) {\n    $arr = [];\n    for ($i = 0; $i < $len;\
    \ $i++) {\n      for ($j = 0; $j < $len; $j++) {\n        $arr[] = $grid[$i][$j];\n\
    \      }\n    }\n    return $arr;\n  }\n  $dp = [];\n  $path = [];\n  $len_1 =\
    \ $len - 1;\n  $len_2 = $len - 2;\n  $len_3 = $len - 3;\n  for ($i = 0; $i < $len;\
    \ $i++) {\n    for ($j = 0; $j < $len; $j++) {\n      if ($i == 0 && $j == 0)\
    \ {\n        $dp[$i][$j] = [$grid[$i][$j]];\n        $path[$i][$j] = [$grid[$i][$j]];\n\
    \      } else if ($i == 0) {\n        $dp[$i][$j] = [$grid[$i][$j], $grid[$i][$j\
    \ - 1]];\n        $path[$i][$j] = [$grid[$i][$j]];\n      } else if ($j == 0)\
    \ {\n        $dp[$i][$j] = [$grid[$i][$j], $grid[$i - 1][$j]];\n        $path[$i][$j]\
    \ = [$grid[$i][$j]];\n      } else {\n        $dp[$i][$j] = [$grid[$i][$j], $grid[$i\
    \ - 1][$j], $grid[$i][$j - 1]];\n        $path[$i][$j] = [$grid[$i][$j]];\n  \
    \    }\n    }\n  }", "    // first, we need to find every possible path\n    //\
    \ then, we need to select the minimum path\n    // we can use a stack to keep\
    \ track of the path\n    // we can either do a depth first search or a breadth\
    \ first search\n    // since we need to return the values of the path, the algorithm\
    \ will be\n    // slightly different from the usual DFS or BFS\n    // we don't\
    \ want to just return the first value we see\n    // I will work on the assumption\
    \ that we want to implement DFS for now\n    // if the path we find is smaller\
    \ than what we have, then we update the result\n    // otherwise, we skip\n  \
    \  // base case: if we hit the desired length, we check if it is less than the\n\
    \    // current result\n    // otherwise, we continue\n    // for each adjacent\
    \ cell, we explore it, then undo the change (i.e. backtrack)\n    // since we\
    \ need to find the path, we need to keep track of which cells we have visited\n\
    \    // the path is an ordered list of the values on the cells that the minimum\
    \ path go through\n    // the question wasn't very clear with what they meant\n\
    \    // I will assume that the question wanted me to find the minimum value in\
    \ the path\n    // and we return the values in the order in which we visited them\n\
    \    $N = count($grid);\n    if ($N == 0) {\n        return [];\n    }\n    if\
    \ ($k == 0) {\n        return [];\n    }\n    if ($k > $N * $N) {\n        return\
    \ [];\n    }\n    $result = [];\n    $visited = [];\n    $min = PHP_INT_MAX;\n\
    \    for ($i = 0; $i < $N; $i++) {\n        for ($j = 0; $j < $N; $j++) {\n  \
    \          if ($grid[$i][$j] < $min) {\n                $min = $grid[$i][$j];\n\
    \            }\n        }\n    }\n    for ($i = 0; $i < $N; $i++) {\n        for\
    \ ($j = 0; $j < $N; $j++) {\n            $visited[$i][$j] = false;\n        }\n\
    \    }\n", "    $result = [];\n    if ($k == 0) {\n        return $result;\n \
    \   }\n    $n = count($grid);\n    $m = count($grid[0]);\n    $visited = [];\n\
    \    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n  \
    \          $visited[$i][$j] = 0;\n        }\n    }\n    $queue = new SplQueue();\n\
    \    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n  \
    \          $queue->enqueue([$i, $j, $grid[$i][$j], 1]);\n        }\n    }\n  \
    \  $min = [];\n    while (!$queue->isEmpty()) {\n        $top = $queue->dequeue();\n\
    \        $x = $top[0];\n        $y = $top[1];\n        $cost = $top[2];\n    \
    \    $len = $top[3];\n        if ($len == $k) {\n            if (empty($min) ||\
    \ $cost < $min[0]) {\n                $min = [$cost, $top[3]];\n            }\n\
    \            continue;\n        }\n        if ($visited[$x][$y] == 1) {\n    \
    \        continue;\n        }\n        $visited[$x][$y] = 1;\n        if ($x -\
    \ 1 >= 0 && $visited[$x - 1][$y] == 0) {\n            $newCost = $cost * 10 +\
    \ $grid[$x - 1][$y];\n            $queue->enqueue([$x - 1, $y, $newCost, $len\
    \ + 1]);\n        }\n        if ($x + 1 < $n && $visited[$x + 1][$y] == 0) {\n\
    \            $newCost = $cost * 10 + $grid[$x + 1][$y];\n            $queue->enqueue([$x\
    \ + 1, $y, $newCost, $len + 1]);\n        }\n        if ($y - 1 >= 0 && $visited[$",
  "    // find all unique paths of length k\n    // put them in an array\n    // iterate\
    \ over the array and return the path that is \"less than\" all the others\n  \
    \  $map = new Map();\n    $map->put(0, $grid[0][0]);\n    $paths = [];\n    $check\
    \ = [];\n    $queue = new SplQueue();\n    $queue->enqueue($map);\n    $queue->enqueue(null);\n\
    \    $level = 0;\n    $count = 0;\n    while (!$queue->isEmpty()) {\n        $node\
    \ = $queue->dequeue();\n        if ($node === null) {\n            $level++;\n\
    \            if ($level > $k) {\n                break;\n            }\n     \
    \       if (!$queue->isEmpty()) {\n                $queue->enqueue(null);\n  \
    \          }\n        } else {\n            $nodeVal = $node->value;\n       \
    \     $nodeKey = $node->key;\n            if ($level > 1) {\n                $check[]\
    \ = $nodeVal;\n            }\n            if ($level == $k) {\n              \
    \  $count++;\n                $paths[] = $nodeVal;\n            }\n          \
    \  $path = $nodeVal;\n            $r = $nodeKey / count($grid);\n            $c\
    \ = $nodeKey % count($grid);\n            if ($r - 1 >= 0) {\n               \
    \ $key = ($r - 1) * count($grid) + $c;\n                $val = $grid[$r - 1][$c];\n\
    \                $newNode = new Node($key, $val);\n                $queue->enqueue($newNode);\n\
    \            }\n            if ($r + 1 < count($grid)) {\n                $key\
    \ = ($r + 1) * count($grid) + $c;\n                $val = $grid[$r + 1][$c];\n\
    \                $newNode = new Node($key, $val);\n                $queue->enqueue($newNode);\n\
    \            }\n            if ($c - 1 >= 0) {\n                $key = $r * count($grid)\
    \ + $c - 1;\n                $val = $grid[$r][$c - 1];\n                $newNode\
    \ = new Node", "    $n = count($grid);\n    if ($n < 2 || $k < 1) {\n        return\
    \ false;\n    }\n    $visited = array_fill(0, $n, array_fill(0, $n, false));\n\
    \    $dirs = [[0,1], [0,-1], [1,0], [-1,0]];\n    $min_path = [];\n    for ($i\
    \ = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if\
    \ ($visited[$i][$j]) {\n                continue;\n            }\n           \
    \ $visited[$i][$j] = true;\n            $current_path = [$grid[$i][$j]];\n   \
    \         $result = dfs($grid, $n, $i, $j, $visited, $k, $current_path, $dirs);\n\
    \            if ($result) {\n                if (empty($min_path)) {\n       \
    \             $min_path = $result;\n                } else {\n               \
    \     if (less_than($result, $min_path)) {\n                        $min_path\
    \ = $result;\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return $min_path;\n}", "    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $result = null;\n    $min = INF;\n    for ($i = 0; $i < $m; $i++) {\n   \
    \     for ($j = 0; $j < $n; $j++) {\n            if ($i > 0) {\n             \
    \   $list = [$grid[$i][$j]];\n                $list = helper($grid, $i - 1, $j,\
    \ $m, $n, $k - 1, $list);\n                if ($list !== null && $list[0] < $min)\
    \ {\n                    $min = $list[0];\n                    $result = $list;\n\
    \                }\n            }\n            if ($i < $m - 1) {\n          \
    \      $list = [$grid[$i][$j]];\n                $list = helper($grid, $i + 1,\
    \ $j, $m, $n, $k - 1, $list);\n                if ($list !== null && $list[0]\
    \ < $min) {\n                    $min = $list[0];\n                    $result\
    \ = $list;\n                }\n            }\n            if ($j > 0) {\n    \
    \            $list = [$grid[$i][$j]];\n                $list = helper($grid, $i,\
    \ $j - 1, $m, $n, $k - 1, $list);\n                if ($list !== null && $list[0]\
    \ < $min) {\n                    $min = $list[0];\n                    $result\
    \ = $list;\n                }\n            }\n            if ($j < $n - 1) {\n\
    \                $list = [$grid[$i][$j]];\n                $list = helper($grid,\
    \ $i, $j + 1, $m, $n, $k - 1, $list);\n                if ($list !== null && $list[0]\
    \ < $min) {\n                    $min = $list[0];\n                    $result\
    \ = $list;\n                }\n            }\n        }\n    }\n    return $result;\n\
    }", "    $m = count($grid);\n    $n = count($grid[0]);\n    if ($k > $m * $n)\
    \ {\n        return [];\n    }\n    $visited = array_fill(0, $m, array_fill(0,\
    \ $n, false));\n    $result = [];\n    $min = PHP_INT_MAX;\n    for ($i = 0; $i\
    \ < $m; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            $dfs($grid,\
    \ $i, $j, $k, 0, [], $visited, $result, $min);\n        }\n    }\n    return $result;\n\
    }", "    // I think BFS is the way to go here.\n    $result = [];\n    $queue\
    \ = new SplQueue();\n    $visited = [];\n    for ($i = 0; $i < count($grid); $i++)\
    \ {\n        for ($j = 0; $j < count($grid[$i]); $j++) {\n            $queue->enqueue([$i,\
    \ $j]);\n            $visited[$i][$j] = false;\n        }\n    }\n    while (!$queue->isEmpty())\
    \ {\n        $size = $queue->count();\n        for ($i = 0; $i < $size; $i++)\
    \ {\n            $curr = $queue->dequeue();\n            $row = $curr[0];\n  \
    \          $col = $curr[1];\n            $visited[$row][$col] = true;\n      \
    \      // first check if it is the solution\n            if (count($result) ==\
    \ $k) {\n                $result[] = $grid[$row][$col];\n                break;\n\
    \            }\n            $result[] = $grid[$row][$col];\n            // going\
    \ UP\n            if ($row - 1 >= 0 && !$visited[$row - 1][$col]) {\n        \
    \        $queue->enqueue([$row - 1, $col]);\n            }\n            // going\
    \ DOWN\n            if ($row + 1 < count($grid) && !$visited[$row + 1][$col])\
    \ {\n                $queue->enqueue([$row + 1, $col]);\n            }\n     \
    \       // going LEFT\n            if ($col - 1 >= 0 && !$visited[$row][$col -\
    \ 1]) {\n                $queue->enqueue([$row, $col - 1]);\n            }\n \
    \           // going RIGHT\n            if ($col + 1 < count($grid[$row]) && !$visited[$row][$col\
    \ + 1]) {\n                $queue->enqueue([$row, $col + 1]);\n            }\n\
    \        }\n    }\n    return $result;\n}\n$grid = [\n    [1,2,3],\n    [4,5,6],\n\
    \    [7,8,9]\n];\n$", "    return $grid;\n}\n\nprint_r(minPath([ [1,2,3], [4,5,6],\
    \ [7,8,9]], 3));\nprint_r(minPath([ [5,9,3], [4,1,6], [7,8,2]], 1));", "    $rows\
    \ = count($grid);\n    $cols = count($grid[0]);\n    $min = [];\n    for ($row\
    \ = 0; $row < $rows; $row++) {\n        for ($col = 0; $col < $cols; $col++) {\n\
    \            $min = minPathHelper($grid, $row, $col, $k, $min);\n        }\n \
    \   }\n    return $min;\n}", "    $n = count($grid);\n    if ($n == 0) {\n   \
    \     return [];\n    }\n    if ($k == 0) {\n        return [];\n    }\n    if\
    \ ($k > $n * $n) {\n        return [];\n    }\n    $minPath = null;\n    $minValues\
    \ = [];\n    $visited = [];\n    for ($i = 0; $i < $n; $i++) {\n        for ($j\
    \ = 0; $j < $n; $j++) {\n            $v = $grid[$i][$j];\n            $arr = [$v];\n\
    \            $visited[$i][$j] = true;\n            dfs($grid, $k, $i, $j, $n,\
    \ $minPath, $minValues, $arr, $visited);\n            $visited[$i][$j] = false;\n\
    \        }\n    }\n    return $minValues;\n}", "    // Initialize the path with\
    \ the first cell in the grid, and the path count\n    // with 1.\n    $path =\
    \ [$grid[0][0]];\n    $path_count = 1;\n    // Initialize the starting position\
    \ to [0, 0] and the queue with the first\n    // position in the grid.\n    $pos\
    \ = [0, 0];\n    $queue = [$pos];\n    // Initialize the visited grid with the\
    \ same size as the input grid, and\n    // initialize the visited cell with the\
    \ starting position to true, so that\n    // we don't visit it again.\n    $visited\
    \ = array_fill(0, count($grid), array_fill(0, count($grid), false));\n    $visited[$pos[0]][$pos[1]]\
    \ = true;\n    // Initialize the minimum path and the minimum path count.\n  \
    \  $min_path = $path;\n    $min_path_count = $path_count;\n    // While the queue\
    \ is not empty.\n    while (!empty($queue)) {\n        // Get the next position\
    \ to process from the queue.\n        $pos = array_shift($queue);\n        //\
    \ If we have visited the required number of cells.\n        if ($path_count ==\
    \ $k) {\n            // If the current path is less than the minimum path.\n \
    \           if ($path < $min_path) {\n                // Update the minimum path\
    \ and the minimum path count.\n                $min_path = $path;\n          \
    \      $min_path_count = $path_count;\n            }\n            // Continue\
    \ with the next position.\n            continue;\n        }\n        // Get the\
    \ neighbors of the current position.\n        $neighbors = getNeighbors($grid,\
    \ $pos);\n        // For each neighbor.\n        foreach ($neighbors as $neighbor)\
    \ {\n            // If we have visited the neighbor, continue.\n            if\
    \ ($visited[$neighbor[0]][$neighbor[1]]) {\n                continue;\n      \
    \      }\n            // Mark the neighbor as visited.\n            $visited[$neighbor[0]][$neighbor[1]]\
    \ = true;\n            // Add the neighbor to the queue.\n           ", "    $m\
    \ = count($grid);\n    $n = count($grid[0]);\n    if ($k < 1 || $k > $m * $n)\
    \ {\n        return [];\n    }\n    $min = $grid[0][0];\n    $max = $grid[$m -\
    \ 1][$n - 1];\n    if ($k == 1) {\n        return [$min];\n    }\n    $path =\
    \ [];\n    if ($k == $m * $n) {\n        for ($i = 0; $i < $m; $i++) {\n     \
    \       for ($j = 0; $j < $n; $j++) {\n                $path[] = $grid[$i][$j];\n\
    \            }\n        }\n        return $path;\n    }\n    $offset = $k % $m;\n\
    \    if ($offset == 0) {\n        $offset = $m;\n    }\n    for ($i = 0; $i <\
    \ $offset; $i++) {\n        $path[] = $grid[$i][0];\n    }\n    $num = $k / $m;\n\
    \    $num = intval($num);\n    $col = 0;\n    $row = $offset - 1;\n    for ($i\
    \ = 0; $i < $num; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n           \
    \ $row++;\n            $path[] = $grid[$row][$col];\n        }\n        $col++;\n\
    \    }\n    return $path;\n}\n\n$grid = [\n    [1,2,3],\n    [4,5,6],\n    [7,8,9]\n\
    ];\n$k = 3;\nprint_r(minPath($grid, $k));", "    $result = [];\n    if ($k <=\
    \ 0) {\n        return $result;\n    }\n    $N = count($grid);\n    $minHeap =\
    \ new MinHeap();\n    $visited = [];\n    $minHeap->insert(['value' => $grid[0][0],\
    \ 'path' => [0, 0], 'remaining_steps' => $k - 1]);\n    $visited[0][0] = true;\n\
    \    while (!$minHeap->isEmpty()) {\n        $node = $minHeap->extractMin();\n\
    \        if ($node['remaining_steps'] == 0) {\n            $result = array_merge([$node['value']],\
    \ $node['path']);\n            break;\n        }\n        $x = $node['path'][count($node['path'])\
    \ - 2];\n        $y = $node['path'][count($node['path']) - 1];\n        if ($x\
    \ - 1 >= 0 && !$visited[$x - 1][$y]) {\n            $visited[$x - 1][$y] = true;\n\
    \            $path = array_merge([$grid[$x - 1][$y]], $node['path']);\n      \
    \      $minHeap->insert(['value' => $grid[$x - 1][$y], 'path' => $path, 'remaining_steps'\
    \ => $node['remaining_steps'] - 1]);\n        }\n        if ($x + 1 < $N && !$visited[$x\
    \ + 1][$y]) {\n            $visited[$x + 1][$y] = true;\n            $path = array_merge([$grid[$x\
    \ + 1][$y]], $node['path']);\n            $minHeap->insert(['value' => $grid[$x\
    \ + 1][$y], 'path' => $path, 'remaining_steps' => $node['remaining_steps'] - 1]);\n\
    \        }\n        if ($y - 1 >= 0 && !$visited[$x][$y - 1]) {\n            $visited[$x][$y\
    \ - 1] = true;\n            $path = array_merge", "    if (empty($grid) || empty($grid[0]))\
    \ {\n        return [];\n    }\n    if ($k <= 0) {\n        return [];\n    }\n\
    \    if ($k == 1) {\n        return [[1]];\n    }\n    $rows = count($grid);\n\
    \    $cols = count($grid[0]);\n    $dict = $paths = [];\n    for ($i = 0; $i <\
    \ $rows; $i++) {\n        for ($j = 0; $j < $cols; $j++) {\n            $dict[$grid[$i][$j]]\
    \ = [$i, $j];\n        }\n    }\n    for ($i = 1; $i <= $rows * $cols; $i++) {\n\
    \        list($x, $y) = $dict[$i];\n        $paths[$i] = getPaths($grid, $x, $y,\
    \ $rows, $cols, $k);\n    }\n    $res = [];\n    for ($i = 1; $i <= $rows * $cols;\
    \ $i++) {\n        foreach ($paths[$i] as $path) {\n            if (empty($res)\
    \ || isLess($path, $res)) {\n                $res = $path;\n            }\n  \
    \      }\n    }\n    return $res;\n}\n", "    // let dp[i][j][k] be the minimum\
    \ path from (i, j) of length k\n    // dp[i][j][0] = 0\n    // dp[i][j][k] = min(dp[i\
    \ - 1][j][k - 1], dp[i + 1][j][k - 1], dp[i][j - 1][k - 1], dp[i][j + 1][k - 1])\n\
    \    // answer = dp[i][j][k] for any i, j\n    $row = count($grid);\n    $col\
    \ = count($grid[0]);\n    $dp = [];\n    for ($i = 0; $i < $row; $i++) {\n   \
    \     for ($j = 0; $j < $col; $j++) {\n            $dp[$i][$j][0] = 0;\n     \
    \   }\n    }\n    for ($l = 1; $l <= $k; $l++) {\n        for ($i = 0; $i < $row;\
    \ $i++) {\n            for ($j = 0; $j < $col; $j++) {\n                $min =\
    \ PHP_INT_MAX;\n                for ($m = 0; $m < 4; $m++) {\n               \
    \     $ii = $i + $m % 2 == 0 ? $m - 1 : 0;\n                    $jj = $j + $m\
    \ % 2 == 1 ? ($m - 2) / 2 + 1 : 0;\n                    if ($ii >= 0 && $ii <\
    \ $row && $jj >= 0 && $jj < $col) {\n                        $min = min($min,\
    \ $dp[$ii][$jj][$l - 1]);\n                    }\n                }\n        \
    \        $dp[$i][$j][$l] = $min + $grid[$i][$j];\n            }\n        }\n \
    \   }\n    $path = [];\n    $i = 0;\n    $j = 0;\n    for ($l = $k; $l > 0; $l--)\
    \ {\n        array_push($path, $grid[$i][$j]);\n        $min = PHP_INT_MAX;\n\
    \        $next = -1;\n        for ($m =", "    // TODO:\n}", "  list($m, $n) =\
    \ [count($grid), count($grid[0])];\n  $paths = [];\n  $visited = [];\n  $curr\
    \ = [$grid[0][0], 0, 0];\n  $visited[0][0] = true;\n  while ($curr) {\n    $paths[]\
    \ = $curr[0];\n    if (count($paths) === $k) {\n      return $paths;\n    }\n\
    \    $visited[$curr[1]][$curr[2]] = true;\n    $neighbors = [];\n    if ($curr[1]\
    \ - 1 >= 0 && !$visited[$curr[1] - 1][$curr[2]]) {\n      $neighbors[] = [$grid[$curr[1]\
    \ - 1][$curr[2]], $curr[1] - 1, $curr[2]];\n    }\n    if ($curr[1] + 1 < $m &&\
    \ !$visited[$curr[1] + 1][$curr[2]]) {\n      $neighbors[] = [$grid[$curr[1] +\
    \ 1][$curr[2]], $curr[1] + 1, $curr[2]];\n    }\n    if ($curr[2] - 1 >= 0 &&\
    \ !$visited[$curr[1]][$curr[2] - 1]) {\n      $neighbors[] = [$grid[$curr[1]][$curr[2]\
    \ - 1], $curr[1], $curr[2] - 1];\n    }\n    if ($curr[2] + 1 < $n && !$visited[$curr[1]][$curr[2]\
    \ + 1]) {\n      $neighbors[] = [$grid[$curr[1]][$curr[2] + 1], $curr[1], $curr[2]\
    \ + 1];\n    }\n    usort($neighbors, function($a, $b) { return $a[0] <=> $b[0];\
    \ });\n    $curr = $", "    $result = [];\n    $min = PHP_INT_MAX;\n    $M = count($grid);\n\
    \    $N = count($grid[0]);\n    $helper($grid, $M, $N, 0, 0, $k, $result, $min);\n\
    \    return $result;\n}\n", "  $m = count($grid);\n  $n = count($grid[0]);\n \
    \ $ans = [];\n  $min = INF;\n  $visited = array_fill(0, $m, array_fill(0, $n,\
    \ false));\n  $path = [];\n  $dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  for\
    \ ($i = 0; $i < $m; $i++) {\n    for ($j = 0; $j < $n; $j++) {\n      $path =\
    \ [];\n      $path[] = $grid[$i][$j];\n      $visited[$i][$j] = true;\n      dfs($grid,\
    \ $k, $min, $ans, $path, $visited, $i, $j, $dirs);\n      $visited[$i][$j] = false;\n\
    \    }\n  }\n  return $ans;\n}", "    if ($k <= 0) {\n        return [];\n   \
    \ }\n    $n = count($grid);\n    $visited = array_fill(0, $n, array_fill(0, $n,\
    \ false));\n    $min = [PHP_INT_MAX, []];\n    for ($i = 0; $i < $n; $i++) {\n\
    \        for ($j = 0; $j < $n; $j++) {\n            $visited[$i][$j] = true;\n\
    \            dfs($grid, $visited, $i, $j, $k, [$grid[$i][$j]], $min);\n      \
    \      $visited[$i][$j] = false;\n        }\n    }\n    return $min[1];\n}", " \
    \   $min = $grid[0][0];\n    $result = [];\n    for ($i = 0; $i < $k; $i++) {\n\
    \        $result[] = $min;\n        $min = findNext($grid, $result);\n    }\n\
    \    return $result;\n}\n", "    $result = [];\n    $m = count($grid);\n    $n\
    \ = count($grid[0]);\n    $visited = array_fill(0, $m, array_fill(0, $n, 0));\n\
    \    // $dx = [0, 1, 0, -1];\n    // $dy = [1, 0, -1, 0];\n    $dx = [0, -1, 0,\
    \ 1];\n    $dy = [-1, 0, 1, 0];\n    $min = INF;\n    for ($i = 0; $i < $m; $i++)\
    \ {\n        for ($j = 0; $j < $n; $j++) {\n            list($path, $visited)\
    \ = dfs($grid, $i, $j, $visited, $dx, $dy, $m, $n, 0, $k, []);\n            if\
    \ ($path) {\n                $curr = implode('', $path);\n                if ($curr\
    \ < $min) {\n                    $min = $curr;\n                    $result =\
    \ $path;\n                }\n            }\n        }\n    }\n    return $result;\n\
    }\n", "    $minPath = [];\n    $rowCount = count($grid);\n    $colCount = count($grid[0]);\n\
    \    $minPath = helper($grid, $k, 0, 0, $minPath, $rowCount, $colCount);\n   \
    \ return $minPath;\n}", "    $result = [];\n    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $visited = array_fill(0, $m, array_fill(0, $n, false));\n    $dfs($grid,\
    \ $k, $m, $n, 0, 0, $visited, $result);\n    return $result;\n}\n", "    if ($k\
    \ == 0) {\n        return [];\n    }\n    if ($k == 1) {\n        return [$grid[0][0]];\n\
    \    }\n    if ($k == 2) {\n        if ($grid[0][0] < $grid[0][1]) {\n       \
    \     return [$grid[0][0], $grid[0][1]];\n        } else if ($grid[0][0] < $grid[1][0])\
    \ {\n            return [$grid[0][0], $grid[1][0]];\n        } else {\n      \
    \      return [$grid[1][0], $grid[0][0]];\n        }\n    }\n    if ($k == 3)\
    \ {\n        if ($grid[0][0] < $grid[0][1]) {\n            return [$grid[0][0],\
    \ $grid[0][1], $grid[0][0]];\n        } else if ($grid[0][0] < $grid[1][0]) {\n\
    \            return [$grid[0][0], $grid[1][0], $grid[0][0]];\n        } else {\n\
    \            return [$grid[1][0], $grid[0][0], $grid[1][0]];\n        }\n    }\n\
    \    $path = [$grid[0][0]];\n    if ($grid[0][0] < $grid[0][1]) {\n        $path[]\
    \ = $grid[0][1];\n        $row = 0;\n        $col = 1;\n    } else if ($grid[0][0]\
    \ < $grid[1][0]) {\n        $path[] = $grid[1][0];\n        $row = 1;\n      \
    \  $col = 0;\n    } else {\n        $path[] = $grid[1][0];\n        $row = 1;\n\
    \        $col = 0;\n    }\n    for ($i = 3; $i <= $k; $i++) {\n        $path[]\
    \ = $grid[$row][$col];\n    }\n    return $path;\n}\n$grid = [\n    [1,2,3],\n\
    \    [4,5,6],\n    [7,8,", "    if (empty($grid) || empty($grid[0])) {\n     \
    \   return null;\n    }\n    $rows = count($grid);\n    $cols = count($grid[0]);\n\
    \    $visited = [];\n    $check = function($r, $c) use($rows, $cols) {\n     \
    \   return $r >= 0 && $r < $rows && $c >= 0 && $c < $cols;\n    };\n    $neighbors\
    \ = function($r, $c) use($check) {\n        $nlist = [];\n        $nlist[] = [$r\
    \ - 1, $c];\n        $nlist[] = [$r + 1, $c];\n        $nlist[] = [$r, $c - 1];\n\
    \        $nlist[] = [$r, $c + 1];\n        $res = [];\n        foreach ($nlist\
    \ as $n) {\n            if ($check($n[0], $n[1])) {\n                $res[] =\
    \ $n;\n            }\n        }\n        return $res;\n    };\n    $start = [$rows\
    \ - 1, $cols - 1];\n    $queue = new SplQueue();\n    $queue->enqueue($start);\n\
    \    $visited[$start[0]][$start[1]] = true;\n    $ans = [];\n    $ans[] = $grid[$start[0]][$start[1]];\n\
    \    $count = 0;\n    while (!$queue->isEmpty()) {\n        $count++;\n      \
    \  if ($count > $k) {\n            break;\n        }\n        $size = $queue->count();\n\
    \        for ($i = 0; $i < $size; $i++) {\n            $cur = $queue->dequeue();\n\
    \            $nlist = $neighbors($cur[0], $cur[1]);\n            foreach ($nlist\
    \ as $n) {\n                if (isset($visited[$n[0]][$n[1]])) {\n           \
    \         continue;\n                }\n                $visited[$n[0]][$n[1]]\
    \ = true;\n                $queue->enqueue($n);\n                $ans[] =", " \
    \   // Write your code here\n}", "    $start = [0, 0];\n    $m = count($grid);\n\
    \    $n = count($grid[0]);\n    $steps = [];\n    $path = [];\n    $visited =\
    \ [];\n    for ($i = 0; $i < $m; $i++) {\n        $visited[$i] = [];\n       \
    \ for ($j = 0; $j < $n; $j++) {\n            $visited[$i][$j] = false;\n     \
    \   }\n    }\n    $q = new SplQueue();\n    $q->enqueue($start);\n    $visited[$start[0]][$start[1]]\
    \ = true;\n    $steps[$start[0]][$start[1]] = 0;\n    $path[$start[0]][$start[1]]\
    \ = [];\n    while (!$q->isEmpty()) {\n        $t = $q->dequeue();\n        $step\
    \ = $steps[$t[0]][$t[1]];\n        if ($step === $k) {\n            return $path[$t[0]][$t[1]];\n\
    \        }\n        $curPath = $path[$t[0]][$t[1]];\n        $curPath[] = $grid[$t[0]][$t[1]];\n\
    \        $dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]];\n        foreach ($dirs as\
    \ $dir) {\n            $newX = $t[0] + $dir[0];\n            $newY = $t[1] + $dir[1];\n\
    \            if ($newX >= 0 && $newX < $m && $newY >= 0 && $newY < $n &&\n   \
    \             !$visited[$newX][$newY]) {\n                $visited[$newX][$newY]\
    \ = true;\n                $steps[$newX][$newY] = $step + 1;\n               \
    \ $path[$newX][$newY] = $curPath;\n                $q->enqueue([$newX, $newY]);\n\
    \            }\n        }\n    }\n    return [];\n", "    $n = count($grid);\n\
    \    $range = range(1, $n * $n);\n    $cnt = [];\n    foreach ($range as $num)\
    \ {\n        $cnt[$num] = 0;\n    }\n    for ($i = 0; $i < $n; $i++) {\n     \
    \   for ($j = 0; $j < $n; $j++) {\n            $cnt[$grid[$i][$j]]++;\n      \
    \  }\n    }\n    foreach ($range as $num) {\n        if ($cnt[$num] == 0) {\n\
    \            return [];\n        }\n    }\n    for ($i = 0; $i < $n; $i++) {\n\
    \        for ($j = 0; $j < $n; $j++) {\n            $cnt[$grid[$i][$j]]--;\n \
    \           if ($cnt[$grid[$i][$j]] == 0) {\n                unset($cnt[$grid[$i][$j]]);\n\
    \            }\n            $res = helper($grid, $cnt, $i, $j, $k);\n        \
    \    if (!empty($res)) {\n                return $res;\n            }\n      \
    \      $cnt[$grid[$i][$j]]++;\n        }\n    }\n    return [];\n}", "    // dp[i][j][p]\
    \ = min cost to reach (i, j) in p steps, p = 1 ... k\n    // dp[i][j][p] = min(dp[i\
    \ - 1][j][p - 1], dp[i + 1][j][p - 1],\n    //                   dp[i][j - 1][p\
    \ - 1], dp[i][j + 1][p - 1]) + grid[i][j]\n    // dp[i][j][p] = INF if it's impossible\
    \ to reach (i, j) in p steps.\n    //\n    // Time: O(n^2 * k)\n    // Space:\
    \ O(n^2 * k)\n    $n = count($grid);\n    $dp = array_fill(0, $n, array_fill(0,\
    \ $n, array_fill(0, $k + 1, INF)));\n    for ($i = 0; $i < $n; $i++) {\n     \
    \   for ($j = 0; $j < $n; $j++) {\n            if ($i > 0) {\n               \
    \ $dp[$i][$j][1] = min($dp[$i][$j][1], $dp[$i - 1][$j][1] + $grid[$i][$j]);\n\
    \            }\n            if ($i < $n - 1) {\n                $dp[$i][$j][1]\
    \ = min($dp[$i][$j][1], $dp[$i + 1][$j][1] + $grid[$i][$j]);\n            }\n\
    \            if ($j > 0) {\n                $dp[$i][$j][1] = min($dp[$i][$j][1],\
    \ $dp[$i][$j - 1][1] + $grid[$i][$j]);\n            }\n            if ($j < $n\
    \ - 1) {\n                $dp[$i][$j][1] = min($dp[$i][$j][1], $dp[$i][$j + 1][1]\
    \ + $grid[$i][$j]);\n            }\n        }\n    }\n    for ($p = 2;", "   \
    \ $seen = [];\n    $q = new SplQueue();\n    $n = count($grid);\n    $q->enqueue([0,\
    \ 0, $grid[0][0], $k]);\n    while (!$q->isEmpty()) {\n        [$i, $j, $pathSum,\
    \ $k] = $q->dequeue();\n        $pathSum .= \" $grid[$i][$j]\";\n        if ($k\
    \ == 1) {\n            $seen[] = $pathSum;\n        }\n        $k--;\n       \
    \ if ($i > 0) {\n            $q->enqueue([$i - 1, $j, $pathSum, $k]);\n      \
    \  }\n        if ($i < $n - 1) {\n            $q->enqueue([$i + 1, $j, $pathSum,\
    \ $k]);\n        }\n        if ($j > 0) {\n            $q->enqueue([$i, $j - 1,\
    \ $pathSum, $k]);\n        }\n        if ($j < $n - 1) {\n            $q->enqueue([$i,\
    \ $j + 1, $pathSum, $k]);\n        }\n    }\n    usort($seen, function ($a, $b)\
    \ {\n        return strnatcmp($a, $b);\n    });\n    return explode(\" \", $seen[0]);\n\
    }\n\n$grid = [ [1,2,3], [4,5,6], [7,8,9]];\n$k = 3;\nprint_r(minPath($grid, $k));\n\
    \n$grid = [ [5,9,3], [4,1,6], [7,8,2]];\n$k = 1;\nprint_r(minPath($grid, $k));",
  "    $m = count($grid);\n    $n = count($grid[0]);\n    $visited = array_fill(0,\
    \ $m, array_fill(0, $n, false));\n    $q = new SplQueue();\n    $q->enqueue([0,\
    \ 0, $grid[0][0], [$grid[0][0]]]);\n    $visited[0][0] = true;\n    $path = NULL;\n\
    \    while (!$q->isEmpty()) {\n        $cur = $q->dequeue();\n        list($i,\
    \ $j, $curSum, $curPath) = $cur;\n        if (count($curPath) > $k) {\n      \
    \      continue;\n        }\n        if (count($curPath) == $k) {\n          \
    \  if ($path == NULL || comparePath($curPath, $path) < 0) {\n                $path\
    \ = $curPath;\n            }\n            continue;\n        }\n        // move\
    \ down\n        if ($i + 1 < $m && !$visited[$i + 1][$j]) {\n            $visited[$i\
    \ + 1][$j] = true;\n            $q->enqueue([$i + 1, $j, $curSum + $grid[$i +\
    \ 1][$j],\n                array_merge($curPath, [$grid[$i + 1][$j]])]);\n   \
    \     }\n        // move right\n        if ($j + 1 < $n && !$visited[$i][$j +\
    \ 1]) {\n            $visited[$i][$j + 1] = true;\n            $q->enqueue([$i,\
    \ $j + 1, $curSum + $grid[$i][$j + 1],\n                array_merge($curPath,\
    \ [$grid[$i][$j + 1]])]);\n        }\n    }\n    return $path;\n}", "    if ($k\
    \ == 0) {\n        return [];\n    }\n    $n = count($grid);\n    $start = [];\n\
    \    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n  \
    \          if ($grid[$i][$j] == 1) {\n                $start = [$i, $j];\n   \
    \             break 2;\n            }\n        }\n    }\n    return bfs($grid,\
    \ $start, $k);\n}", "    $m = count($grid);\n    $n = count($grid[0]);\n    $result\
    \ = [];\n    $minPath = [];\n    for ($i = 0; $i < $m; $i++) {\n        for ($j\
    \ = 0; $j < $n; $j++) {\n            $minPath[$i][$j] = [PHP_INT_MAX, []] ;\n\
    \        }\n    }\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            if ($minPath[$i][$j][0] >= $k) {\n              \
    \  $result = dfs($grid, $i, $j, $k, $m, $n, $minPath, $result);\n            }\n\
    \        }\n    }\n    return $result;\n}", "    $result = [];\n    if ($k ==\
    \ 0) {\n        return $result;\n    }\n    $row = count($grid);\n    $col = count($grid[0]);\n\
    \    $step = 0;\n    $rowIndex = 0;\n    $colIndex = 0;\n    $dir = 0;\n    $dirs\
    \ = [\n        [0, 1],\n        [1, 0],\n        [0, -1],\n        [-1, 0]\n \
    \   ];\n    $path = [];\n    $minPath = PHP_INT_MAX;\n    $visited = [];\n   \
    \ for ($i = 0; $i < $row; $i++) {\n        $visited[$i] = [];\n        for ($j\
    \ = 0; $j < $col; $j++) {\n            $visited[$i][$j] = false;\n        }\n\
    \    }\n    $dirs = array_reverse($dirs);\n    while ($step >= 0) {\n        $visited[$rowIndex][$colIndex]\
    \ = true;\n        array_push($path, $grid[$rowIndex][$colIndex]);\n        $step++;\n\
    \        if ($step == $k) {\n            if ($path < $minPath) {\n           \
    \     $minPath = $path;\n            }\n            $path = [];\n            $step\
    \ = 0;\n            $dir = 0;\n            $rowIndex = 0;\n            $colIndex\
    \ = 0;\n            $visited = [];\n            for ($i = 0; $i < $row; $i++)\
    \ {\n                $visited[$i] = [];\n                for ($j = 0; $j < $col;\
    \ $j++) {\n                    $visited[$i][$j] = false;\n                }\n\
    \            }\n            $dirs = array_reverse($dirs);\n            continue;\n\
    \        }\n        $nextRow = $rowIndex + $dirs[$dir][0];\n        $nextCol =\
    \ $colIndex + $dirs[$dir][1];\n        if ($nextRow < 0 || $nextRow >= $row ||\
    \ $nextCol < 0 || $nextCol >= $col || $visited[$nextRow][$nextCol])", "  $minPath\
    \ = [];\n  $hash = [];\n  $n = count($grid);\n  for ($i = 0; $i < $n; $i++) {\n\
    \    for ($j = 0; $j < $n; $j++) {\n      $hash[$grid[$i][$j]] = [$i, $j];\n \
    \   }\n  }\n  $comparator = function($a, $b) use ($grid) {\n    if ($a === $b)\
    \ {\n      return 0;\n    }\n    $ai = $a[0];\n    $aj = $a[1];\n    $bi = $b[0];\n\
    \    $bj = $b[1];\n    if ($grid[$ai][$aj] === $grid[$bi][$bj]) {\n      return\
    \ 0;\n    }\n    return $grid[$ai][$aj] < $grid[$bi][$bj] ? -1 : 1;\n  };\n  $visited\
    \ = array_fill(0, $n, array_fill(0, $n, 0));\n  $queue = new \\Ds\\PriorityQueue();\n\
    \  $queue->push([1, $hash[1]], 1);\n  while ($queue->count() > 0) {\n    list($num,\
    \ $cell) = $queue->pop();\n    if ($num === $k) {\n      $result = $minPath;\n\
    \      return $result;\n    }\n    $i = $cell[0];\n    $j = $cell[1];\n    if\
    \ ($i - 1 >= 0 && $visited[$i - 1][$j] === 0) {\n      $visited[$i - 1][$j] =\
    \ 1;\n      $queue->push([$num + 1, [$i - 1, $j]], $num + 1);\n      $minPath[]\
    \ = $grid[$i - 1][$j];\n    }\n    if ($i + 1 < $n && $visited[$i + 1][$j] ===\
    \ 0) {\n      $visited[$i + 1][$j] = 1;\n      $queue->push([$num + 1, [$i + 1,\
    \ $j]", "    $size = count($grid);\n    $path = [$grid[0][0]];\n    $i = 0;\n\
    \    $j = 0;\n    for ($m = 1; $m < $k; $m++) {\n        $up = ($i > 0) ? $grid[$i\
    \ - 1][$j] : PHP_INT_MAX;\n        $down = ($i < $size - 1) ? $grid[$i + 1][$j]\
    \ : PHP_INT_MAX;\n        $left = ($j > 0) ? $grid[$i][$j - 1] : PHP_INT_MAX;\n\
    \        $right = ($j < $size - 1) ? $grid[$i][$j + 1] : PHP_INT_MAX;\n      \
    \  $min = min($up, $down, $left, $right);\n        if ($min == $up) {\n      \
    \      $i--;\n        } elseif ($min == $down) {\n            $i++;\n        }\
    \ elseif ($min == $left) {\n            $j--;\n        } else {\n            $j++;\n\
    \        }\n        $path[] = $min;\n    }\n    return $path;\n}\n\n$grid = [\n\
    \    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n$k = 3;\n$result = minPath($grid,\
    \ $k);\nprint_r($result);\necho PHP_EOL;\n$grid = [\n    [5, 9, 3],\n    [4, 1,\
    \ 6],\n    [7, 8, 2]\n];\n$k = 1;\n$result = minPath($grid, $k);\nprint_r($result);\n\
    echo PHP_EOL;", "    // if k is 0 return empty array\n    if ($k == 0) {\n   \
    \     return [];\n    }\n    // if k is 1 return grid[0][0]\n    if ($k == 1)\
    \ {\n        return [$grid[0][0]];\n    }\n    // if k is less than grid length\
    \ return min path\n    if ($k < sizeof($grid)) {\n        $path = [$grid[0][0]];\n\
    \        $min = $grid[0][0];\n        for ($i = 1; $i < $k; $i++) {\n        \
    \    for ($j = 0; $j < $k; $j++) {\n                if ($grid[$i][$j] < $min)\
    \ {\n                    $min = $grid[$i][$j];\n                    $path[] =\
    \ $min;\n                }\n            }\n        }\n        return $path;\n\
    \    }\n    // if k is grid size return min path\n    if ($k == sizeof($grid))\
    \ {\n        $path = [$grid[0][0]];\n        $min = $grid[0][0];\n        for\
    \ ($i = 1; $i < $k; $i++) {\n            for ($j = 0; $j < $k; $j++) {\n     \
    \           if ($grid[$i][$j] < $min) {\n                    $min = $grid[$i][$j];\n\
    \                    $path[] = $min;\n                }\n            }\n     \
    \   }\n        return $path;\n    }\n    // if k is greater than grid size return\
    \ min path\n    if ($k > sizeof($grid)) {\n        $path = [$grid[0][0]];\n  \
    \      $min = $grid[0][0];\n        for ($i = 1; $i < $k; $i++) {\n          \
    \  for ($j = 0; $j < $k; $j++) {\n                if ($grid[$i][$j] < $min) {\n\
    \                    $min = $grid[$i][$j];\n                    $path[] = $min;\n\
    \                }\n            }\n        }\n        return $path;\n    }\n}\n\
    $grid = [ [1,2,3], [4,5", "    $n = count($grid);\n    $min = [];\n    for ($r\
    \ = 0; $r < $n; $r++) {\n        for ($c = 0; $c < $n; $c++) {\n            $min\
    \ = getPath($grid, $r, $c, $k, $n, [], $min);\n        }\n    }\n    return $min;\n\
    }", "    $dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    $rows = count($grid);\n\
    \    $cols = count($grid[0]);\n    $len = $rows * $cols;\n    $visited = array_fill(0,\
    \ $len, false);\n    $que = new SplPriorityQueue();\n    $x0 = $y0 = 0;\n    while\
    \ ($grid[$x0][$y0] != 1) {\n        ++$x0;\n    }\n    $que->insert([[$x0, $y0],\
    \ [1]], 0);\n    $visited[$x0 * $cols + $y0] = true;\n    while (!$que->isEmpty())\
    \ {\n        $cur = $que->extract();\n        $curPath = $cur[0];\n        $curVal\
    \ = $cur[1];\n        $x = $curPath[0][0];\n        $y = $curPath[0][1];\n   \
    \     if (count($curPath) == $k) {\n            return $curVal;\n        }\n \
    \       for ($i = 0; $i < 4; ++$i) {\n            $nextX = $x + $dirs[$i][0];\n\
    \            $nextY = $y + $dirs[$i][1];\n            if ($nextX >= 0 && $nextX\
    \ < $rows && $nextY >= 0 && $nextY < $cols && !$visited[$nextX * $cols + $nextY])\
    \ {\n                $visited[$nextX * $cols + $nextY] = true;\n             \
    \   $nextPath = $curPath;\n                $nextPath[] = [$nextX, $nextY];\n \
    \               $nextVal = $curVal;\n                $nextVal[] = $grid[$nextX][$nextY];\n\
    \                $que->insert([$nextPath, $nextVal], -1 * array_sum($nextVal));\n\
    \            }\n        }\n    }\n    return [];\n}\n$grid = [ [1,2,3], [4,5,6],\
    \ [7,8,9]];\n", "    $n = count($grid);\n    $values = [];\n    for ($i = 0; $i\
    \ < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            $values[$grid[$i][$j]]\
    \ = [$i, $j];\n        }\n    }\n    $curr = [0, 0];\n    $result = [];\n    $result[]\
    \ = $grid[0][0];\n    while ($k > 1) {\n        $next = move($grid, $values, $curr);\n\
    \        $result[] = $grid[$next[0]][$next[1]];\n        $curr = $next;\n    \
    \    $k--;\n    }\n    return $result;\n}", "  $i = 0;\n  $j = 0;\n  $len = count($grid);\n\
    \  $visited = [];\n  while (count($visited) < $k) {\n    $visited[] = $grid[$i][$j];\n\
    \    if ($i + 1 < $len && $grid[$i + 1][$j] < $grid[$i][$j]) {\n      $i++;\n\
    \    } else if ($j + 1 < $len && $grid[$i][$j + 1] < $grid[$i][$j]) {\n      $j++;\n\
    \    } else if ($i - 1 >= 0 && $grid[$i - 1][$j] < $grid[$i][$j]) {\n      $i--;\n\
    \    } else if ($j - 1 >= 0 && $grid[$i][$j - 1] < $grid[$i][$j]) {\n      $j--;\n\
    \    }\n  }\n  return $visited;\n}\n$grid = [\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n\
    ];\n$k = 3;\nvar_dump(minPath($grid, $k));\n$grid = [\n  [5,9,3],\n  [4,1,6],\n\
    \  [7,8,2]\n];\n$k = 1;\nvar_dump(minPath($grid, $k));", "    $m = count($grid);\n\
    \    $n = count($grid[0]);\n    $dp = array_fill(0, $m, array_fill(0, $n, PHP_INT_MAX));\n\
    \    $visited = array_fill(0, $m, array_fill(0, $n, false));\n    $res = [];\n\
    \    dfs($grid, $m, $n, 0, 0, 0, $k, $res, $dp, $visited);\n    return $res;\n\
    }", "    if ($k <= 0) {\n        return [];\n    }\n    $n = count($grid);\n \
    \   $visited = array_fill(0, $n, array_fill(0, $n, false));\n    $minLen = PHP_INT_MAX;\n\
    \    $minVisited = [];\n    $minLenPath = [];\n    // DFS\n    for ($i = 0; $i\
    \ < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            DFS($grid,\
    \ $i, $j, $k, $visited, $minLen, $minVisited, $minLenPath);\n        }\n    }\n\
    \    return $minLenPath;\n}\n", "    if (empty($grid) || empty($grid[0])) {\n\
    \        return [];\n    }\n    $n = count($grid);\n    $start = [0, 0];\n   \
    \ $min = null;\n    $minPath = [];\n    $path = [];\n    dfs($grid, $n, $k, $start,\
    \ $min, $minPath, $path);\n    return $minPath;\n}", "    $n = count($grid);\n\
    \    $dist = new SplMaxHeap();\n    $dist->insert([$grid[0][0], 0, 0]);\n    $visited\
    \ = [];\n    $visited[0][0] = 1;\n    $result = [];\n    while (!$dist->isEmpty())\
    \ {\n        list($currVal, $currRow, $currCol) = $dist->extract();\n        if\
    \ (count($result) == $k) {\n            break;\n        }\n        array_push($result,\
    \ $currVal);\n        if ($currRow > 0 && $visited[$currRow - 1][$currCol] ==\
    \ 0) {\n            $dist->insert([$grid[$currRow - 1][$currCol], $currRow - 1,\
    \ $currCol]);\n            $visited[$currRow - 1][$currCol] = 1;\n        }\n\
    \        if ($currRow < $n - 1 && $visited[$currRow + 1][$currCol] == 0) {\n \
    \           $dist->insert([$grid[$currRow + 1][$currCol], $currRow + 1, $currCol]);\n\
    \            $visited[$currRow + 1][$currCol] = 1;\n        }\n        if ($currCol\
    \ > 0 && $visited[$currRow][$currCol - 1] == 0) {\n            $dist->insert([$grid[$currRow][$currCol\
    \ - 1], $currRow, $currCol - 1]);\n            $visited[$currRow][$currCol - 1]\
    \ = 1;\n        }\n        if ($currCol < $n - 1 && $visited[$currRow][$currCol\
    \ + 1] == 0) {\n            $dist->insert([$grid[$currRow][$currCol + 1], $currRow,\
    \ $currCol + 1]);\n            $visited[$currRow][$currCol + 1] = 1;\n       \
    \ }\n    }\n    return $result;\n}", "    $n = count($grid);\n    if ($n == 0)\
    \ {\n        return [];\n    }\n    $m = count($grid[0]);\n    $visited = [];\n\
    \    for ($i = 0; $i < $n; $i++) {\n        $visited[] = array_fill(0, $m, 0);\n\
    \    }\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++)\
    \ {\n            $visited[$i][$j] = -1;\n        }\n    }\n    $queue = [];\n\
    \    $queue[] = [0, 0, 0, $grid[0][0]];\n    $visited[0][0] = 0;\n    $min_path\
    \ = [];\n    $min_sum = PHP_INT_MAX;\n    while (!empty($queue)) {\n        $size\
    \ = count($queue);\n        for ($i = 0; $i < $size; $i++) {\n            $item\
    \ = $queue[$i];\n            $sum = $item[3];\n            $path = $item[2];\n\
    \            $pos = $item[1];\n            $cur = $item[0];\n            if ($path\
    \ == $k) {\n                if ($sum < $min_sum) {\n                    $min_sum\
    \ = $sum;\n                    $min_path = [];\n                    for ($j =\
    \ 0; $j < $n; $j++) {\n                        $min_path[] = [];\n           \
    \             for ($l = 0; $l < $m; $l++) {\n                            $min_path[$j][]\
    \ = -1;\n                        }\n                    }\n                  \
    \  $min_path[0][0] = $grid[0][0];\n                    while ($cur != -1) {\n\
    \                        list($row, $col) = $cur;\n                        $min_path[$row][$col]\
    \ = $grid[$row][$col];\n                        $cur = $visited[$row][$col];\n\
    \                    }\n                }\n                continue;\n       \
    \     }\n            if ($sum >= $min_sum) {\n                continue;\n    \
    \        }\n            list($row", "  $n = count($grid);\n  $m = count($grid[0]);\n\
    \  $cellValues = [];\n  $minPaths = [];\n  $minPaths[0] = [];\n  for ($i = 0;\
    \ $i < $n; $i++) {\n    for ($j = 0; $j < $m; $j++) {\n      $cellValues[$grid[$i][$j]]\
    \ = [$i, $j];\n    }\n  }\n  $minPaths[0][$grid[0][0]] = [0, 0];\n  for ($i =\
    \ 1; $i <= $k; $i++) {\n    $minPaths[$i] = [];\n    for ($j = 1; $j <= $n * $m;\
    \ $j++) {\n      $minPaths[$i][$j] = null;\n    }\n  }\n  for ($i = 1; $i <= $k;\
    \ $i++) {\n    for ($j = 1; $j <= $n * $m; $j++) {\n      list($x, $y) = $cellValues[$j];\n\
    \      $minPaths[$i][$j] = $minPaths[$i - 1][$j];\n      if ($x > 0 && $y > 0)\
    \ {\n        if ($minPaths[$i][$j] === null || $minPaths[$i - 1][$grid[$x - 1][$y\
    \ - 1]] < $minPaths[$i][$j]) {\n          $minPaths[$i][$j] = $minPaths[$i - 1][$grid[$x\
    \ - 1][$y - 1]];\n        }\n      }\n      if ($x > 0) {\n        if ($minPaths[$i][$j]\
    \ === null || $minPaths[$i - 1][$grid[$x - 1][$y]] < $minPaths[$i][$j]) {\n  \
    \        $minPaths[$i][$j] = $minPaths[$i - 1][$grid[$x - 1][$y]];\n        }\n\
    \      }\n      if ($y > 0) {\n", "    if ($k <= 0) {\n        return [];\n  \
    \  }\n    if ($k === 1) {\n        return [1];\n    }\n    $n = count($grid);\n\
    \    $path = array_fill(0, $k, 0);\n    $seen = [];\n    $min = [0];\n    // use\
    \ dfs to find the min path\n    dfs($grid, $n, $seen, $path, $min, $k, 0, 0, 0);\n\
    \    return $min;\n}", "    $m = count($grid);\n    $n = count($grid[0]);\n  \
    \  $min = null;\n    $path = null;\n    $solutions = [];\n    // we make sure\
    \ that at least one out of the 4 directions is valid\n    $x = 0;\n    $y = 0;\n\
    \    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n  \
    \          $left = $j > 0;\n            $right = $j < $n - 1;\n            $up\
    \ = $i > 0;\n            $down = $i < $m - 1;\n            if ($left || $right\
    \ || $up || $down) {\n                $solutions[$i][$j] = true;\n           \
    \ }\n        }\n    }\n    $solutions[$x][$y] = false;\n    $visited = array_fill(0,\
    \ $m, array_fill(0, $n, false));\n    $res = minPathHelper($grid, $x, $y, $k,\
    \ $visited, $solutions, $min, $path);\n    return $res;\n}", "    // dp[i][j][k]\
    \ means shortest path with length k with starting point grid[i][j]\n    $n = count($grid);\n\
    \    $dp = [];\n    $directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n         \
    \   for ($p = 0; $p < $k; $p++) {\n                $dp[$i][$j][$p] = PHP_INT_MAX;\n\
    \            }\n        }\n    }\n    for ($i = 0; $i < $n; $i++) {\n        for\
    \ ($j = 0; $j < $n; $j++) {\n            $dp[$i][$j][0] = $grid[$i][$j];\n   \
    \     }\n    }\n    for ($t = 1; $t < $k; $t++) {\n        for ($i = 0; $i < $n;\
    \ $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                for ($d\
    \ = 0; $d < 4; $d++) {\n                    $x = $i + $directions[$d][0];\n  \
    \                  $y = $j + $directions[$d][1];\n                    if ($x >=\
    \ 0 && $x < $n && $y >= 0 && $y < $n) {\n                        $dp[$i][$j][$t]\
    \ = min($dp[$i][$j][$t], $dp[$x][$y][$t - 1]);\n                    }\n      \
    \          }\n            }\n        }\n    }\n    $res = [];\n    $res[] = $dp[0][0][$k\
    \ - 1];\n    for ($t = $k - 2; $t >= 0; $t--) {\n        for ($d = 0; $d < 4;\
    \ $d++) {\n            $x = $i + $directions[$d][0];\n            $y = $j + $directions[$d][1];\n\
    \            if ($x >= 0 && $", "    // write your code here.\n    $n = count($grid);\n\
    \    $minPath = [];\n    $visited = array_fill(0, $n, array_fill(0, $n, false));\n\
    \    $visited[0][0] = true;\n    $minPath[] = $grid[0][0];\n    $minPath = DFS($grid,\
    \ $visited, $minPath, 0, 0, $k, 1);\n    return $minPath;\n}\n", "  $N = count($grid);\n\
    \  if ($k < $N || $k > $N * $N) return [];\n  $visited = array_fill(0, $N, array_fill(0,\
    \ $N, false));\n  $ans = [];\n  $prev = [];\n  for ($i = 0; $i < $N; $i++) {\n\
    \    for ($j = 0; $j < $N; $j++) {\n      $ans[$i][$j] = [PHP_INT_MAX, null];\n\
    \    }\n  }\n  $ans[0][0] = [0, [0, 0]];\n  $q = new SplPriorityQueue();\n  $q->insert([0,\
    \ [0, 0]], $grid[0][0]);\n  while (!$q->isEmpty()) {\n    $t = $q->extract();\n\
    \    $cnt = $t[0];\n    $row = $t[1][0];\n    $col = $t[1][1];\n    if ($visited[$row][$col])\
    \ continue;\n    $visited[$row][$col] = true;\n    $prev[$row][$col] = $ans[$row][$col][1];\n\
    \    if ($cnt === $k) break;\n    $d = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n \
    \   for ($i = 0; $i < 4; $i++) {\n      $x = $row + $d[$i][0];\n      $y = $col\
    \ + $d[$i][1];\n      if ($x < 0 || $x >= $N || $y < 0 || $y >= $N) continue;\n\
    \      if ($visited[$x][$y]) continue;\n      $nxtCnt = $cnt + 1;\n      $nxtVal\
    \ = $grid[$x][$y];\n      if ($nxtCnt < $ans[$x][$y][0] || ($nxtCnt === $ans[$x][$y][0]\
    \ && $nxtVal < $grid[$ans[$x][$y][1][", "    $lowest = null;\n    $lowestList\
    \ = [];\n    $queue = new SplQueue();\n    $queue->enqueue([0, 0, [$grid[0][0]]]);\n\
    \    $m = count($grid);\n    $n = count($grid[0]);\n    $visited = array_fill(0,\
    \ $m, array_fill(0, $n, false));\n    $visited[0][0] = true;\n    while (!$queue->isEmpty())\
    \ {\n        list($x, $y, $path) = $queue->dequeue();\n        if (count($path)\
    \ === $k) {\n            $num = implode($path);\n            if ($lowest === null\
    \ || $num < $lowest) {\n                $lowest = $num;\n                $lowestList\
    \ = $path;\n            }\n            continue;\n        }\n        $adj = [\n\
    \            [$x + 1, $y],\n            [$x - 1, $y],\n            [$x, $y + 1],\n\
    \            [$x, $y - 1],\n        ];\n        foreach ($adj as list($a, $b))\
    \ {\n            if ($a < 0 || $a >= $m || $b < 0 || $b >= $n || $visited[$a][$b])\
    \ {\n                continue;\n            }\n            $visited[$a][$b] =\
    \ true;\n            $queue->enqueue([$a, $b, array_merge($path, [$grid[$a][$b]])]);\n\
    \        }\n    }\n    return $lowestList;\n}", "    $minPath = [];\n    $r =\
    \ count($grid);\n    $c = count($grid[0]);\n    $min = PHP_INT_MAX;\n    $pos\
    \ = [];\n    for ($i = 0; $i < $r; $i++) {\n        for ($j = 0; $j < $c; $j++)\
    \ {\n            $pos[$grid[$i][$j]] = [$i, $j];\n        }\n    }\n    for ($start\
    \ = 1; $start <= $r * $c; $start++) {\n        $curr = [$start];\n        $currPath\
    \ = [$start];\n        $min = PHP_INT_MAX;\n        $minPath = [];\n        dfs($grid,\
    \ $curr, $min, $minPath, $pos, $k, $currPath);\n        // echo implode(',', $minPath),\
    \ \"\\n\";\n        if ($min == $k) {\n            break;\n        }\n    }\n\
    \    return $minPath;\n}", "    $gridLen = count($grid);\n    $start = $grid[0][0];\n\
    \    $path = [$start];\n    $minPath = $path;\n    $minPathLen = $k;\n    $neighbors\
    \ = getNeighbors($grid, $gridLen, $start);\n    return minPath2($grid, $gridLen,\
    \ $path, $minPath, $minPathLen, $k, $neighbors);\n}", "    $n = count($grid);\n\
    \    $dp = array_fill(0, $n, array_fill(0, $n, null));\n    $min_path = array_fill(0,\
    \ $k, null);\n    $min_path_value = null;\n    $heap = new SplMinHeap();\n   \
    \ $heap->insert([0, 0, 1, [$grid[0][0]]]);\n    while (!$heap->isEmpty()) {\n\
    \        $tuple = $heap->extract();\n        list($path_length, $i, $j, $path)\
    \ = $tuple;\n        if ($i == $n - 1 && $j == $n - 1) {\n            $last_value\
    \ = end($path);\n            if ($min_path_value === null || $last_value < $min_path_value)\
    \ {\n                $min_path_value = $last_value;\n                $min_path\
    \ = $path;\n            }\n            continue;\n        }\n        if ($path_length\
    \ + 1 == $k) {\n            continue;\n        }\n        if ($i > 0 && ($dp[$i\
    \ - 1][$j] === null || $dp[$i - 1][$j] > $path_length + 1)) {\n            $path_copy\
    \ = $path;\n            $path_copy[] = $grid[$i - 1][$j];\n            $heap->insert([$path_length\
    \ + 1, $i - 1, $j, $path_copy]);\n            $dp[$i - 1][$j] = $path_length +\
    \ 1;\n        }\n        if ($i < $n - 1 && ($dp[$i + 1][$j] === null || $dp[$i\
    \ + 1][$j] > $path_length + 1)) {\n            $path_copy = $path;\n         \
    \   $path_copy[] = $grid[$i + 1][$j];\n            $heap->insert([$path_length\
    \ + 1, $i + 1, $j, $path_copy]);\n            $dp[$i + 1][$j] = $path_length +\
    \ 1;\n        }\n        if ($j > 0", "    if ($k == 0) {\n        return [0];\n\
    \    }\n    $map = [];\n    $m = count($grid);\n    $n = count($grid[0]);\n  \
    \  $q = new SplQueue();\n    $visited = [];\n    $q->enqueue([0, 0, 0]);\n   \
    \ $map[0][0] = $grid[0][0];\n    $visited[0][0] = true;\n    while (!$q->isEmpty())\
    \ {\n        $cur = $q->dequeue();\n        if ($cur[2] == $k - 1) {\n       \
    \     return toPath($map, $k);\n        }\n        $i = $cur[0];\n        $j =\
    \ $cur[1];\n        if ($i - 1 >= 0 && !$visited[$i - 1][$j]) {\n            $q->enqueue([$i\
    \ - 1, $j, $cur[2] + 1]);\n            $map[$i - 1][$j] = $grid[$i - 1][$j];\n\
    \            $visited[$i - 1][$j] = true;\n        }\n        if ($i + 1 < $m\
    \ && !$visited[$i + 1][$j]) {\n            $q->enqueue([$i + 1, $j, $cur[2] +\
    \ 1]);\n            $map[$i + 1][$j] = $grid[$i + 1][$j];\n            $visited[$i\
    \ + 1][$j] = true;\n        }\n        if ($j - 1 >= 0 && !$visited[$i][$j - 1])\
    \ {\n            $q->enqueue([$i, $j - 1, $cur[2] + 1]);\n            $map[$i][$j\
    \ - 1] = $grid[$i][$j - 1];\n            $visited[$i][$j - 1] = true;\n      \
    \  }\n        if ($j + 1 < $n && !$visited[$i][$j + 1]) {\n            $q->enqueue([$i,\
    \ $j + 1, $cur[2] + 1]);\n            $map[$i][", "    // edge cases\n    if ($k\
    \ == 0) {\n        return [];\n    }\n    $n = count($grid);\n    if ($n == 0)\
    \ {\n        return [];\n    }\n    if ($k < $n) {\n        return [$grid[0][0]];\n\
    \    }\n    $visited = [];\n    for ($i = 0; $i < $n; $i++) {\n        $visited[]\
    \ = array_fill(0, $n, false);\n    }\n    $visited[0][0] = true;\n    $res = [$grid[0][0]];\n\
    \    $i = 0;\n    $j = 0;\n    $p = 1;\n    while ($p < $k) {\n        $top =\
    \ $i - 1;\n        $bottom = $i + 1;\n        $left = $j - 1;\n        $right\
    \ = $j + 1;\n        $next = [];\n        if ($top >= 0 && !$visited[$top][$j])\
    \ {\n            $next[] = [$top, $j];\n        }\n        if ($bottom < $n &&\
    \ !$visited[$bottom][$j]) {\n            $next[] = [$bottom, $j];\n        }\n\
    \        if ($left >= 0 && !$visited[$i][$left]) {\n            $next[] = [$i,\
    \ $left];\n        }\n        if ($right < $n && !$visited[$i][$right]) {\n  \
    \          $next[] = [$i, $right];\n        }\n        if (empty($next)) {\n \
    \           $res[] = $grid[$i][$j];\n            break;\n        }\n        usort($next,\
    \ function($a, $b) use ($grid) {\n            return $grid[$a[0]][$a[1]] - $grid[$b[0]][$b[1]];\n\
    \        });\n        $i = $next[0][0];\n        $j = $next[0][1];\n        $visited[$i][$j]\
    \ = true;\n        $res[] = $grid[$i][$j];\n        $p++;", "    // we create\
    \ a queue of two dimensional array, where each element is the\n    // tuple containing\
    \ the number of steps taken and the current cell. The\n    // initial element\
    \ is [0, [0, 0]].\n    $queue = [[0, [0, 0]]];\n    // we create a map of arrays\
    \ keyed by cell coordinates and values as the\n    // list of steps taken to get\
    \ to the cell.\n    $values = [];\n    $values[[0, 0]] = [$grid[0][0]];\n    //\
    \ we create a variable to hold the least steps taken so far to the\n    // current\
    \ cell, this is used to prune the search.\n    $least_step = 0;\n    // continue\
    \ while there are still unvisited cells.\n    while (!empty($queue)) {\n     \
    \   // dequeue the next cell.\n        list($steps, $cell) = array_shift($queue);\n\
    \        // get the coordinates of the cell.\n        list($i, $j) = $cell;\n\
    \        // if the current cell is off the grid, ignore it.\n        if ($i <\
    \ 0 || $i >= count($grid) || $j < 0 || $j >= count($grid)) {\n            continue;\n\
    \        }\n        // if the steps taken to the current cell is greater than\
    \ the least\n        // step taken so far to any cell then we can prune the search.\n\
    \        if ($steps > $least_step) {\n            continue;\n        }\n     \
    \   // get the list of steps taken to the current cell.\n        $val = $values[$cell];\n\
    \        // if the list of steps taken to the current cell is greater than the\n\
    \        // k steps required then we can prune the search.\n        if (count($val)\
    \ > $k) {\n            continue;\n        }\n        // if the list of steps taken\
    \ to the current cell is exactly k steps\n        // then we found a path with\
    \ k steps, check if it is the minimum\n        // path, if so update the result.\n\
    \        if (count($val) == $k) {\n            if ($steps < $least_step) {\n \
    \               $result = $val;\n                $least_step = $steps;\n     \
    \       } elseif ($steps == $le", "    $rows = count($grid);\n    $cols = count($grid[0]);\n\
    \    $dp = [];\n    $path = [];\n    $min = [PHP_INT_MAX, null];\n    for ($i\
    \ = 0; $i < $rows; $i++) {\n        for ($j = 0; $j < $cols; $j++) {\n       \
    \     for ($curK = 1; $curK <= $k; $curK++) {\n                $min[0] = PHP_INT_MAX;\n\
    \                $min[1] = null;\n                if ($i > 0) {\n            \
    \        $prev = $dp[$i - 1][$j][$curK - 1];\n                    if ($prev[0]\
    \ < $min[0]) {\n                        $min = $prev;\n                    }\n\
    \                }\n                if ($j > 0) {\n                    $prev =\
    \ $dp[$i][$j - 1][$curK - 1];\n                    if ($prev[0] < $min[0]) {\n\
    \                        $min = $prev;\n                    }\n              \
    \  }\n                $dp[$i][$j][$curK] = [\n                    $min[0] * 10\
    \ + $grid[$i][$j],\n                    $min[1] !== null ? array_merge($min[1],\
    \ [$grid[$i][$j]]) : [$grid[$i][$j]]\n                ];\n            }\n    \
    \    }\n    }\n    return $dp[$rows - 1][$cols - 1][$k][1];\n}\necho implode(',\
    \ ', minPath([[1,2,3], [4,5,6], [7,8,9]], 3)) . PHP_EOL;\necho implode(', ', minPath([[5,9,3],\
    \ [4,1,6], [7,8,2]], 1)) . PHP_EOL;", "    $rows = count($grid);\n    $cols =\
    \ count($grid[0]);\n    $memo = [];\n    for ($i = 0; $i < $rows; $i++) {\n  \
    \      for ($j = 0; $j < $cols; $j++) {\n            $memo[$i][$j] = [];\n   \
    \     }\n    }\n    $minPath = [];\n    $path = [];\n    $minSum = PHP_INT_MAX;\n\
    \    backtrack($grid, $memo, $minPath, $path, $minSum, $k, 0, 0);\n    return\
    \ $minPath;\n}", "  $n = count($grid);\n  $dist = array_fill(0, $n, array_fill(0,\
    \ $n, PHP_INT_MAX));\n  $queue = new SplPriorityQueue();\n  $queue->insert([$grid[0][0],\
    \ [0, 0]], -$grid[0][0]);\n  $dist[0][0] = $grid[0][0];\n  $directions = [[0,\
    \ 1], [0, -1], [1, 0], [-1, 0]];\n  while (!$queue->isEmpty()) {\n    list($val,\
    \ $pos) = $queue->extract();\n    list($x, $y) = $pos;\n    if ($val == PHP_INT_MAX)\
    \ {\n      return [];\n    }\n    if ($dist[$x][$y] > $k) {\n      continue;\n\
    \    }\n    if ($dist[$x][$y] == $k) {\n      return backtrace($grid, $dist, $directions,\
    \ $k, $x, $y);\n    }\n    foreach ($directions as $dir) {\n      list($dx, $dy)\
    \ = $dir;\n      $nx = $x + $dx;\n      $ny = $y + $dy;\n      if ($nx < 0 ||\
    \ $nx >= $n || $ny < 0 || $ny >= $n) {\n        continue;\n      }\n      $nv\
    \ = $val + $grid[$nx][$ny];\n      if ($nv < $dist[$nx][$ny]) {\n        $dist[$nx][$ny]\
    \ = $nv;\n        $queue->insert([$nv, [$nx, $ny]], -$nv);\n      }\n    }\n \
    \ }\n  return [];\n}", "    $paths = [];\n    $visited = [];\n    minPathHelper($grid,\
    \ 0, 0, $k, $paths, $visited);\n    $min = [];\n    foreach ($paths as $path)\
    \ {\n        if (!$min || count($path) < count($min)) {\n            $min = $path;\n\
    \        } elseif (count($path) == count($min)) {\n            for ($i = 0; $i\
    \ < count($path); $i++) {\n                if ($path[$i] < $min[$i]) {\n     \
    \               $min = $path;\n                    break;\n                } elseif\
    \ ($path[$i] > $min[$i]) {\n                    break;\n                }\n  \
    \          }\n        }\n    }\n    return $min;\n}", "    // if $k is 1, return\
    \ the min in $grid\n    if ($k == 1) {\n        $min = PHP_INT_MAX;\n        foreach\
    \ ($grid as $r) {\n            foreach ($r as $c) {\n                $min = min($min,\
    \ $c);\n            }\n        }\n        return [$min];\n    }\n    // get neighbors\
    \ and cost from each node\n    $n = count($grid);\n    $neighbors = [];\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n         \
    \   $key = \"$i:$j\";\n            $neighbors[$key] = [];\n            if ($i\
    \ > 0) {\n                $neighbors[$key][] = \"$i:\" . ($j - 1);\n         \
    \   }\n            if ($i < $n - 1) {\n                $neighbors[$key][] = \"\
    $i:\" . ($j + 1);\n            }\n            if ($j > 0) {\n                $neighbors[$key][]\
    \ = ($i - 1) . \":$j\";\n            }\n            if ($j < $n - 1) {\n     \
    \           $neighbors[$key][] = ($i + 1) . \":$j\";\n            }\n        }\n\
    \    }\n    // do topological sort\n    $indegree = [];\n    foreach ($neighbors\
    \ as $k => $v) {\n        $indegree[$k] = 0;\n    }\n    foreach ($neighbors as\
    \ $k => $v) {\n        foreach ($v as $neighbor) {\n            $indegree[$neighbor]++;\n\
    \        }\n    }\n    $next = [];\n    foreach ($indegree as $k => $v) {\n  \
    \      if ($v == 0) {\n            $next[] = $k;\n        }\n    }\n    $result\
    \ = [];\n    while (!empty($next)) {\n        $current = array_shift($next);\n\
    \        $result[] = $current;\n        foreach ($neighbors[$current] as $neighbor",
  "    $order = [];\n    $size = count($grid);\n    $visited = [];\n    for ($i =\
    \ 0; $i < $size; $i++) {\n        $visited[$i] = [];\n        for ($j = 0; $j\
    \ < $size; $j++) {\n            $visited[$i][$j] = false;\n        }\n    }\n\
    \    minPathHelper($grid, $size, $visited, 0, 0, $k, $order);\n    return $order;\n\
    }", "    $rows = count($grid);\n    $cols = count($grid[0]);\n    $getValue =\
    \ function($r, $c) use ($grid) {\n        return $grid[$r][$c];\n    };\n    $key\
    \ = function($r, $c) use ($rows, $cols) {\n        return $r * $cols + $c;\n \
    \   };\n    $neighbors = function($r, $c) use ($rows, $cols) {\n        $neighbors\
    \ = [];\n        if ($r - 1 >= 0) {\n            $neighbors[] = [$r - 1, $c];\n\
    \        }\n        if ($r + 1 < $rows) {\n            $neighbors[] = [$r + 1,\
    \ $c];\n        }\n        if ($c - 1 >= 0) {\n            $neighbors[] = [$r,\
    \ $c - 1];\n        }\n        if ($c + 1 < $cols) {\n            $neighbors[]\
    \ = [$r, $c + 1];\n        }\n        return $neighbors;\n    };\n    $isLessThan\
    \ = function($p1, $p2) use ($rows, $cols, $getValue) {\n        for ($i = 0; $i\
    \ < $rows * $cols; $i++) {\n            if ($p1[$i] !== $p2[$i]) {\n         \
    \       return $p1[$i] < $p2[$i];\n            }\n        }\n        return false;\n\
    \    };\n    $minPaths = [];\n    for ($r = 0; $r < $rows; $r++) {\n        for\
    \ ($c = 0; $c < $cols; $c++) {\n            $value = $getValue($r, $c);\n    \
    \        if (!isset($minPaths[$value])) {\n                $minPaths[$value] =\
    \ [];\n            }\n            $nbs = $neighbors($r, $c);\n            foreach\
    \ ($nbs as $nb) {\n                list($r1, $c1) = $nb;\n                $value1\
    \ = $getValue($r1, $c", "    $rows = count($grid);\n    $cols = count($grid[0]);\n\
    \    // initial max path = [1, 2, 3, ..., N^2]\n    $max = range(1, $rows * $cols);\n\
    \    $result = [];\n    // start from any cell\n    for ($i = 0; $i < $rows; $i++)\
    \ {\n        for ($j = 0; $j < $cols; $j++) {\n            // try all paths from\
    \ this cell\n            $result = findPath($grid, $i, $j, $k, $rows, $cols, $max,\
    \ []);\n        }\n    }\n    return $result;\n}", "    $map = [];\n    for ($i\
    \ = 0; $i < count($grid); $i++) {\n        for ($j = 0; $j < count($grid[$i]);\
    \ $j++) {\n            $map[$grid[$i][$j]] = [$i, $j];\n        }\n    }\n   \
    \ $minPath = [];\n    foreach ($map as $v => $rowCol) {\n        $minPath = findPath($grid,\
    \ $map, $rowCol[0], $rowCol[1], $k, [$v], $minPath);\n    }\n    return $minPath;\n\
    }", "    if ($k == 0) {\n        return [];\n    }\n    $m = count($grid);\n \
    \   $n = count($grid[0]);\n    $list = [];\n    for ($i = 0; $i < $m; $i++) {\n\
    \        for ($j = 0; $j < $n; $j++) {\n            $list[$grid[$i][$j]] = [$i,\
    \ $j];\n        }\n    }\n    // var_dump($list);\n    $dp = array_fill(0, $k,\
    \ array_fill(0, $k, 0));\n    for ($i = 1; $i < $k; $i++) {\n        $dp[$i][0]\
    \ = -1;\n        $dp[0][$i] = -1;\n    }\n    $dp[0][0] = $grid[0][0];\n    for\
    \ ($i = 1; $i < $k; $i++) {\n        list($x, $y) = $list[$dp[$i - 1][0] + 1];\n\
    \        $dp[$i][0] = $grid[$x][$y];\n        list($x, $y) = $list[$dp[0][$i -\
    \ 1] + 1];\n        $dp[0][$i] = $grid[$x][$y];\n    }\n    for ($i = 1; $i <\
    \ $k; $i++) {\n        for ($j = 1; $j < $k; $j++) {\n            list($x1, $y1)\
    \ = $list[$dp[$i - 1][$j] + 1];\n            list($x2, $y2) = $list[$dp[$i][$j\
    \ - 1] + 1];\n            if ($grid[$x1][$y1] < $grid[$x2][$y2]) {\n         \
    \       $dp[$i][$j] = $grid[$x1][$y1];\n            } else {\n               \
    \ $dp[$i][$j] = $grid[$x2][$y2];\n            }\n        }\n    }\n    $result\
    \ = [];\n    for ($i =", "    // TODO: Write your code here\n}\n", "    $n = count($grid);\n\
    \    $m = count($grid[0]);\n    $minPath = [];\n    for ($i = 0; $i < $n; $i++)\
    \ {\n        for ($j = 0; $j < $m; $j++) {\n            $idx = $grid[$i][$j];\n\
    \            $visited = [];\n            $minPath[$idx] = search($grid, $i, $j,\
    \ $k, $visited);\n        }\n    }\n    return $minPath;\n}", "    $result = [];\n\
    \    if (empty($grid) || empty($grid[0]) || count($grid) !== count($grid[0]))\
    \ {\n        return $result;\n    }\n    $n = count($grid);\n    if ($k <= 0 ||\
    \ $k > $n * $n) {\n        return $result;\n    }\n    $indexes = [];\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n         \
    \   $indexes[$grid[$i][$j]] = [$i, $j];\n        }\n    }\n    $nexts = [\n  \
    \      [-1, 0],\n        [1, 0],\n        [0, -1],\n        [0, 1]\n    ];\n \
    \   $start = [\n        $indexes[1][0],\n        $indexes[1][1]\n    ];\n    $queue\
    \ = new SplQueue();\n    $queue->enqueue($start);\n    $visited = [];\n    for\
    \ ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n         \
    \   $visited[$i][$j] = false;\n        }\n    }\n    $visited[$start[0]][$start[1]]\
    \ = true;\n    $k--;\n    while (!$queue->isEmpty()) {\n        $size = $queue->count();\n\
    \        for ($i = 0; $i < $size; $i++) {\n            $node = $queue->dequeue();\n\
    \            $row = $node[0];\n            $col = $node[1];\n            $result[]\
    \ = $grid[$row][$col];\n            if ($k === 0) {\n                return $result;\n\
    \            }\n            foreach ($nexts as $next) {\n                $r =\
    \ $row + $next[0];\n                $c = $col + $next[1];\n                if\
    \ ($r >= 0 && $r < $n && $c >= 0 && $c < $n && !$visited[$r][$c]) {\n        \
    \            $vis", "    $m = count($grid);\n    $n = count($grid[0]);\n    $minList\
    \ = [];\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++)\
    \ {\n            $list = helper($grid, $i, $j, $k, []);\n            $minList\
    \ = min_list($minList, $list);\n        }\n    }\n    return $minList;\n}", " \
    \   $minList = [];\n    $minListCount = INF;\n    $n = count($grid);\n    $m =\
    \ count($grid[0]);\n    $visited = [];\n    $curr = [1, 0, 0];\n    while (count($curr)\
    \ > 0) {\n        list($count, $row, $col) = $curr;\n        array_shift($curr);\n\
    \        if ($count > $k) {\n            continue;\n        }\n        if ($count\
    \ == $k) {\n            if ($count < $minListCount) {\n                $minListCount\
    \ = $count;\n                $minList = $visited;\n            } elseif ($count\
    \ == $minListCount) {\n                $minList = minPathCompare($minList, $visited);\n\
    \            }\n            continue;\n        }\n        if ($row - 1 >= 0 &&\
    \ !isset($visited[$row - 1][$col])) {\n            $visited[$row - 1][$col] =\
    \ 1;\n            $curr[] = [$count + 1, $row - 1, $col];\n        }\n       \
    \ if ($row + 1 < $n && !isset($visited[$row + 1][$col])) {\n            $visited[$row\
    \ + 1][$col] = 1;\n            $curr[] = [$count + 1, $row + 1, $col];\n     \
    \   }\n        if ($col - 1 >= 0 && !isset($visited[$row][$col - 1])) {\n    \
    \        $visited[$row][$col - 1] = 1;\n            $curr[] = [$count + 1, $row,\
    \ $col - 1];\n        }\n        if ($col + 1 < $m && !isset($visited[$row][$col\
    \ + 1])) {\n            $visited[$row][$col + 1] = 1;\n            $curr[] = [$count\
    \ + 1, $row, $col + 1];\n        }\n    }\n    return $minList;\n}\n", "    //\
    \ dp[i][j][l]: represents the minimum lexicographical path of length l\n    //\
    \ starting from point [i][j].\n    $dp = [];\n    $N = count($grid);\n    for\
    \ ($i = 0; $i < $N; $i++) {\n        for ($j = 0; $j < $N; $j++) {\n         \
    \   for ($l = 0; $l <= $k; $l++) {\n                $dp[$i][$j][$l] = [$grid[$i][$j]];\n\
    \            }\n        }\n    }\n    for ($l = 2; $l <= $k; $l++) {\n       \
    \ for ($i = 0; $i < $N; $i++) {\n            for ($j = 0; $j < $N; $j++) {\n \
    \               $curr = [PHP_INT_MAX];\n                if ($i > 0) {\n      \
    \              $curr = min($curr, $dp[$i - 1][$j][$l - 1]);\n                }\n\
    \                if ($i < $N - 1) {\n                    $curr = min($curr, $dp[$i\
    \ + 1][$j][$l - 1]);\n                }\n                if ($j > 0) {\n     \
    \               $curr = min($curr, $dp[$i][$j - 1][$l - 1]);\n               \
    \ }\n                if ($j < $N - 1) {\n                    $curr = min($curr,\
    \ $dp[$i][$j + 1][$l - 1]);\n                }\n                $dp[$i][$j][$l]\
    \ = $curr;\n                $dp[$i][$j][$l][] = $grid[$i][$j];\n            }\n\
    \        }\n    }\n    $minPath = [PHP_INT_MAX];\n    for ($i = 0; $i < $N; $i++)\
    \ {\n        for ($j = 0; $j < $N; $j++) {\n            $minPath = min($minPath,\
    \ $dp[$i][$j][$k]);\n        }\n    }\n    return $minPath;\n}\n$grid =", "  \
    \  $row = count($grid);\n    $col = count($grid[0]);\n    $res = $path = $visited\
    \ = [];\n    for ($i = 0; $i < $row; $i++) {\n        for ($j = 0; $j < $col;\
    \ $j++) {\n            if ($grid[$i][$j] == 1) {\n                dfs($grid, $k,\
    \ $i, $j, $path, $visited, $res);\n            }\n        }\n    }\n    return\
    \ $res;\n}", "    $m = count($grid);\n    $n = count($grid[0]);\n    $queue =\
    \ new SplPriorityQueue();\n    $value2Pos = [];\n    for ($i = 0; $i < $m; $i++)\
    \ {\n        for ($j = 0; $j < $n; $j++) {\n            $value2Pos[$grid[$i][$j]]\
    \ = [$i, $j];\n        }\n    }\n    $queue->insert([[], $grid[0][0]], PHP_INT_MAX);\n\
    \    $seen = [];\n    while (!$queue->isEmpty()) {\n        $node = $queue->extract();\n\
    \        $path = $node[0];\n        $value = $node[1];\n        if (count($path)\
    \ === $k) {\n            return $path;\n        }\n        $next = $value2Pos[$value];\n\
    \        $key = implode(',', $next);\n        if (isset($seen[$key])) {\n    \
    \        continue;\n        }\n        $seen[$key] = true;\n        $nextPath\
    \ = array_merge($path, [$value]);\n        if ($next[0] > 0) {\n            $queue->insert([$nextPath,\
    \ $grid[$next[0] - 1][$next[1]]], -min($grid[$next[0] - 1][$next[1]], $value));\n\
    \        }\n        if ($next[0] < $m - 1) {\n            $queue->insert([$nextPath,\
    \ $grid[$next[0] + 1][$next[1]]], -min($grid[$next[0] + 1][$next[1]], $value));\n\
    \        }\n        if ($next[1] > 0) {\n            $queue->insert([$nextPath,\
    \ $grid[$next[0]][$next[1] - 1]], -min($grid[$next[0]][$next[1] - 1], $value));\n\
    \        }\n        if ($next[1] < $n - 1) {\n            $queue->insert([$nextPath,\
    \ $grid[$next[0]][$next[1]", "    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $matrix = [];\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            $matrix[$i][$j] = 0;\n        }\n    }\n    $matrix[0][0]\
    \ = 1;\n    $result = [];\n    $result[] = $grid[0][0];\n    $path = [];\n   \
    \ $path[] = [0, 0];\n    while ($k > 0) {\n        $min_value = PHP_INT_MAX;\n\
    \        $min_index = -1;\n        for ($i = 0; $i < count($path); $i++) {\n \
    \           $x = $path[$i][0];\n            $y = $path[$i][1];\n            if\
    \ ($i > 0 && $matrix[$x][$y] < $min_value) {\n                $min_value = $matrix[$x][$y];\n\
    \                $min_index = $i;\n            }\n            if ($x > 0 && $grid[$x\
    \ - 1][$y] < $min_value) {\n                $min_value = $grid[$x - 1][$y];\n\
    \                $min_index = count($path);\n                $path[] = [$x - 1,\
    \ $y];\n            }\n            if ($x < $m - 1 && $grid[$x + 1][$y] < $min_value)\
    \ {\n                $min_value = $grid[$x + 1][$y];\n                $min_index\
    \ = count($path);\n                $path[] = [$x + 1, $y];\n            }\n  \
    \          if ($y > 0 && $grid[$x][$y - 1] < $min_value) {\n                $min_value\
    \ = $grid[$x][$y - 1];\n                $min_index = count($path);\n         \
    \       $path[] = [$x, $y - 1];\n            }\n            if ($y < $n - 1 &&\
    \ $grid[$x][$y + 1] < $min", "    if ($k <= 0) {\n        return [];\n    }\n\
    \    if ($k == 1) {\n        return [$grid[0][0]];\n    }\n    $m = count($grid);\n\
    \    $n = count($grid[0]);\n    $grid[0][0] = -1;\n    $visited = [];\n    $cnt\
    \ = 1;\n    $visited[0][0] = $cnt;\n    while ($cnt < $k) {\n        $visited_new\
    \ = [];\n        foreach ($visited as $x => $rows) {\n            foreach ($rows\
    \ as $y => $v) {\n                if ($x > 0 && $grid[$x - 1][$y] > 0) {\n   \
    \                 $grid[$x - 1][$y] = -1;\n                    $visited_new[$x\
    \ - 1][$y] = $cnt + 1;\n                }\n                if ($x < $m - 1 &&\
    \ $grid[$x + 1][$y] > 0) {\n                    $grid[$x + 1][$y] = -1;\n    \
    \                $visited_new[$x + 1][$y] = $cnt + 1;\n                }\n   \
    \             if ($y > 0 && $grid[$x][$y - 1] > 0) {\n                    $grid[$x][$y\
    \ - 1] = -1;\n                    $visited_new[$x][$y - 1] = $cnt + 1;\n     \
    \           }\n                if ($y < $n - 1 && $grid[$x][$y + 1] > 0) {\n \
    \                   $grid[$x][$y + 1] = -1;\n                    $visited_new[$x][$y\
    \ + 1] = $cnt + 1;\n                }\n            }\n        }\n        $visited\
    \ = $visited_new;\n        $cnt++;\n    }\n    $res = [];\n    foreach ($visited\
    \ as $x => $rows) {\n        foreach ($rows as $y => $v) {\n            $res[]\
    \ = $grid[$x][$y];\n        }\n    }\n    return $res;\n", "    $n = count($grid);\n\
    \    $minPath = array_fill(0, $k, PHP_INT_MAX);\n    $minPath[0] = $grid[0][0];\n\
    \    $queue = [0];\n    $visited = [0];\n    while (!empty($queue)) {\n      \
    \  $cur = array_shift($queue);\n        $row = $cur / $n;\n        $col = $cur\
    \ % $n;\n        $curValue = $grid[$row][$col];\n        // check top neighbor\n\
    \        if ($row > 0 && !in_array($cur - $n, $visited)) {\n            $visited[]\
    \ = $cur - $n;\n            $queue[] = $cur - $n;\n            $upValue = $grid[$row\
    \ - 1][$col];\n            for ($i = 0; $i < $k; $i++) {\n                if ($minPath[$i]\
    \ === PHP_INT_MAX) {\n                    break;\n                }\n        \
    \        if ($i === $k - 1) {\n                    continue;\n               \
    \ }\n                if ($minPath[$i] > $upValue) {\n                    break;\n\
    \                }\n                if ($minPath[$i] < $upValue) {\n         \
    \           continue;\n                }\n                if ($minPath[$i] ===\
    \ $upValue) {\n                    for ($j = $i + 1; $j < $k; $j++) {\n      \
    \                  if ($minPath[$j] === PHP_INT_MAX) {\n                     \
    \       break;\n                        }\n                        if ($minPath[$j]\
    \ > $curValue) {\n                            break;\n                       \
    \ }\n                        if ($minPath[$j] < $curValue) {\n               \
    \             continue;\n                        }\n                        if\
    \ ($minPath[$j] === $curValue) {\n                            $minPath[$j] = $minPath[$j\
    \ - 1];\n                        }\n                    }\n                  \
    \  $minPath[$i] = $upValue;\n                    $minPath[$i + 1] = $curValue;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     // check bottom neighbor\n        if ($row < $n - 1 &&", "    if ($k ==\
    \ 0) {\n        return [];\n    }\n    $n = count($grid);\n    $result = [];\n\
    \    $min = PHP_INT_MAX;\n    $minVal = [];\n    $path = [];\n    helper($grid,\
    \ $n, 0, 0, $k, $result, $min, $minVal, $path);\n    return $minVal;\n}", "  \
    \  $rows = count($grid);\n    $cols = count($grid[0]);\n    $minPath = [];\n \
    \   $minSum = PHP_INT_MAX;\n    $visited = [];\n    for ($i = 0; $i < $rows; $i++)\
    \ {\n        for ($j = 0; $j < $cols; $j++) {\n            $visited[$i][$j] =\
    \ false;\n        }\n    }\n    for ($i = 0; $i < $rows; $i++) {\n        for\
    \ ($j = 0; $j < $cols; $j++) {\n            findMinPath($grid, $i, $j, $k, $visited,\
    \ $minPath, 0, $minSum);\n        }\n    }\n    return $minPath;\n}", "    if\
    \ ($k == 0) {\n        return [];\n    }\n    $m = count($grid);\n    $n = count($grid[0]);\n\
    \    $visited = [];\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j\
    \ < $n; $j++) {\n            $visited[$i][$j] = false;\n        }\n    }\n   \
    \ $result = PHP_INT_MAX;\n    $path = [];\n    $minPathUtil($grid, $visited, $k,\
    \ 0, 0, 0, $path, $result);\n    return $path;\n}", "    if (empty($grid) || $k\
    \ <= 0) {\n        return null;\n    }\n    $total = count($grid) * count($grid[0]);\n\
    \    if ($k > $total) {\n        return null;\n    }\n    $m = count($grid);\n\
    \    $n = count($grid[0]);\n    $minPath = array_fill(0, $k, PHP_INT_MAX);\n \
    \   $minCells = array_fill(0, $k, []);\n    $visited = array_fill(0, $m, array_fill(0,\
    \ $n, false));\n    $queue = new SplQueue();\n    // init queue\n    for ($i =\
    \ 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            $queue->enqueue([$i,\
    \ $j, 0]);\n        }\n    }\n    // loop all possible path\n    while (!$queue->isEmpty())\
    \ {\n        $cur = $queue->dequeue();\n        $row = $cur[0];\n        $col\
    \ = $cur[1];\n        $len = $cur[2];\n        // update if current path is smaller\n\
    \        if ($len > 0 && $grid[$row][$col] < $minPath[$len - 1]) {\n         \
    \   $minPath[$len - 1] = $grid[$row][$col];\n            $minCells[$len - 1] =\
    \ [$row, $col];\n        }\n        // continue if path length not enough\n  \
    \      if ($len < $k) {\n            if ($row - 1 >= 0 && !$visited[$row - 1][$col])\
    \ {\n                $queue->enqueue([$row - 1, $col, $len + 1]);\n          \
    \  }\n            if ($row + 1 < $m && !$visited[$row + 1][$col]) {\n        \
    \        $queue->enqueue([$row + 1, $col, $len + 1]);\n            }\n       \
    \     if ($col - 1 >= 0 && !$visited[$row][$col - 1]) {\n                $queue->enqueue([$row,\
    \ $col - 1, $len", "    if ($k <= 0) {\n        return [];\n    }\n    $m = count($grid);\n\
    \    $n = count($grid[0]);\n    $memo = [];\n    for ($i = 0; $i < $m; $i++) {\n\
    \        for ($j = 0; $j < $n; $j++) {\n            if ($i === 0 && $j === 0)\
    \ {\n                $memo[$i][$j] = [$grid[$i][$j]];\n            } else {\n\
    \                $memo[$i][$j] = [PHP_INT_MAX];\n            }\n        }\n  \
    \  }\n    for ($i = 0; $i < $m; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n\
    \            if ($i > 0) {\n                $curr = $memo[$i - 1][$j];\n     \
    \           if ($curr[0] < $memo[$i][$j][0]) {\n                    $memo[$i][$j]\
    \ = array_merge([$grid[$i][$j]], $curr);\n                } else if ($curr[0]\
    \ === $memo[$i][$j][0]) {\n                    $memo[$i][$j] = compare($memo[$i][$j],\
    \ array_merge([$grid[$i][$j]], $curr));\n                }\n            }\n  \
    \          if ($j > 0) {\n                $curr = $memo[$i][$j - 1];\n       \
    \         if ($curr[0] < $memo[$i][$j][0]) {\n                    $memo[$i][$j]\
    \ = array_merge([$grid[$i][$j]], $curr);\n                } else if ($curr[0]\
    \ === $memo[$i][$j][0]) {\n                    $memo[$i][$j] = compare($memo[$i][$j],\
    \ array_merge([$grid[$i][$j]], $curr));\n                }\n            }\n  \
    \      }\n    }\n    $lastRow ="]
stop_tokens:
- "\nfunction"
- "\n?>"
- "\n//"
- "\n#"
