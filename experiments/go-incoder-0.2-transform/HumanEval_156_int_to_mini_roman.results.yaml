language: go_test.go
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n  \
    \  roman_numeral := roman_numerals[number]\n    if number < 1 || number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb_wlghd6_test.go:33:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"\
    XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n   \
    \     \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\", \"LIX\",\n        \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\",\n        \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\", \"LXXIX\",\n        \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n\
    \        \"XC\", \"C\", \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\",\n        \"XC\", \"C\", \"CI\", \"CII\",\
    \ \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\",\n\
    \        \"XXC\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"\
    CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\",\n        \"XXXC\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"XLC\", \"LCC\", \"LCCI\", \"LCCII\", \"LCCIII\", \"LCCIV\"\
    , \"LCCV\", \"LCCVI\", \"L\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0m7qili3_test.go:32:76: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number >= number\
    \ {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\", romanNumeral,\
    \ number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsau_j3cw_test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    ,\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8l8t_zot_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\",\n        \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\",\n        \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\"\
    ,\n        \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\",\n        \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\",\n        \"CXIX\", \"CC\", \"CCI\"\
    , \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\",\n        \"CCVIII\"\
    , \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\",\n \
    \       \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \"CCXX\", \"CCXXI\", \"\
    CCXXII\",\n        \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \"CCXXVII\"\
    , \"CCXXVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnnvtww_q_test.go:34:60: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiii\"\
    ,\n        10000: \"vivvi\",\n        50000: \"vivvii\",\n        100000: \"vivviii\"\
    ,\n        500000: \"vivviiii\",\n        1000000: \"vivviv\",\n        5000000:\
    \ \"vivvivi\",\n        10000000: \"vivvivii\",\n        50000000: \"vivviviii\"\
    ,\n        100000000: \"vivviviiii\",\n        500000000: \"vivviviiiii\",\n \
    \       1000000000: \"vivviviv\",\n        5000000000: \"vivvivivi\",\n      \
    \  10000000000: \"vivvivivii\",\n        50000000000: \"vivviviviii\",\n     \
    \   100000000000: \"vivviviviiii\",\n        500000000000: \"vivviviviiiii\",\n\
    \        1000000000000: \"vivviviviv\",\n        5000000000000: \"vivvivivivi\"\
    ,\n        10000000000000: \"vivvivivivii\",\n        50000000000000: \"vivviviviviii\"\
    ,\n        100000000000000: \"vivviviviviiii\",\n        500000000000000: \"vivviviviviiiii\"\
    ,\n        1000000000000000: \"vivviviviviv\",\n        5000000000000000: \"vivvivivivivi\"\
    ,\n        10000000000000000: \"vivvivivivivii\",\n        5000000000000000: \"\
    vivviviviviviii\",\n        10000000000000000: \"vivviviviviviiii\",\n       \
    \ 5000000000000000: \"vivviviviviviiiii\",\n        100000000000000000: \"vivviviviviviv\"\
    ,\n        50000000000000000: \"vivvivivivivi\",\n        1000000000000000000:\
    \ \"vivvivivivivii\",\n        500000000000000000: \"vivviviviviviii\",\n    \
    \    10000000000000000000: \"vivviviviviviiii\",\n        5000000000000000000:\
    \ \"vivviviviviviiiii\",\n        \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7ne77es9_test.go:63:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := \"\"\n\
    \    for roman_numeral, number := range roman_numerals {\n        if number >=\
    \ number {\n            break\n        }\n    }\n    if number == 0 {\n      \
    \  return roman_numeral\n    }\n    roman_numeral += roman_numerals[number]\n\
    \    for i := number; i > 0; i-- {\n        roman_numeral += roman_numerals[number/i]\n\
    \    }\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9vpsc84d_test.go:29:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n\
    \        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case\
    \ 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"VI\"\n   \
    \ case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\
    \n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num = \"\
    X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpko4pjie6_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    romanNumerals := map[int]string{\n        1: \"i\"\
    ,\n        5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100:\
    \ \"viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\"\
    ,\n        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n \
    \       500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n\
    \        10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n    }\n    romanNumeralString := \"\"\
    \n    for romanNumeral, roman := range romanNumerals {\n        if number >= romanNumeral\
    \ {\n            romanNumeralString += roman\n            number -= romanNumeral\n\
    \        }\n    }\n    return strings.ToLower(romanNumeralString)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2y1v8a5t_test.go:64:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n    }\n\n    romanNumeral\
    \ := romanNumerals[number]\n    if romanNumeral == \"\" {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmv1tgn4e_test.go:33:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    ix\",\n        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    if number == 0 {\n        return romanNumeral\n\
    \    }\n    result := \"\"\n    currentNumber := number\n    for {\n        if\
    \ currentNumber > 1000 {\n            break\n        }\n        result += romanNumeral\n\
    \        currentNumber -= romanNumerals[currentNumber]\n    }\n    return result\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2z0dwa8w_test.go:39:9: invalid operation: currentNumber -= romanNumerals[currentNumber]
    (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"IV\", \"V\", \"IX\"\
    , \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"\n    }\n \
    \   result := \"\"\n    i := 0\n    for ; i < len(romans); i++ {\n        if number\
    \ >= romans[i] && number < romans[i+1] {\n            result += romans[i]\n  \
    \          number -= romans[i]\n        }\n    }\n    if number > 0 {\n      \
    \  result += romans[i]\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph_arctom_test.go:20:78: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\"\
    , \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result := \"\
    \"\n    for i := 0; i < len(roman_num); i++ {\n        if number >= 1000 && number\
    \ < 1000000 {\n            result += roman_num[i]\n            number -= 1000\n\
    \        } else {\n            result += roman_num[i] + string(number % 10)\n\
    \            number /= 10\n        }\n    }\n    return strings.ToLower(result)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnnb2ufki_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\",\n        \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\",\n        \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\"\
    ,\n        \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\",\n        \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\",\n        \"CXIX\", \"CC\", \"CCI\"\
    , \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\",\n        \"CCVIII\"\
    , \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\",\n \
    \       \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \"CCXX\", \"CCXXI\", \"\
    CCXXII\",\n        \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \"CCXXVII\"\
    , \"CCXXVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnnvtww_q_test.go:34:60: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result := \"\"\n\
    \    number -= 1 // We start at 1, not 0\n    for _, roman := range romans {\n\
    \        result += roman\n        number /= 10\n    }\n    return strings.ToLower(result)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv3mosk4k_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n\n    romanNumeral\
    \ := romanNumerals[number]\n\n    if number == 0 {\n        return \"\"\n    }\n\
    \n    return romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp5mvmow3r_test.go:64: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp5mvmow3r_test.go:64: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp5mvmow3r_test.go:64: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp5mvmow3r_test.go:64: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp5mvmow3r_test.go:64:\
    \ expected 'd', got 'viv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp5mvmow3r_test.go:64: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp5mvmow3r_test.go:64: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp5mvmow3r_test.go:64: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp5mvmow3r_test.go:64: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp5mvmow3r_test.go:64: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp5mvmow3r_test.go:64:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp5mvmow3r_test.go:64: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp5mvmow3r_test.go:64: expected 'm', got 'vi'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075666
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \      50000000000000000: \"viiv\",\n        10000000000000000000: \"viv\",\n\
    \        5000000000000000000: \"viiv\",\n        100000000000000000000: \"viv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000: \"viiv\",\n        100000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000: \"viiv\",\n        1000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000: \"viiv\",\n        10000000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000000: \"viiv\",\n        100000000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000000: \"viiv\",\n        1000000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000000: \"viiv\",\n        10000000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqibzoj_7_test.go:78:41: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuqg9dqn_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"c\"\n    default:\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    return roman_number\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpyt9x8dhj_test.go:71: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpyt9x8dhj_test.go:71: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpyt9x8dhj_test.go:71:\
    \ expected 'd', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpyt9x8dhj_test.go:71: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpyt9x8dhj_test.go:71: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpyt9x8dhj_test.go:71: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpyt9x8dhj_test.go:71:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpyt9x8dhj_test.go:71:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'm', got 'c'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075666
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\",\n        \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\",\n    \
    \    \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\",\n        \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\",\n        \"XXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\",\n        \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\",\n        \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\",\n        \"LXXIII\"\
    , \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\",\n      \
    \  \"XC\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\",\
    \ \"M\", \"MM\",\n        \"MMM\", \"MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\"\
    , \"MMMMMMMM\", \"MMMMMMMMM\",\n        \"MMMMMMMMMM\", \"MMMMMMMMMMM\", \"MMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMM\", \"MMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n     \
    \   \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMM\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv_6ubu9v_test.go:38:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\"I\", \"II\", \"III\", \"IV\", \"V\"\
    , \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIIII\"\
    , \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIVIV\", \"LIVV\", \"\
    LIVVI\", \"LIVVII\", \"LIVVIII\", \"LIVIX\", \"LX\", \"L\", \"LXI\", \"LXII\"\
    , \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"\
    LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\"\
    , \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"\
    CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXX\", \"CXXI\", \"\
    CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\",\
    \ \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\", \"CXIII\", \"CXX\", \"CXXI\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmxvp20wn_test.go:19:1159: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viv\"\
    ,\n        10000: \"viv\",\n        50000: \"viv\",\n        100000: \"viv\",\n\
    \        500000: \"viv\",\n        1000000: \"viv\",\n        5000000: \"viv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viv\",\n        1000000000: \"viv\",\n      \
    \  5000000000: \"viv\",\n        10000000000: \"viv\",\n        50000000000: \"\
    viv\",\n        100000000000: \"viv\",\n        500000000000: \"viv\",\n     \
    \   1000000000000: \"viv\",\n        5000000000000: \"viv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viv\",\n        1000000000000000: \"viv\",\n   \
    \     5000000000000000: \"viv\",\n        1000000000000000000: \"viv\",\n    }\n\
    \    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkztroheo_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwv13wfzz_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return \"\"\n    }\n\n    roman_numerals := []string{\n\
    \        \"M\",\n        \"CM\",\n        \"D\",\n        \"CD\",\n        \"\
    C\",\n        \"XC\",\n        \"L\",\n        \"XL\",\n        \"X\",\n     \
    \   \"IX\",\n        \"V\",\n        \"IV\",\n        \"I\",\n    }\n\n    roman_numeral_string\
    \ := \"\"\n    for _, roman_numeral := range roman_numerals {\n        if number\
    \ >= roman_numeral {\n            roman_numeral_string += roman_numeral\n    \
    \        number -= roman_numeral\n        }\n    }\n\n    return roman_numeral_string\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5va6ftn8_test.go:42:22: invalid operation: number >= roman_numeral (mismatched
    types int and string)

    /tmp/tmp5va6ftn8_test.go:44:13: invalid operation: number -= roman_numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvii\",\n        100000: \"\
    vivviii\",\n        500000: \"viiviii\",\n        1000000: \"viiviiii\",\n   \
    \     5000000: \"viiiviii\",\n        10000000: \"viiiviiii\",\n        50000000:\
    \ \"vivviiiii\",\n        100000000: \"vivviiiiii\",\n        500000000: \"viiviiiiii\"\
    ,\n        1000000000: \"viiviiiiiii\",\n        5000000000: \"viiiviiiiii\",\n\
    \        10000000000: \"viiiviiiiiii\",\n        50000000000: \"vivviiiiiiiii\"\
    ,\n        100000000000: \"vivviiiiiiiiii\",\n        500000000000: \"viiviiiiiiiiii\"\
    ,\n        1000000000000: \"viiviiiiiiiiiii\",\n        5000000000000: \"viiiviiiiiiiiii\"\
    ,\n        10000000000000: \"viiiviiiiiiiiiii\",\n        50000000000000: \"vivviiiiiiiiiiiiii\"\
    ,\n        100000000000000: \"vivviiiiiiiiiiiiiii\",\n        500000000000000:\
    \ \"viiviiiiiiiiiiiiiiii\",\n        1000000000000000: \"viiviiiiiiiiiiiiiiiii\"\
    ,\n        5000000000000000: \"viiiviiiiiiiiiiiiiiii\",\n        1000000000000000000:\
    \ \"viiiviiiiiiiiiiiiiiiii\",\n    }\n    roman_numeral := \"\"\n    for roman_numeral,\
    \ number := range roman_numerals {\n        if number <= number {\n          \
    \  break\n        }\n    }\n    if number > 1000 {\n        fmt.Println(\"int_to_mini_roman:\
    \ number too large\")\n        return \"\"\n    }\n    return roman_numerals[number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprmwtp8v__test.go:54:5: roman_numeral declared but not used

    /tmp/tmprmwtp8v__test.go:55:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n   \
    \     \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\",\n        \"CCVII\"\
    , \"CCV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp50v6obyd_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    int_to_mini_roman: number must be between 1 and 1000\")\n        return \"\"\n\
    \    }\n\n    roman_numerals := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n      \
    \  10000: \"viii\",\n        100000: \"viv\",\n        1000000: \"viv\",\n   \
    \     10000000: \"viii\",\n        100000000: \"viv\",\n        1000000000: \"\
    viv\",\n        10000000000: \"viii\",\n        100000000000: \"viv\",\n     \
    \   1000000000000: \"viii\",\n        10000000000000: \"viv\",\n        100000000000000:\
    \ \"viii\",\n        1000000000000000: \"viv\",\n        10000000000000000: \"\
    viii\",\n        100000000000000000: \"viv\",\n        1000000000000000000: \"\
    vi\",\n    }\n\n    roman_numeral := \"\"\n    for roman_numeral, number := range\
    \ roman_numerals {\n        if number == number {\n            return roman_numeral\n\
    \        }\n    }\n\n    return \"\"\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppgta9uej_test.go:50:5: roman_numeral declared but not used

    /tmp/tmppgta9uej_test.go:53:20: cannot use roman_numeral (variable of type int)
    as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"\
    XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n   \
    \     \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n    }\n   \
    \ romanNumeralIndex := 0\n    romanNumeralIndex := romanNumeralIndex + number\n\
    \    romanNumeralIndex %= len(romanNumerals)\n    return romanNumerals[romanNumeralIndex]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuz2oavly_test.go:26:23: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number := roman_numerals[number]\n\
    \    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiomvmrcm_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n        50000000000000000: \"vi\",\n\
    \        10000000000000000000: \"vi\",\n        5000000000000000000: \"vi\",\n\
    \        100000000000000000000: \"vi\",\n        50000000000000000000: \"vi\"\
    ,\n        1000000000000000000000: \"vi\",\n        500000000000000000000: \"\
    vi\",\n        10000000000000000000000: \"vi\",\n        5000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000: \"vi\",\n        50000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000: \"vi\",\n        500000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000: \"vi\",\n        5000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000: \"vi\",\n        50000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000: \"vi\",\n        500000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000: \"vi\",\n        5000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000: \"vi\",\n        50000000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000000: \"vi\",\n        500000000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000000: \"vi\",\n        5000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        50000000000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000000000: \"vi\",\n        500000000000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000000000\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeskgaofy_test.go:84:44: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n  \
    \  roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsl805vh2_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"ix\"\n    case 7:\n        roman_number = \"lb\"\n    case 8:\n        roman_number\
    \ = \"c\"\n    case 9:\n        roman_number = \"d\"\n    case 10:\n        roman_number\
    \ = \"ix\"\n    case 11:\n        roman_number = \"lb\"\n    case 12:\n      \
    \  roman_number = \"c\"\n    case 13:\n        roman_number = \"d\"\n    case\
    \ 14:\n        roman_number = \"ix\"\n    case 15:\n        roman_number = \"\
    lb\"\n    case 16:\n        roman_number = \"c\"\n    case 17:\n        roman_number\
    \ = \"d\"\n    case 18:\n        roman_number = \"ix\"\n    case 19:\n       \
    \ roman_number = \"lb\"\n    case 20:\n        roman_number = \"c\"\n    case\
    \ 21:\n        roman_number = \"d\"\n    case 22:\n        roman_number = \"ix\"\
    \n    case 23:\n        roman_number = \"lb\"\n    case 24:\n        roman_number\
    \ = \"c\"\n    case 25:\n        roman_number = \"d\"\n    case 26:\n        roman_number\
    \ = \"ix\"\n    case 27:\n        roman_number = \"lb\"\n    case 28:\n      \
    \  roman_number = \"c\"\n    case 29:\n        roman_number = \"d\"\n    case\
    \ 30:\n        roman_number = \"ix\"\n    case 31:\n        roman_number = \"\
    lb\"\n    case 32:\n        roman_number = \"c\"\n    case 33:\n        roman_number\
    \ = \"d\"\n    case 34:\n        roman_number = \"ix\"\n    case 35:\n       \
    \ roman_number = \"lb\"\n    case 36:\n        roman_number = \"c\"\n    case\
    \ 37:\n        roman_number = \"d\"\n    case 38:\n        roman_number = \"ix\"\
    \n    case 39:\n        roman_number = \"lb\"\n    case 40:\n        roman_number\
    \ = \"c\"\n    case 41:\n        roman_number = \"d\"\n    case 42:\n        roman_number\
    \ = \"ix\"\n    case 43:\n        roman_number = \"lb\"\n    case 44:\n      \
    \  roman_number = \"c\"\n    case 45:\n        roman_\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmm1yp02d_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"\
    i\",\n        5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n      \
    \  100: \"viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000:\
    \ \"viiv\",\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000:\
    \ \"viv\",\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000:\
    \ \"viiv\",\n        10000000: \"viv\",\n        50000000: \"viiv\",\n       \
    \ 100000000: \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\"\
    ,\n        5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        10000000000000000: \"viv\",\n    \
    \    5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n    \
    \    50000000000000000: \"viiv\",\n        10000000000000000000: \"viv\",\n  \
    \      5000000000000000000: \"viiv\",\n        100000000000000000000: \"viv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viv\",\n    }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnj5cn513_test.go:56:9: duplicate key 5000000000000000 in map literal

    /tmp/tmpnj5cn513_test.go:59:9: cannot use 10000000000000000000 (untyped int constant)
    as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:61:9: cannot use 100000000000000000000 (untyped int constant)
    as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:62:9: cannot use 50000000000000000000 (untyped int constant)
    as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:63:9: cannot use 1000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:64:9: cannot use 500000000000000000000 (untyped int constant)
    as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:65:9: cannot use 10000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:66:9: cannot use 5000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:67:9: cannot use 100000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:68:9: cannot use 50000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpnj5cn513_test.go:68:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075666
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viv\",\n        500: \"vivvi\",\n        1000: \"vivv\",\n        5000: \"\
    vivvv\",\n        10000: \"vivvvv\",\n        100000: \"vivvvvv\",\n        1000000:\
    \ \"vivvvvvv\",\n        10000000: \"vivvvvvvv\",\n        100000000: \"vivvvvvvvv\"\
    ,\n        1000000000: \"vivvvvvvvvv\",\n        10000000000: \"vivvvvvvvvvv\"\
    ,\n        100000000000: \"vivvvvvvvvvvv\",\n        1000000000000: \"vivvvvvvvvvvvv\"\
    ,\n        10000000000000: \"vivvvvvvvvvvvvv\",\n        100000000000000: \"vivvvvvvvvvvvvvv\"\
    ,\n        1000000000000000: \"vivvvvvvvvvvvvvvv\",\n        10000000000000000:\
    \ \"vivvvvvvvvvvvvvvvv\",\n        100000000000000000: \"vivvvvvvvvvvvvvvvvv\"\
    ,\n        1000000000000000000: \"vivvvvvvvvvvvvvvvvvv\",\n    }\n\n    romanNumeral\
    \ := \"\"\n    for romanNumeral, number := range romanNumerals {\n        if number\
    \ <= number {\n            break\n        }\n    }\n\n    if romanNumeral == \"\
    \" {\n        fmt.Println(\"Roman numeral not found!\")\n    }\n\n    return romanNumerals[number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyjuztxbu_test.go:46:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075666
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"mi\"\n    case 7:\n        roman_number = \"f\"\n    case 8:\n        roman_number\
    \ = \"v\"\n    case 9:\n        roman_number = \"x\"\n    case 10:\n        roman_number\
    \ = \"c\"\n    case 11:\n        roman_number = \"d\"\n    case 12:\n        roman_number\
    \ = \"mi\"\n    case 13:\n        roman_number = \"f\"\n    case 14:\n       \
    \ roman_number = \"v\"\n    case 15:\n        roman_number = \"x\"\n    case 16:\n\
    \        roman_number = \"c\"\n    case 17:\n        roman_number = \"d\"\n  \
    \  case 18:\n        roman_number = \"mi\"\n    case 19:\n        roman_number\
    \ = \"f\"\n    case 20:\n        roman_number = \"v\"\n    case 21:\n        roman_number\
    \ = \"x\"\n    case 22:\n        roman_number = \"c\"\n    case 23:\n        roman_number\
    \ = \"d\"\n    case 24:\n        roman_number = \"mi\"\n    case 25:\n       \
    \ roman_number = \"f\"\n    case 26:\n        roman_number = \"v\"\n    case 27:\n\
    \        roman_number = \"x\"\n    case 28:\n        roman_number = \"c\"\n  \
    \  case 29:\n        roman_number = \"d\"\n    case 30:\n        roman_number\
    \ = \"mi\"\n    case 31:\n        roman_number = \"f\"\n    case 32:\n       \
    \ roman_number = \"v\"\n    case 33:\n        roman_number = \"x\"\n    case 34:\n\
    \        roman_number = \"c\"\n    case 35:\n        roman_number = \"d\"\n  \
    \  case 36:\n        roman_number = \"mi\"\n    case 37:\n        roman_number\
    \ = \"f\"\n    case 38:\n        roman_number = \"v\"\n    case 39:\n        roman_number\
    \ = \"x\"\n    case 40:\n        roman_number = \"c\"\n    case 41:\n        roman_number\
    \ = \"d\"\n    case 42:\n        roman_number = \"mi\"\n    case 43:\n       \
    \ roman_number = \"f\"\n    case 44:\n        roman_number = \"v\"\n    case 45:\n\
    \        roman_number = \"x\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnlviqury_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n\n    romanNumeralString\
    \ := \"\"\n    for romanNumeral, roman := range romanNumerals {\n        if number\
    \ >= romanNumeral {\n            romanNumeralString += roman\n            number\
    \ -= romanNumeral\n        }\n    }\n\n    return romanNumeralString\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmps6yqmmko_test.go:66: expected 'xix', got 'ivivii'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmps6yqmmko_test.go:66:\
    \ expected 'clii', got 'vivivivii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmps6yqmmko_test.go:66: expected 'ccli', got 'viviiviiivivi'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmps6yqmmko_test.go:66:\
    \ expected 'cdxxvi', got 'viiivivivivii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmps6yqmmko_test.go:66: expected 'd', got 'iviviiviiiviv'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmps6yqmmko_test.go:66:\
    \ expected 'iv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n\
    \        tmps6yqmmko_test.go:66: expected 'xliii', got 'viviii'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmps6yqmmko_test.go:66: expected\
    \ 'xc', got 'viiiivivii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n\
    \        tmps6yqmmko_test.go:66: expected 'xciv', got 'iviviiviii'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmps6yqmmko_test.go:66:\
    \ expected 'dxxxii', got 'viiviiivivivi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmps6yqmmko_test.go:66: expected 'cm', got 'iviviiviiivivviv'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmps6yqmmko_test.go:66:\
    \ expected 'cmxciv', got 'viviviviiviiiviv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmps6yqmmko_test.go:66: expected 'm', got 'viiviiivivvivivi'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075667
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := []string{\"M\", \"CM\", \"D\",\
    \ \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n\
    \    roman_numerals_lower := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    roman_numerals_upper\
    \ := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"}\n    roman_numerals_lower_upper := []string{\"\
    m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\"\
    , \"iv\", \"i\"}\n    roman_numerals_upper_lower := []string{\"M\", \"CM\", \"\
    D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\
    }\n    roman_numerals_upper_lower_lower := []string{\"M\", \"CM\", \"D\", \"CD\"\
    , \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    roman_numerals_upper_lower_lower_lower\
    \ := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"}\n    roman_numerals_upper_lower_lower_lower_lower\
    \ := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"}\n    roman_numerals_upper_lower_lower_lower_lower_lower\
    \ := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"}\n    roman_numerals_upper_lower_lower_lower_lower_lower_lower\
    \ := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"}\n    roman_numerals_upper_lower_lower_lower_lower_lower_lower_lower\
    \ := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"}\n    roman_numerals_upper_lower_lower_lower_lower_lower_lower_lower_lower\
    \ := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfsxj1ldw_test.go:33:152: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075666
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhcjrxs_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000:\
    \ \"m\",\n        50000: \"m\",\n        100000: \"b\",\n        500000: \"b\"\
    ,\n        1000000: \"y\",\n        5000000: \"y\",\n        10000000: \"z\",\n\
    \        50000000: \"z\",\n        100000000: \"d\",\n        500000000: \"d\"\
    ,\n        1000000000: \"c\",\n        5000000000: \"c\",\n        10000000000:\
    \ \"v\",\n        50000000000: \"v\",\n        100000000000: \"v\",\n        500000000000:\
    \ \"v\",\n        1000000000000: \"v\",\n        5000000000000: \"v\",\n     \
    \   10000000000000: \"v\",\n        50000000000000: \"v\",\n        100000000000000:\
    \ \"v\",\n        500000000000000: \"v\",\n        1000000000000000: \"v\",\n\
    \        5000000000000000: \"v\",\n        1000000000000000000: \"v\",\n    }\n\
    \n    romanNumeral := \"\"\n    for romanNumeral, number := range romanNumerals\
    \ {\n        if number >= number {\n            break\n        }\n    }\n\n  \
    \  if romanNumeral == \"\" {\n        fmt.Println(\"Error: no roman numeral for\
    \ number \", number)\n    }\n\n    return romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbyek7r3y_test.go:56:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075666
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n    }\n    roman_number := 0\n  \
    \  roman_number += number/100\n    number %= 100\n    roman_number += number/10\n\
    \    number %= 10\n    roman_number += number\n    return romans[roman_number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: runtime error: index out\
    \ of range [10] with length 9 [recovered]\n\tpanic: runtime error: index out of\
    \ range [10] with length 9\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.int_to_mini_roman(...)\n\t/tmp/tmp9kwbhicu_test.go:28\n\
    command-line-arguments_test.TestInt_To_Mini_Roman(0x0?)\n\t/tmp/tmp9kwbhicu_test.go:38\
    \ +0x1d\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075667
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"\
    i\",\n        5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n      \
    \  100: \"viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000:\
    \ \"vi\",\n        10000: \"vi\",\n        100000: \"vi\",\n        1000000: \"\
    vi\",\n        10000000: \"vi\",\n        100000000: \"vi\",\n        1000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        100000000000: \"vi\",\n     \
    \   1000000000000: \"vi\",\n        10000000000000: \"vi\",\n        100000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        10000000000000000: \"vi\"\
    ,\n        100000000000000000: \"vi\",\n        1000000000000000000: \"vi\",\n\
    \    }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiygpli7d_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075666
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number <= number\
    \ {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\", romanNumeral,\
    \ number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp20u9xe99_test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"ix\",\n\
    \        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    result := \"\"\n \
    \   for num, _ := range romans {\n        if number >= num {\n            result\
    \ += romans[num]\n            number -= num\n        }\n    }\n    return strings.ToLower(result)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp46r72ce3_test.go:35:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075666
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 2:\n        roman_num = \"c\"\n    case 3:\n\
    \        roman_num = \"m\"\n    case 4:\n        roman_num = \"l\"\n    case 5:\n\
    \        roman_num = \"x\"\n    case 6:\n        roman_num = \"c\"\n    case 7:\n\
    \        roman_num = \"m\"\n    case 8:\n        roman_num = \"l\"\n    case 9:\n\
    \        roman_num = \"x\"\n    case 10:\n        roman_num = \"c\"\n    case\
    \ 11:\n        roman_num = \"m\"\n    case 12:\n        roman_num = \"l\"\n  \
    \  case 13:\n        roman_num = \"x\"\n    case 14:\n        roman_num = \"c\"\
    \n    case 15:\n        roman_num = \"m\"\n    case 16:\n        roman_num = \"\
    l\"\n    case 17:\n        roman_num = \"x\"\n    case 18:\n        roman_num\
    \ = \"c\"\n    case 19:\n        roman_num = \"m\"\n    case 20:\n        roman_num\
    \ = \"l\"\n    case 21:\n        roman_num = \"x\"\n    case 22:\n        roman_num\
    \ = \"c\"\n    case 23:\n        roman_num = \"m\"\n    case 24:\n        roman_num\
    \ = \"l\"\n    case 25:\n        roman_num = \"x\"\n    case 26:\n        roman_num\
    \ = \"c\"\n    case 27:\n        roman_num = \"m\"\n    case 28:\n        roman_num\
    \ = \"l\"\n    case 29:\n        roman_num = \"x\"\n    case 30:\n        roman_num\
    \ = \"c\"\n    case 31:\n        roman_num = \"m\"\n    case 32:\n        roman_num\
    \ = \"l\"\n    case 33:\n        roman_num = \"x\"\n    case 34:\n        roman_num\
    \ = \"c\"\n    case 35:\n        roman_num = \"m\"\n    case 36:\n        roman_num\
    \ = \"l\"\n    case 37:\n        roman_num = \"x\"\n    case 38:\n        roman_num\
    \ = \"c\"\n    case 39:\n        roman_num = \"m\"\n    case 40:\n        roman_num\
    \ = \"l\"\n    case 41:\n        roman_num = \"x\"\n    case 42:\n        roman_num\
    \ = \"c\"\n    case 43:\n        roman_num = \"m\"\n    case 44:\n        roman_num\
    \ = \"l\"\n    case 45:\n        roman_num\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgf15spu__test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return \"\"\n    }\n\n    roman_numerals := []string{\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\"}\n    roman_numerals_index := []int{1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n\n    roman_numeral := \"\"\n    for _, roman_numeral_index\
    \ := range roman_numerals_index {\n        if number >= roman_numeral_index {\n\
    \            roman_numeral = roman_numerals[roman_numeral_index-number]\n    \
    \        break\n        }\n    }\n\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz9p_7_gb_test.go:35:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiviii\"\
    ,\n        10000: \"viiii\",\n        50000: \"viiiii\",\n        100000: \"viv\"\
    ,\n        500000: \"vivi\",\n        1000000: \"vivii\",\n        5000000: \"\
    viviii\",\n        10000000: \"viviv\",\n        50000000: \"vivivi\",\n     \
    \   100000000: \"vivivii\",\n        500000000: \"viviviii\",\n        1000000000:\
    \ \"viviviv\",\n        5000000000: \"vivivivi\",\n        10000000000: \"vivivivii\"\
    ,\n        50000000000: \"viviviviii\",\n        100000000000: \"viviviviv\",\n\
    \        500000000000: \"vivivivivi\",\n        1000000000000: \"vivivivivii\"\
    ,\n        5000000000000: \"viviviviviii\",\n        10000000000000: \"viviviviviv\"\
    ,\n        50000000000000: \"vivivivivivi\",\n        100000000000000: \"vivivivivivii\"\
    ,\n        500000000000000: \"viviviviviviii\",\n        1000000000000000: \"\
    viviviviviviv\",\n        5000000000000000: \"vivivivivivivi\",\n        10000000000000000:\
    \ \"vivivivivivivii\",\n        5000000000000000: \"viviviviviviviii\",\n    \
    \    100000000000000000: \"viviviviviviviv\",\n        50000000000000000: \"vivivivivivivivi\"\
    ,\n        1000000000000000000: \"vivivivivivivii\",\n        500000000000000000:\
    \ \"viviviviviviviviii\",\n        10000000000000000000: \"viviviviviviviviv\"\
    ,\n        5000000000000000000: \"vivivivivivivivivi\",\n        100000000000000000000:\
    \ \"vivivivivivivivivii\",\n        50000000000000000000: \"viviviviviviviviviii\"\
    ,\n        1000000000000000000000: \"viviviviviviviviviv\",\n        500000000000000000000:\
    \ \"vivi\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvti3gp6n_test.go:63:32: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n      \
    \  10000: \"viii\",\n        100000: \"viv\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpgevwnbdu_test.go:64: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpgevwnbdu_test.go:64: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpgevwnbdu_test.go:64: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpgevwnbdu_test.go:64: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpgevwnbdu_test.go:64:\
    \ expected 'd', got 'viv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpgevwnbdu_test.go:64: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpgevwnbdu_test.go:64: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpgevwnbdu_test.go:64: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpgevwnbdu_test.go:64: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpgevwnbdu_test.go:64: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpgevwnbdu_test.go:64:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpgevwnbdu_test.go:64: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpgevwnbdu_test.go:64: expected 'm', got 'vi'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075668
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw8omr9rj_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viivi\"\
    ,\n        10000: \"viiii\",\n        100000: \"vivvi\",\n        1000000: \"\
    vivii\",\n        10000000: \"viviii\",\n        100000000: \"viviv\",\n     \
    \   1000000000: \"vivivi\",\n        10000000000: \"vivivii\",\n        100000000000:\
    \ \"viviviii\",\n        1000000000000: \"viviviv\",\n        10000000000000:\
    \ \"vivivivi\",\n        100000000000000: \"vivivivii\",\n        1000000000000000:\
    \ \"viviviviii\",\n        10000000000000000: \"viviviviv\",\n        100000000000000000:\
    \ \"vivivivivi\",\n        1000000000000000000: \"vivivivivii\",\n        10000000000000000000:\
    \ \"viviviviviii\",\n        100000000000000000000: \"viviviviviv\",\n       \
    \ 1000000000000000000000: \"vivivivivivi\",\n        10000000000000000000000:\
    \ \"vivivivivivii\",\n        100000000000000000000000: \"viviviviviviii\",\n\
    \        1000000000000000000000000: \"viviviviviviv\",\n        10000000000000000000000000:\
    \ \"vivivivivivivi\",\n        1000000000000000000000000000: \"vivivivivivivii\"\
    ,\n        10000000000000000000000000000: \"viviviviviviviii\",\n        100000000000000000000000000000:\
    \ \"viviviviviviviv\",\n        1000000000000000000000000000000: \"vivivivivivivivii\"\
    ,\n        10000000000000000000000000000000: \"viviviviviviviviii\",\n       \
    \ 100000000000000000000000000000000: \"viviviviviviviviv\",\n        1000000000000000000000000000000000:\
    \ \"vivivivivivivivivi\",\n        1000000000000000000000000000000000: \"vivivivivivivivivii\"\
    ,\n        1000000000000000000000000000000000: \"viviviviviviviviii\",\n     \
    \   1000000000000000000000000000000000: \"viviviviviviviviviii\",\n        1000000000000000000000000000000000:\
    \ \"viviviviviviviviviii\",\n        1000000000000000000000000000000000: \"vivivivi\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpewunegf4_test.go:61:45: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n    romanNumerals[number]\
    \ = \"\"\n    romanNumerals[number / 1000] = \"v\"\n    romanNumerals[number /\
    \ 500] = \"v\"\n    romanNumerals[number / 100] = \"v\"\n    romanNumerals[number\
    \ / 50] = \"v\"\n    romanNumerals[number / 10] = \"v\"\n    romanNumerals[number\
    \ / 5] = \"v\"\n    romanNumerals[number / 2] = \"v\"\n    romanNumerals[number\
    \ / 1] = \"v\"\n    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmphilo9q9x_test.go:66: expected 'xix', got 'v'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmphilo9q9x_test.go:66: expected\
    \ 'clii', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n \
    \       tmphilo9q9x_test.go:66: expected 'ccli', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmphilo9q9x_test.go:66: expected 'cdxxvi', got 'v'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmphilo9q9x_test.go:66:\
    \ expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmphilo9q9x_test.go:66: expected 'i', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmphilo9q9x_test.go:66: expected 'iv', got 'v'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmphilo9q9x_test.go:66: expected\
    \ 'xliii', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n\
    \        tmphilo9q9x_test.go:66: expected 'xc', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmphilo9q9x_test.go:66: expected 'xciv', got 'v'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmphilo9q9x_test.go:66:\
    \ expected 'dxxxii', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmphilo9q9x_test.go:66: expected 'cm', got 'v'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmphilo9q9x_test.go:66:\
    \ expected 'cmxciv', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmphilo9q9x_test.go:66: expected 'm', got 'v'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075668
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        50000: \"viv\",\n        100000: \"vi\",\n\
    \        500000: \"vii\",\n        1000000: \"viii\",\n        5000000: \"viv\"\
    ,\n        10000000: \"vi\",\n        50000000: \"vii\",\n        100000000: \"\
    viii\",\n        500000000: \"viv\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vii\",\n        10000000000: \"viii\",\n        50000000000: \"viv\",\n  \
    \      100000000000: \"vi\",\n        500000000000: \"vii\",\n        1000000000000:\
    \ \"viii\",\n        5000000000000: \"viv\",\n        10000000000000: \"vi\",\n\
    \        50000000000000: \"vii\",\n        100000000000000: \"viii\",\n      \
    \  500000000000000: \"viv\",\n        1000000000000000: \"vi\",\n        5000000000000000:\
    \ \"vii\",\n        1000000000000000000: \"viii\",\n    }\n    roman_numeral :=\
    \ roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ed4qirk_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"IV\", \"V\"\
    , \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"\n\
    \    }\n    romanNumeralIndex := 0\n    romanNumeralIndex := romanNumeralIndex\
    \ + number/1000\n    romanNumeralIndex := romanNumeralIndex % len(romanNumerals)\n\
    \    return romanNumerals[romanNumeralIndex]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2en0_1zp_test.go:20:78: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwlijy91d_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        100000: \"vi\",\n        1000000: \"vi\",\n \
    \       10000000: \"vi\",\n        100000000: \"vi\",\n        1000000000: \"\
    vi\",\n        10000000000: \"vi\",\n        100000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        10000000000000: \"vi\",\n        100000000000000: \"vi\",\n\
    \        1000000000000000: \"vi\",\n        10000000000000000: \"vi\",\n     \
    \   1000000000000000000: \"vi\",\n    }\n    roman_numeral_string := \"\"\n  \
    \  for roman_numeral, numeral_string := range roman_numerals {\n        if number\
    \ >= roman_numeral {\n            roman_numeral_string = numeral_string\n    \
    \        break\n        }\n    }\n    return strings.ToLower(roman_numeral_string)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpje14d77d_test.go:50:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"c\"\n    case\
    \ 2000:\n        roman_number = \"d\"\n    case 5000:\n        roman_number =\
    \ \"l\"\n    case 10000:\n        roman_number = \"c\"\n    case 20000:\n    \
    \    roman_number = \"d\"\n    case 50000:\n        roman_number = \"l\"\n   \
    \ case 100000:\n        roman_number = \"c\"\n    case 200000:\n        roman_number\
    \ = \"d\"\n    case 500000:\n        roman_number = \"l\"\n    case 1000000:\n\
    \        roman_number = \"c\"\n    case 2000000:\n        roman_number = \"d\"\
    \n    case 5000000:\n        roman_number = \"l\"\n    case 10000000:\n      \
    \  roman_number = \"c\"\n    case 20000000:\n        roman_number = \"d\"\n  \
    \  case 50000000:\n        roman_number = \"l\"\n    case 100000000:\n       \
    \ roman_number = \"c\"\n    case 200000000:\n        roman_number = \"d\"\n  \
    \  case 500000000:\n        roman_number = \"l\"\n    case 1000000000:\n     \
    \   roman_number = \"c\"\n    case 2000000000:\n        roman_number = \"d\"\n\
    \    case 5000000000:\n        roman_number = \"l\"\n    case 10000000000:\n \
    \       roman_number = \"c\"\n    case 20000000000:\n        roman_number = \"\
    d\"\n    case 50000000000:\n        roman_number = \"l\"\n    case 100000000000:\n\
    \        roman_number = \"c\"\n    case 200000000000:\n        roman_number =\
    \ \"d\"\n    case 500000000000:\n        roman_number = \"l\"\n    case 1000000000000:\n\
    \        roman_number = \"c\"\n    case 2000000000000:\n        roman_number =\
    \ \"d\"\n    case 5000000000000:\n        roman_number = \"l\"\n    case 10000000000000:\n\
    \        roman_number = \"c\"\n    case 20000000000000:\n        roman_number\
    \ = \"d\"\n    case 50000000000000:\n        roman_number\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx2qjw8v0_test.go:103:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszcenp2e_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number := roman_numerals[number]\n\
    \    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiomvmrcm_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n    }\n\n    roman_number := number /\
    \ 1000\n    roman_number %= 1000\n\n    return roman_numerals[roman_number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpkn2cp4uw_test.go:87: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpkn2cp4uw_test.go:87: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpkn2cp4uw_test.go:87: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpkn2cp4uw_test.go:87: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpkn2cp4uw_test.go:87:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpkn2cp4uw_test.go:87: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpkn2cp4uw_test.go:87: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpkn2cp4uw_test.go:87: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpkn2cp4uw_test.go:87: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpkn2cp4uw_test.go:87: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpkn2cp4uw_test.go:87:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpkn2cp4uw_test.go:87: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpkn2cp4uw_test.go:87:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpkn2cp4uw_test.go:87: expected 'm', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075668
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n\
    \        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case\
    \ 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"VI\"\n   \
    \ case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\
    \n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num = \"\
    X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpko4pjie6_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwv13wfzz_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075665
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number >= number\
    \ {\n            break\n        }\n    }\n    if romanNumeral == \"\" {\n    \
    \    fmt.Println(\"No roman numeral for number\", number)\n    }\n    return romanNumerals[number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkjsjszs__test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiii\",\n        1000: \"viii\",\n        5000:\
    \ \"vii\",\n        10000: \"vi\",\n        100000: \"v\",\n        1000000: \"\
    iv\",\n        10000000: \"iv\",\n        100000000: \"iv\",\n        1000000000:\
    \ \"iv\",\n        10000000000: \"iv\",\n        100000000000: \"iv\",\n     \
    \   1000000000000: \"iv\",\n        10000000000000: \"iv\",\n        100000000000000:\
    \ \"iv\",\n        1000000000000000: \"iv\",\n        10000000000000000: \"iv\"\
    ,\n        100000000000000000: \"iv\",\n        1000000000000000000: \"iv\",\n\
    \    }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmn1j9skr_test.go:45:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszcenp2e_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"vii\",\n        100: \"\
    vi\",\n        500: \"viii\",\n        1000: \"viii\",\n        5000: \"viii\"\
    ,\n        10000: \"viii\",\n        50000: \"viii\",\n        100000: \"viii\"\
    ,\n        500000: \"viii\",\n        1000000: \"viii\",\n        5000000: \"\
    viii\",\n        10000000: \"viii\",\n        50000000: \"viii\",\n        100000000:\
    \ \"viii\",\n        500000000: \"viii\",\n        1000000000: \"viii\",\n   \
    \     5000000000: \"viii\",\n        10000000000: \"viii\",\n        50000000000:\
    \ \"viii\",\n        100000000000: \"viii\",\n        500000000000: \"viii\",\n\
    \        1000000000000: \"viii\",\n        5000000000000: \"viii\",\n        10000000000000:\
    \ \"viii\",\n        50000000000000: \"viii\",\n        100000000000000: \"viii\"\
    ,\n        500000000000000: \"viii\",\n        1000000000000000: \"viii\",\n \
    \       5000000000000000: \"viii\",\n        1000000000000000000: \"viii\",\n\
    \        50000000000000000: \"viii\",\n        10000000000000000000: \"viii\"\
    ,\n        5000000000000000000: \"viii\",\n        100000000000000000000: \"viii\"\
    ,\n        50000000000000000000: \"viii\",\n        1000000000000000000000: \"\
    viii\",\n        500000000000000000000: \"viii\",\n        10000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000: \"viii\",\n        100000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000: \"viii\",\n        1000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000: \"viii\",\n        10000000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000000: \"viii\",\n        100000000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000000: \"viii\",\n        1000000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000000: \"viii\",\n        10000000000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000000000: \"viii\",\n        100000000000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000000000: \"viii\",\n        1000000000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000000000: \"viii\",\n        10000000000000000000000000000000:\
    \ \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpao6sn4u7_test.go:78:43: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 400:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"m\"\n    default:\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    return roman_number\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\nInvalid input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmphl8zv81p_test.go:71: expected\
    \ 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n   \
    \     tmphl8zv81p_test.go:71: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmphl8zv81p_test.go:71: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmphl8zv81p_test.go:71: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmphl8zv81p_test.go:71: expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5\
    \ (0.00s)\n        tmphl8zv81p_test.go:71: expected 'i', got 'x'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmphl8zv81p_test.go:71: expected\
    \ 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n    \
    \    tmphl8zv81p_test.go:71: expected 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmphl8zv81p_test.go:71: expected 'xc', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmphl8zv81p_test.go:71: expected\
    \ 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n \
    \       tmphl8zv81p_test.go:71: expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmphl8zv81p_test.go:71: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmphl8zv81p_test.go:71:\
    \ expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075668
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhcjrxs_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\",\n        \"LXVIII\", \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\",\n        \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    ,\n        \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\",\n        \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\",\n        \"CX\", \"CXI\", \"CXII\", \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\",\n        \"CXIX\"\
    , \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\"\
    ,\n        \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\", \"CCXII\", \"CCXIII\", \"\
    CCXIV\", \"CCXV\",\n        \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \"\
    CCXX\", \"CCXXI\", \"CCXXII\",\n        \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"\
    CCXXVI\", \"CCXXVII\", \"CCXXV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6cfvm2cs_test.go:34:60: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuqg9dqn_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_num := \"\"\n    roman_num := fmt.Sprintf(\"\
    %c\", number % 10)\n    number /= 10\n    for number > 0 {\n        roman_num\
    \ += fmt.Sprintf(\"%c\", number % 10)\n        number /= 10\n    }\n    return\
    \ strings.ToLower(roman_num)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4sn76oye_test.go:23:15: no new variables on left side of :=

    /tmp/tmp4sn76oye_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075667
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\",\n        \"LXVIII\", \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\",\n        \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    ,\n        \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\",\n        \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\",\n        \"CX\", \"CXI\", \"CXII\", \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\",\n        \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    ,\n        \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\",\n        \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\"\
    , \"CXII\", \"CXIII\", \"CXIV\", \"CXV\",\n        \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1ts28cay_test.go:34:73: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075668
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyo631ndu_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"IV\", \"V\", \"IX\"\
    , \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MM\",\n\
    \        \"MMM\",\n    }\n    result := \"\"\n    for _, romanNum := range romans\
    \ {\n        result += \"M\"\n        if number >= romanNum {\n            number\
    \ -= romanNum\n            result += romans[romanNum]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm38m7uj1_test.go:26:22: invalid operation: number >= romanNum (mismatched
    types int and string)

    /tmp/tmpm38m7uj1_test.go:27:13: invalid operation: number -= romanNum (mismatched
    types int and string)

    /tmp/tmpm38m7uj1_test.go:28:30: invalid argument: index romanNum (variable of
    type string) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075668
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    ,\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8l8t_zot_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n    }\n\n    roman_number := roman_numerals[number]\n\
    \    if roman_number == \"\" {\n        fmt.Println(\"Error: number too large\"\
    )\n    }\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Error: number too large\nError: number too large\nError: number too large\n\
    Error: number too large\nError: number too large\nError: number too large\nError:\
    \ number too large\nError: number too large\nError: number too large\nError: number\
    \ too large\nError: number too large\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpduafcvws_test.go:88:\
    \ expected 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n\
    \        tmpduafcvws_test.go:88: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpduafcvws_test.go:88: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpduafcvws_test.go:88: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmpduafcvws_test.go:88: expected 'd', got 'viv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpduafcvws_test.go:88: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpduafcvws_test.go:88: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpduafcvws_test.go:88: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpduafcvws_test.go:88: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpduafcvws_test.go:88:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpduafcvws_test.go:88: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpduafcvws_test.go:88:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpduafcvws_test.go:88: expected 'm', got 'vi'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075669
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n    romanNumeralsString :=\
    \ \"\"\n    for romanNumeral, roman := range romanNumerals {\n        if number\
    \ >= romanNumeral {\n            romanNumeralsString += roman\n            number\
    \ -= romanNumeral\n        }\n    }\n    return romanNumeralsString\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpzgtivxjy_test.go:64: expected 'xix', got 'ivil'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpzgtivxjy_test.go:64:\
    \ expected 'clii', got 'villi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpzgtivxjy_test.go:64: expected 'ccli', got 'lcivil'\n   \
    \ --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpzgtivxjy_test.go:64:\
    \ expected 'cdxxvi', got 'ivillc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpzgtivxjy_test.go:64: expected 'd', got 'villci'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpzgtivxjy_test.go:64:\
    \ expected 'iv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n\
    \        tmpzgtivxjy_test.go:64: expected 'xliii', got 'ivil'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpzgtivxjy_test.go:64: expected 'xc', got 'ivill'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpzgtivxjy_test.go:64:\
    \ expected 'xciv', got 'villi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpzgtivxjy_test.go:64: expected 'dxxxii', got 'civil'\n  \
    \  --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpzgtivxjy_test.go:64:\
    \ expected 'cm', got 'ivillcc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpzgtivxjy_test.go:64: expected 'cmxciv', got 'ivillcc'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpzgtivxjy_test.go:64:\
    \ expected 'm', got 'ivillcc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075669
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \    }\n    roman_numeral := roman_numerals[number]\n    if number == 0 {\n  \
    \      return \"\"\n    }\n    mini_roman_numeral := \"\"\n    for _, char :=\
    \ range roman_numeral {\n        mini_roman_numeral += char\n    }\n    return\
    \ mini_roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpig13jxk0_test.go:35:9: invalid operation: mini_roman_numeral += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075668
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\",\n    }\n    result := \"\"\n    for _, romanIndex := range\
    \ romans {\n        result += romanIndex\n        if number >= romanIndex {\n\
    \            number -= romanIndex\n        }\n    }\n    return strings.ToLower(result)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcdl_a_2h_test.go:27:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmpcdl_a_2h_test.go:28:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmpcdl_a_2h_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"mi\"\n    case 7:\n        roman_number = \"i\"\n    case 8:\n        roman_number\
    \ = \"vi\"\n    case 9:\n        roman_number = \"vix\"\n    case 10:\n      \
    \  roman_number = \"lx\"\n    case 11:\n        roman_number = \"ixl\"\n    case\
    \ 12:\n        roman_number = \"cxl\"\n    case 13:\n        roman_number = \"\
    dx\"\n    case 14:\n        roman_number = \"ixd\"\n    case 15:\n        roman_number\
    \ = \"clx\"\n    case 16:\n        roman_number = \"dxc\"\n    case 17:\n    \
    \    roman_number = \"ixc\"\n    case 18:\n        roman_number = \"cll\"\n  \
    \  case 19:\n        roman_number = \"dl\"\n    case 20:\n        roman_number\
    \ = \"i\"\n    case 21:\n        roman_number = \"vi\"\n    case 22:\n       \
    \ roman_number = \"vii\"\n    case 23:\n        roman_number = \"li\"\n    case\
    \ 24:\n        roman_number = \"ci\"\n    case 25:\n        roman_number = \"\
    di\"\n    case 26:\n        roman_number = \"vii\"\n    case 27:\n        roman_number\
    \ = \"li\"\n    case 28:\n        roman_number = \"ci\"\n    case 29:\n      \
    \  roman_number = \"di\"\n    case 30:\n        roman_number = \"vi\"\n    case\
    \ 31:\n        roman_number = \"vii\"\n    case 32:\n        roman_number = \"\
    li\"\n    case 33:\n        roman_number = \"ci\"\n    case 34:\n        roman_number\
    \ = \"di\"\n    case 35:\n        roman_number = \"vii\"\n    case 36:\n     \
    \   roman_number = \"li\"\n    case 37:\n        roman_number = \"ci\"\n    case\
    \ 38:\n        roman_number = \"di\"\n    case 39:\n        roman_number = \"\
    vi\"\n    case 40:\n        roman_number = \"vii\"\n    case 41:\n        roman_number\
    \ = \"li\"\n    case 42:\n        roman_number = \"ci\"\n    case 43:\n      \
    \  roman_number = \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4h1wow_p_test.go:106:24: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075668
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_5nfdwfy_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \      50000000000000000: \"viiv\",\n        10000000000000000000: \"viv\",\n\
    \        5000000000000000000: \"viiv\",\n        100000000000000000000: \"viv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viv\",\n    }\n    romanNumerals := map[int]string{\n        1: \"i\",\n \
    \       5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100:\
    \ \"viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpox6i_pag_test.go:84:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075668
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppsq4yepq_test.go:34:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    result := \"\"\n    for num,\
    \ res := range romans {\n        if number >= num {\n            result += res\n\
    \            number -= num\n        }\n    }\n    if number > 0 {\n        result\
    \ += romans[number]\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpcre8dcxv_test.go:67: expected 'xix', got 'livi'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpcre8dcxv_test.go:67:\
    \ expected 'clii', got 'ivill'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpcre8dcxv_test.go:67: expected 'ccli', got 'llcivi'\n   \
    \ --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpcre8dcxv_test.go:67:\
    \ expected 'cdxxvi', got 'ivillc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpcre8dcxv_test.go:67: expected 'd', got 'civill'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpcre8dcxv_test.go:67:\
    \ expected 'iv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n\
    \        tmpcre8dcxv_test.go:67: expected 'xliii', got 'vili'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpcre8dcxv_test.go:67: expected 'xc', got 'llivi'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpcre8dcxv_test.go:67:\
    \ expected 'xciv', got 'ivill'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpcre8dcxv_test.go:67: expected 'dxxxii', got 'ivillc'\n \
    \   --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpcre8dcxv_test.go:67:\
    \ expected 'cm', got 'civillc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpcre8dcxv_test.go:67: expected 'cmxciv', got 'villcci'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpcre8dcxv_test.go:67:\
    \ expected 'm', got 'villcci'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075669
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n    }\n\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpolqkrkqr_test.go:56:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp71f63gr_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        100000: \"vi\",\n        1000000: \"vi\",\n \
    \       10000000: \"vi\",\n        100000000: \"vi\",\n        1000000000: \"\
    vi\",\n        10000000000: \"vi\",\n        100000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        10000000000000: \"vi\",\n        100000000000000: \"vi\",\n\
    \        1000000000000000: \"vi\",\n        10000000000000000: \"vi\",\n     \
    \   1000000000000000000: \"vi\",\n    }\n    romanNumerals[1000] = \"v\"\n   \
    \ romanNumerals[5000] = \"v\"\n    romanNumerals[10000] = \"v\"\n    romanNumerals[100000]\
    \ = \"v\"\n    romanNumerals[1000000] = \"v\"\n    romanNumerals[10000000] = \"\
    v\"\n    romanNumerals[100000000] = \"v\"\n    romanNumerals[1000000000] = \"\
    v\"\n    romanNumerals[10000000000] = \"v\"\n    romanNumerals[100000000000] =\
    \ \"v\"\n    romanNumerals[1000000000000] = \"v\"\n    romanNumerals[10000000000000]\
    \ = \"v\"\n    romanNumerals[100000000000000] = \"v\"\n    romanNumerals[1000000000000000]\
    \ = \"v\"\n    romanNumerals[10000000000000000] = \"v\"\n    romanNumerals[100000000000000000]\
    \ = \"v\"\n    romanNumerals[1000000000000000000] = \"v\"\n    romanNumerals[10000000000000000000]\
    \ = \"v\"\n\n    romanNumerals[500] = \"vi\"\n    romanNumerals[100] = \"vii\"\
    \n    romanNumerals[5000] = \"viii\"\n    romanNumerals[10000] = \"viii\"\n  \
    \  romanNumerals[100000] = \"viii\"\n    romanNumerals[1000000] = \"viii\"\n \
    \   romanNumerals[10000000] = \"viii\"\n    romanNumerals[100000000] = \"viii\"\
    \n    romanNumerals[1000000000] = \"viii\"\n    romanNumerals[100\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1gon7oc9_test.go:71:22: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075668
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n   \
    \     \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\",\n        \"CCVII\"\
    , \"CCV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp50v6obyd_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        50000: \"viv\",\n        100000: \"vi\",\n\
    \        500000: \"vii\",\n        1000000: \"viii\",\n        5000000: \"viv\"\
    ,\n        10000000: \"vi\",\n        50000000: \"vii\",\n        100000000: \"\
    viii\",\n        500000000: \"viv\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vii\",\n        10000000000: \"viii\",\n        50000000000: \"viv\",\n  \
    \      100000000000: \"vi\",\n        500000000000: \"vii\",\n        1000000000000:\
    \ \"viii\",\n        5000000000000: \"viv\",\n        10000000000000: \"vi\",\n\
    \        50000000000000: \"vii\",\n        100000000000000: \"viii\",\n      \
    \  500000000000000: \"viv\",\n        1000000000000000: \"vi\",\n        5000000000000000:\
    \ \"vii\",\n        1000000000000000000: \"viii\",\n    }\n    roman_number :=\
    \ roman_numerals[number]\n    return strings.ToLower(roman_number)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0ln_ko42_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    mini_roman_numeral := \"\"\n    for _, char := range roman_numeral {\n  \
    \      mini_roman_numeral += char\n    }\n    return mini_roman_numeral\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuvgumd0v_test.go:31:9: invalid operation: mini_roman_numeral += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    result\
    \ := \"\"\n    for number > 0 {\n        result := romans[number%100] + result\n\
    \        number /= 100\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprqot77n4_test.go:31:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp2pij8dq5_test.go:61: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp2pij8dq5_test.go:61: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp2pij8dq5_test.go:61: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp2pij8dq5_test.go:61: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp2pij8dq5_test.go:61: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    ix\",\n        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprv6ttaer_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000: \"\
    c\",\n        50000: \"c\",\n        100000: \"x\",\n        500000: \"x\",\n\
    \        1000000: \"ix\",\n        5000000: \"ix\",\n        10000000: \"v\",\n\
    \        50000000: \"v\",\n        100000000: \"iv\",\n        500000000: \"iv\"\
    ,\n        1000000000: \"v\",\n        5000000000: \"v\",\n        10000000000:\
    \ \"iv\",\n        50000000000: \"iv\",\n        100000000000: \"v\",\n      \
    \  500000000000: \"v\",\n        1000000000000: \"iv\",\n        5000000000000:\
    \ \"iv\",\n        10000000000000: \"v\",\n        50000000000000: \"v\",\n  \
    \      100000000000000: \"iv\",\n        500000000000000: \"iv\",\n        1000000000000000:\
    \ \"v\",\n        5000000000000000: \"v\",\n        1000000000000000000: \"i\"\
    ,\n        50000000000000000: \"i\",\n        10000000000000000000: \"i\",\n \
    \       5000000000000000000: \"i\",\n        100000000000000000000: \"i\",\n \
    \       50000000000000000000: \"i\",\n        1000000000000000000000: \"i\",\n\
    \        500000000000000000000: \"i\",\n        10000000000000000000000: \"i\"\
    ,\n        5000000000000000000000: \"i\",\n        100000000000000000000000: \"\
    i\",\n        50000000000000000000000: \"i\",\n        1000000000000000000000000:\
    \ \"i\",\n        500000000000000000000000: \"i\",\n        10000000000000000000000000:\
    \ \"i\",\n        5000000000000000000000000: \"i\",\n        100000000000000000000000000:\
    \ \"i\",\n        50000000000000000000000000: \"i\",\n        1000000000000000000000000000:\
    \ \"i\",\n        500000000000000000000000000: \"i\",\n        10000000000000000000000000000:\
    \ \"i\",\n        5000000000000000000000000000: \"i\",\n        100000000000000000000000000000:\
    \ \"i\",\n        50000000000000000000000000000: \"i\",\n        1000000000000000000000000000000:\
    \ \"i\",\n        500000000000000000000000000000: \"i\",\n        10000000000000000000000000000000:\
    \ \"i\",\n        5000000000000000000000000000000: \"i\",\n        100000000000000000000000000000000:\
    \ \"i\",\n        50000000000000000000000000000000: \"i\",\n        1000000000000000000000000000000000:\
    \ \"i\",\n        500000000000000000000000000000000: \"i\",\n        10000000000000000000000000000000000:\
    \ \"i\",\n        5000000000000000000000000000000000: \"i\",\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptl5i56u2_test.go:86:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiiiix\",\n        1000: \"viiiiiix\",\n      \
    \  5000: \"viiiiiiix\",\n        10000: \"viiiiiiiix\",\n        50000: \"viiiiiiiiix\"\
    ,\n        100000: \"viiiiiiiiiix\",\n        500000: \"viiiiiiiiiiix\",\n   \
    \     1000000: \"viiiiiiiiiiiix\",\n        5000000: \"viiiiiiiiiiiiix\",\n  \
    \      10000000: \"viiiiiiiiiiiiiix\",\n        50000000: \"viiiiiiiiiiiiiiix\"\
    ,\n        100000000: \"viiiiiiiiiiiiiiiix\",\n        500000000: \"viiiiiiiiiiiiiiiiix\"\
    ,\n        1000000000: \"viiiiiiiiiiiiiiiiiix\",\n        5000000000: \"viiiiiiiiiiiiiiiiiiix\"\
    ,\n        10000000000: \"viiiiiiiiiiiiiiiiiiiix\",\n        50000000000: \"viiiiiiiiiiiiiiiiiiiiix\"\
    ,\n        100000000000: \"viiiiiiiiiiiiiiiiiiiiiix\",\n        500000000000:\
    \ \"viiiiiiiiiiiiiiiiiiiiiiiiix\",\n        1000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiix\"\
    ,\n        5000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiix\",\n        10000000000000:\
    \ \"viiiiiiiiiiiiiiiiiiiiiiiiiiiix\",\n        50000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiix\"\
    ,\n        100000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiiix\",\n        500000000000000:\
    \ \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiix\",\n        1000000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiix\"\
    ,\n        5000000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiix\",\n      \
    \  1000000000000000000: \"viiiiiiiiiiiiiii\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe55vuhko_test.go:52:30: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    int_to_mini_roman: number must be between 1 and 1000\")\n        return \"\"\n\
    \    }\n\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIIII\"\
    , \"LIIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"CV\", \"CVI\", \"\
    CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"\
    CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\",\
    \ \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CX\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_xa83ddm_test.go:25:1083: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n        50000000000000000: \"vi\",\n\
    \        10000000000000000000: \"vi\",\n        5000000000000000000: \"vi\",\n\
    \        100000000000000000000: \"vi\",\n        50000000000000000000: \"vi\"\
    ,\n        1000000000000000000000: \"vi\",\n        500000000000000000000: \"\
    vi\",\n        10000000000000000000000: \"vi\",\n        5000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000: \"vi\",\n        50000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000: \"vi\",\n        500000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000: \"vi\",\n        5000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000: \"vi\",\n        50000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000: \"vi\",\n        500000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000: \"vi\",\n        5000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000: \"vi\",\n        50000000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000000: \"vi\",\n        500000000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000000: \"vi\",\n        5000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        50000000000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000000000: \"vi\",\n        500000000000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000000000\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeskgaofy_test.go:84:44: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n        1000000: \"viv\"\
    ,\n        10000000: \"viii\",\n        100000000: \"viv\",\n        1000000000:\
    \ \"viv\",\n        10000000000: \"viii\",\n        100000000000: \"viv\",\n \
    \       1000000000000: \"viv\",\n        10000000000000: \"viii\",\n        100000000000000:\
    \ \"viv\",\n        1000000000000000: \"viv\",\n        10000000000000000: \"\
    viii\",\n        100000000000000000: \"viv\",\n        1000000000000000000: \"\
    vi\",\n    }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv9955ao2_test.go:45:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := []string{\"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\"\
    , \"LIIII\", \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\"\
    , \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"\
    CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdoeza35g_test.go:22:1135: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp0l3zxi9x_test.go:62: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp0l3zxi9x_test.go:62: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp0l3zxi9x_test.go:62:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp0l3zxi9x_test.go:62: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp0l3zxi9x_test.go:62: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp0l3zxi9x_test.go:62: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp0l3zxi9x_test.go:62:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp0l3zxi9x_test.go:62: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"m\"\n    default:\n\
    \        fmt.Println(\"Error: number too large\")\n    }\n    return roman_number\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Error: number too large\nError: number too large\nError: number too large\n\
    Error: number too large\nError: number too large\nError: number too large\nError:\
    \ number too large\nError: number too large\nError: number too large\nError: number\
    \ too large\nError: number too large\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpbg_0wwp1_test.go:71:\
    \ expected 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n\
    \        tmpbg_0wwp1_test.go:71: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpbg_0wwp1_test.go:71: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpbg_0wwp1_test.go:71: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmpbg_0wwp1_test.go:71: expected 'd', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5\
    \ (0.00s)\n        tmpbg_0wwp1_test.go:71: expected 'i', got 'x'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpbg_0wwp1_test.go:71: expected\
    \ 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n    \
    \    tmpbg_0wwp1_test.go:71: expected 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpbg_0wwp1_test.go:71: expected 'xc', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpbg_0wwp1_test.go:71: expected\
    \ 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n \
    \       tmpbg_0wwp1_test.go:71: expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpbg_0wwp1_test.go:71: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpbg_0wwp1_test.go:71:\
    \ expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\",\n    \
    \    \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\"\
    , \"LXXV\",\n        \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\",\
    \ \"LXXXI\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\",\n        \"CI\", \"CIX\"\
    , \"CXX\", \"CXXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\",\n \
    \       \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXXI\", \"CXXXII\",\
    \ \"CXXXIII\", \"CXXXIV\",\n        \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\",\n        \"CCIII\", \"CCIV\", \"CCV\"\
    , \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCL\", \"L\",\n        \"LII\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    ,\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\",\n        \"LXX\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc4ys5wue_test.go:34:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    result\
    \ := \"\"\n    for _, romanNum := range romans {\n        if number >= romanNum\
    \ {\n            result += romans[romanNum]\n            number -= romanNum\n\
    \        }\n    }\n    if number > 0 {\n        result += romans[number]\n   \
    \ }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpct8wwavu_test.go:31:22: invalid operation: number >= romanNum (mismatched
    types int and string)

    /tmp/tmpct8wwavu_test.go:32:30: cannot use romanNum (variable of type string)
    as type int in map index

    /tmp/tmpct8wwavu_test.go:33:13: invalid operation: number -= romanNum (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number >= number\
    \ {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\", romanNumeral,\
    \ number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsau_j3cw_test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\",\n   \
    \     10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\",\n  \
    \      500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \      50000000000000000: \"viiv\",\n        10000000000000000000: \"viv\",\n\
    \        5000000000000000000: \"viiv\",\n        100000000000000000000: \"viv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000: \"viiv\",\n        100000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000: \"viiv\",\n        1000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000: \"viiv\",\n        10000000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000000: \"viiv\",\n        100000000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000000: \"viiv\",\n        1000000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000000: \"viiv\",\n        10000000000000000000000000000000:\
    \ \"vi\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3t2lx36x_test.go:78:43: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := \"\"\n\
    \    for roman_numeral, number := range roman_numerals {\n        if number >=\
    \ number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%s\"\
    , roman_numerals[number], int_to_roman(number))\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq09nhc2e_test.go:28:5: roman_numeral declared but not used

    /tmp/tmpq09nhc2e_test.go:29:9: roman_numeral declared but not used

    /tmp/tmpq09nhc2e_test.go:34:56: undefined: int_to_roman

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\",\n        \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\",\n        \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\",\n        \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIIII\", \"LIIV\",\n        \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"\
    LXV\",\n        \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\",\
    \ \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\",\n        \"LXXVI\", \"LXXVII\",\
    \ \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\"\
    ,\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\"\
    , \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\",\n        \"CIV\", \"CV\", \"CVI\"\
    , \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\",\n        \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\",\n        \"CXXVI\", \"CXXVII\",\
    \ \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    ,\n        \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\",\n        \"CCV\", \"CCVI\", \"\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnhlhavam_test.go:32:24: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx08g12wb_test.go:34:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 2:\n        roman_num = \"ix\"\n    case 3:\n\
    \        roman_num = \"lb\"\n    case 4:\n        roman_num = \"c\"\n    case\
    \ 5:\n        roman_num = \"d\"\n    case 6:\n        roman_num = \"mi\"\n   \
    \ case 7:\n        roman_num = \"f\"\n    case 8:\n        roman_num = \"v\"\n\
    \    case 9:\n        roman_num = \"x\"\n    case 10:\n        roman_num = \"\
    c\"\n    case 11:\n        roman_num = \"d\"\n    case 12:\n        roman_num\
    \ = \"mi\"\n    case 13:\n        roman_num = \"f\"\n    case 14:\n        roman_num\
    \ = \"v\"\n    case 15:\n        roman_num = \"x\"\n    case 16:\n        roman_num\
    \ = \"c\"\n    case 17:\n        roman_num = \"d\"\n    case 18:\n        roman_num\
    \ = \"mi\"\n    case 19:\n        roman_num = \"f\"\n    case 20:\n        roman_num\
    \ = \"v\"\n    case 21:\n        roman_num = \"x\"\n    case 22:\n        roman_num\
    \ = \"c\"\n    case 23:\n        roman_num = \"d\"\n    case 24:\n        roman_num\
    \ = \"mi\"\n    case 25:\n        roman_num = \"f\"\n    case 26:\n        roman_num\
    \ = \"v\"\n    case 27:\n        roman_num = \"x\"\n    case 28:\n        roman_num\
    \ = \"c\"\n    case 29:\n        roman_num = \"d\"\n    case 30:\n        roman_num\
    \ = \"mi\"\n    case 31:\n        roman_num = \"f\"\n    case 32:\n        roman_num\
    \ = \"v\"\n    case 33:\n        roman_num = \"x\"\n    case 34:\n        roman_num\
    \ = \"c\"\n    case 35:\n        roman_num = \"d\"\n    case 36:\n        roman_num\
    \ = \"mi\"\n    case 37:\n        roman_num = \"f\"\n    case 38:\n        roman_num\
    \ = \"v\"\n    case 39:\n        roman_num = \"x\"\n    case 40:\n        roman_num\
    \ = \"c\"\n    case 41:\n        roman_num = \"d\"\n    case 42:\n        roman_num\
    \ = \"mi\"\n    case 43:\n        roman_num = \"f\"\n    case 44:\n        roman_num\
    \ = \"v\"\n    case 45:\n        roman_num = \"x\"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1fdkvs2f_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\",\
    \ \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"\
    LIIII\", \"LIIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", \"M\"\
    , \"MM\", \"MMM\", \"MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\"\
    , \"MMMMMMMMM\", \"MMMMMMMMMM\", \"MMMMMMMMMMM\", \"MMMMMMMMMMMM\", \"MMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMM\", \"\
    MMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"\
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"\
    MMMMMMMMMMMMMMMM\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_x745bwx_test.go:19:1433: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"m\"\n    default:\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    return roman_number\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmphzwhy8sw_test.go:71: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmphzwhy8sw_test.go:71: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmphzwhy8sw_test.go:71: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmphzwhy8sw_test.go:71: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmphzwhy8sw_test.go:71:\
    \ expected 'd', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmphzwhy8sw_test.go:71: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmphzwhy8sw_test.go:71: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmphzwhy8sw_test.go:71: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmphzwhy8sw_test.go:71: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmphzwhy8sw_test.go:71: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmphzwhy8sw_test.go:71:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmphzwhy8sw_test.go:71: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmphzwhy8sw_test.go:71:\
    \ expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075671
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    result := \"\"\n    for _, romanNum\
    \ := range romans {\n        if number >= romanNum {\n            result += romans[romanNum]\n\
    \            number -= romanNum\n        }\n    }\n    return strings.ToLower(result)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp11pz2hxt_test.go:30:22: invalid operation: number >= romanNum (mismatched
    types int and string)

    /tmp/tmp11pz2hxt_test.go:31:30: cannot use romanNum (variable of type string)
    as type int in map index

    /tmp/tmp11pz2hxt_test.go:32:13: invalid operation: number -= romanNum (mismatched
    types int and string)

    /tmp/tmp11pz2hxt_test.go:35:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 2:\n        roman_num = \"ix\"\n    case 3:\n\
    \        roman_num = \"lb\"\n    case 4:\n        roman_num = \"c\"\n    case\
    \ 5:\n        roman_num = \"d\"\n    case 6:\n        roman_num = \"mi\"\n   \
    \ case 7:\n        roman_num = \"f\"\n    case 8:\n        roman_num = \"v\"\n\
    \    case 9:\n        roman_num = \"x\"\n    case 10:\n        roman_num = \"\
    c\"\n    case 11:\n        roman_num = \"d\"\n    case 12:\n        roman_num\
    \ = \"mi\"\n    case 13:\n        roman_num = \"f\"\n    case 14:\n        roman_num\
    \ = \"v\"\n    case 15:\n        roman_num = \"x\"\n    case 16:\n        roman_num\
    \ = \"c\"\n    case 17:\n        roman_num = \"d\"\n    case 18:\n        roman_num\
    \ = \"mi\"\n    case 19:\n        roman_num = \"f\"\n    case 20:\n        roman_num\
    \ = \"v\"\n    case 21:\n        roman_num = \"x\"\n    case 22:\n        roman_num\
    \ = \"c\"\n    case 23:\n        roman_num = \"d\"\n    case 24:\n        roman_num\
    \ = \"mi\"\n    case 25:\n        roman_num = \"f\"\n    case 26:\n        roman_num\
    \ = \"v\"\n    case 27:\n        roman_num = \"x\"\n    case 28:\n        roman_num\
    \ = \"c\"\n    case 29:\n        roman_num = \"d\"\n    case 30:\n        roman_num\
    \ = \"mi\"\n    case 31:\n        roman_num = \"f\"\n    case 32:\n        roman_num\
    \ = \"v\"\n    case 33:\n        roman_num = \"x\"\n    case 34:\n        roman_num\
    \ = \"c\"\n    case 35:\n        roman_num = \"d\"\n    case 36:\n        roman_num\
    \ = \"mi\"\n    case 37:\n        roman_num = \"f\"\n    case 38:\n        roman_num\
    \ = \"v\"\n    case 39:\n        roman_num = \"x\"\n    case 40:\n        roman_num\
    \ = \"c\"\n    case 41:\n        roman_num = \"d\"\n    case 42:\n        roman_num\
    \ = \"mi\"\n    case 43:\n        roman_num = \"f\"\n    case 44:\n        roman_num\
    \ = \"v\"\n    case 45:\n        roman_num = \"x\"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1fdkvs2f_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    roman_number += int_to_roman(number)\n\
    \    roman_number += int_to_roman(number / 10)\n    roman_number += int_to_roman(number\
    \ / 100)\n    roman_number += int_to_roman(number / 1000)\n    return roman_number\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi81m1_sx_test.go:20:21: undefined: int_to_roman

    /tmp/tmpi81m1_sx_test.go:21:21: undefined: int_to_roman

    /tmp/tmpi81m1_sx_test.go:22:21: undefined: int_to_roman

    /tmp/tmpi81m1_sx_test.go:23:21: undefined: int_to_roman

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpryj9v5tx_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeralsInverse :=\
    \ map[string]int{\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n\
    \        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\":\
    \ 1000,\n    }\n    romanNumeralsInverse[\"\"] = 0\n    romanNumeralsInverse[\"\
    I\"] = 1\n    romanNumeralsInverse[\"V\"] = 5\n    romanNumeralsInverse[\"X\"\
    ] = 10\n    romanNumeralsInverse[\"L\"] = 50\n    romanNumeralsInverse[\"C\"]\
    \ = 100\n    romanNumeralsInverse[\"D\"] = 500\n    romanNumeralsInverse[\"M\"\
    ] = 1000\n\n    romanNumeral := \"\"\n    for numDigit := 0; numDigit < number;\
    \ numDigit++ {\n        romanNumeral += romanNumerals[number % 10]\n        number\
    \ /= 10\n    }\n    return romanNumeralsInverse[romanNumeral]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeidac0g8_test.go:51:12: cannot use romanNumeralsInverse[romanNumeral]
    (map index expression of type int) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, numeral := range romanNumerals {\n        if number >=\
    \ romanNumerals[numeral] {\n            break\n        }\n    }\n    return romanNumeral\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzk_pod2x_test.go:29:9: romanNumeral declared but not used

    /tmp/tmpzk_pod2x_test.go:30:22: invalid operation: number >= romanNumerals[numeral]
    (mismatched types int and string)

    /tmp/tmpzk_pod2x_test.go:30:36: cannot use numeral (variable of type string) as
    type int in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"mi\"\n    case 7:\n        roman_number = \"f\"\n    case 8:\n        roman_number\
    \ = \"v\"\n    case 9:\n        roman_number = \"x\"\n    case 10:\n        roman_number\
    \ = \"c\"\n    case 11:\n        roman_number = \"d\"\n    case 12:\n        roman_number\
    \ = \"mi\"\n    case 13:\n        roman_number = \"f\"\n    case 14:\n       \
    \ roman_number = \"v\"\n    case 15:\n        roman_number = \"x\"\n    case 16:\n\
    \        roman_number = \"c\"\n    case 17:\n        roman_number = \"d\"\n  \
    \  case 18:\n        roman_number = \"mi\"\n    case 19:\n        roman_number\
    \ = \"f\"\n    case 20:\n        roman_number = \"v\"\n    case 21:\n        roman_number\
    \ = \"x\"\n    case 22:\n        roman_number = \"c\"\n    case 23:\n        roman_number\
    \ = \"d\"\n    case 24:\n        roman_number = \"mi\"\n    case 25:\n       \
    \ roman_number = \"f\"\n    case 26:\n        roman_number = \"v\"\n    case 27:\n\
    \        roman_number = \"x\"\n    case 28:\n        roman_number = \"c\"\n  \
    \  case 29:\n        roman_number = \"d\"\n    case 30:\n        roman_number\
    \ = \"mi\"\n    case 31:\n        roman_number = \"f\"\n    case 32:\n       \
    \ roman_number = \"v\"\n    case 33:\n        roman_number = \"x\"\n    case 34:\n\
    \        roman_number = \"c\"\n    case 35:\n        roman_number = \"d\"\n  \
    \  case 36:\n        roman_number = \"mi\"\n    case 37:\n        roman_number\
    \ = \"f\"\n    case 38:\n        roman_number = \"v\"\n    case 39:\n        roman_number\
    \ = \"x\"\n    case 40:\n        roman_number = \"c\"\n    case 41:\n        roman_number\
    \ = \"d\"\n    case 42:\n        roman_number = \"mi\"\n    case 43:\n       \
    \ roman_number = \"f\"\n    case 44:\n        roman_number = \"v\"\n    case 45:\n\
    \        roman_number = \"x\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnlviqury_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viivi\",\n        100:\
    \ \"viiviii\",\n        500: \"viiviivi\",\n        1000: \"viiviiviii\",\n  \
    \  }\n    roman_numeral_string := \"\"\n    for roman_numeral, roman_numeral_string\
    \ := range roman_numerals {\n        if number >= roman_numeral {\n          \
    \  break\n        }\n    }\n    return roman_numeral_string\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxc9zsvjq_test.go:29:24: roman_numeral_string declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    romanNumeral = strings.ToLower(romanNumeral)\n    return romanNumeral\n}\n\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp77x01bm7_test.go:29:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000:\
    \ \"c\",\n        50000: \"c\",\n        100000: \"x\",\n        500000: \"x\"\
    ,\n        1000000: \"ix\",\n        5000000: \"ix\",\n        10000000: \"iv\"\
    ,\n        50000000: \"iv\",\n        100000000: \"v\",\n        500000000: \"\
    v\",\n        1000000000: \"vi\",\n        5000000000: \"vi\",\n        10000000000:\
    \ \"vi\",\n        50000000000: \"vi\",\n        100000000000: \"vi\",\n     \
    \   500000000000: \"vi\",\n        1000000000000: \"vi\",\n        5000000000000:\
    \ \"vi\",\n        10000000000000: \"vi\",\n        50000000000000: \"vi\",\n\
    \        100000000000000: \"vi\",\n        500000000000000: \"vi\",\n        1000000000000000:\
    \ \"vi\",\n        5000000000000000: \"vi\",\n        1000000000000000000: \"\
    vi\",\n    }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpytu2stdd_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := []string{\"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\"\
    , \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"\
    LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\"\
    , \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"\
    CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CD\", \"CD\"\
    , \"CDI\", \"CDII\", \"CDIII\", \"CDIIII\", \"CDIIV\", \"CDIV\", \"CDIVI\", \"\
    CDIVII\", \"CDIVIII\", \"CDIIX\", \"CM\", \"CM\", \"CMI\", \"CMII\", \"CMIII\"\
    , \"CMIV\", \"CMV\", \"CMVI\", \"CMVII\", \"CMVIII\", \"CMIX\", \"M\", \"M\",\
    \ \"MI\", \"MII\", \"MIII\", \"MIIV\", \"MV\", \"MVI\", \"MVII\", \"MVIII\", \"\
    MIV\", \"MVI\", \"MVII\", \"MVIII\", \"MIX\", \"MXX\", \"MXXI\", \"MXXII\", \"\
    MXXIII\", \"MXXIV\", \"MXXV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9eqre7ao_test.go:22:1131: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    result := \"\"\n    for\
    \ number > 0 {\n        result += roman_numerals[number%10]\n        number /=\
    \ 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpxr6rb1pn_test.go:62: expected 'xix', got 'I'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpxr6rb1pn_test.go:62: expected\
    \ 'clii', got 'VI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n\
    \        tmpxr6rb1pn_test.go:62: expected 'ccli', got 'IV'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpxr6rb1pn_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpxr6rb1pn_test.go:62:\
    \ expected 'd', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpxr6rb1pn_test.go:62: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpxr6rb1pn_test.go:62: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpxr6rb1pn_test.go:62: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpxr6rb1pn_test.go:62: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpxr6rb1pn_test.go:62: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpxr6rb1pn_test.go:62:\
    \ expected 'dxxxii', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpxr6rb1pn_test.go:62: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpxr6rb1pn_test.go:62:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpxr6rb1pn_test.go:62: expected 'm', got 'I'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075671
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    10000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n   \
    \     1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n    }\n    roman_numeral_string\
    \ := \"\"\n    for roman_numeral, numeral_string := range roman_numerals {\n \
    \       if number >= roman_numeral {\n            roman_numeral_string = numeral_string\n\
    \            break\n        }\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu136giq7_test.go:76:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiiiix\",\n        1000: \"viiiiiix\",\n      \
    \  5000: \"viiiiiix\",\n        10000: \"viiiiiix\",\n        50000: \"viiiiiiix\"\
    ,\n        100000: \"viiiiiiix\",\n        500000: \"viiiiiiix\",\n        1000000:\
    \ \"viiiiiiix\",\n        5000000: \"viiiiiiix\",\n        10000000: \"viiiiiiix\"\
    ,\n        50000000: \"viiiiiiix\",\n        100000000: \"viiiiiiix\",\n     \
    \   500000000: \"viiiiiiix\",\n        1000000000: \"viiiiiiix\",\n        5000000000:\
    \ \"viiiiiiix\",\n        10000000000: \"viiiiiiix\",\n        50000000000: \"\
    viiiiiiix\",\n        100000000000: \"viiiiiiix\",\n        500000000000: \"viiiiiiix\"\
    ,\n        1000000000000: \"viiiiiiix\",\n        5000000000000: \"viiiiiiix\"\
    ,\n        10000000000000: \"viiiiiiix\",\n        50000000000000: \"viiiiiiix\"\
    ,\n        100000000000000: \"viiiiiiix\",\n        500000000000000: \"viiiiiiix\"\
    ,\n        1000000000000000: \"viiiiiiix\",\n        5000000000000000: \"viiiiiiix\"\
    ,\n        10000000000000000: \"viiiiiiix\",\n        5000000000000000: \"viiiiiiix\"\
    ,\n        100000000000000000: \"viiiiiiix\",\n        50000000000000000: \"viiiiiiix\"\
    ,\n        1000000000000000000: \"viiiiiiix\",\n        500000000000000000: \"\
    viiiiiiix\",\n        10000000000000000000: \"viiiiiiix\",\n        5000000000000000000:\
    \ \"viiiiiiix\",\n        100000000000000000000: \"viiiiiiix\",\n        50000000000000000000:\
    \ \"viiiiiiix\",\n        1000000000000000000000: \"viiiiiiix\",\n        500000000000000000000:\
    \ \"viiiiiiix\",\n        10000000000000000000000: \"viiiiiiix\",\n        5000000000000000000000:\
    \ \"viiiiiiix\",\n        \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr_h1_lfl_test.go:67:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := []string{\"M\", \"CM\", \"D\", \"CD\", \"\
    C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    roman_number\
    \ := roman_number[:number%100]\n    number /= 100\n    roman_number := append(roman_number,\
    \ []string{\"I\"}...)\n    roman_number := append(roman_number, []string{\"V\"\
    }...)\n    roman_number := append(roman_number, []string{\"X\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"L\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"C\"}...)\n    roman_number := append(roman_number, []string{\"D\"\
    }...)\n    roman_number := append(roman_number, []string{\"M\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"I\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"V\"}...)\n    roman_number := append(roman_number, []string{\"X\"\
    }...)\n    roman_number := append(roman_number, []string{\"L\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"C\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"D\"}...)\n    roman_number := append(roman_number, []string{\"M\"\
    }...)\n    roman_number := append(roman_number, []string{\"I\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"V\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"X\"}...)\n    roman_number := append(roman_number, []string{\"L\"\
    }...)\n    roman_number := append(roman_number, []string{\"C\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"D\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"M\"}...)\n    roman_number := append(roman_number, []string{\"I\"\
    }...)\n    roman_number := append(roman_number, []string{\"V\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"X\"}...)\n    roman_number := append(roman_number,\
    \ []string{\"L\"}...)\n    roman_number := append(roman_number, []string{\"C\"\
    }...)\n    roman_number := append(roman_number, []string{\"D\"}...)\n    roman_number\
    \ := append(roman_number, []string{\"M\"}...)\n    roman_number := append(roman_number,\
    \ \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9b0khd9l_test.go:51:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvi\",\n        100000: \"\
    vivvii\",\n        500000: \"viviv\",\n        1000000: \"vivivi\",\n        5000000:\
    \ \"vivivii\",\n        10000000: \"viviviii\",\n        50000000: \"viviivi\"\
    ,\n        100000000: \"viviivii\",\n        500000000: \"viviiivi\",\n      \
    \  1000000000: \"viviiivii\",\n        5000000000: \"vivivvi\",\n        10000000000:\
    \ \"vivivvii\",\n        50000000000: \"viviviv\",\n        100000000000: \"vivivivi\"\
    ,\n        500000000000: \"viviiviv\",\n        1000000000000: \"viviivivi\",\n\
    \        5000000000000: \"viviiiviv\",\n        10000000000000: \"viviiivivi\"\
    ,\n        50000000000000: \"vivivviv\",\n        100000000000000: \"vivivvivi\"\
    ,\n        500000000000000: \"viviviviv\",\n        1000000000000000: \"vivivivivi\"\
    ,\n        5000000000000000: \"viviiviviv\",\n        10000000000000000: \"viviivivivi\"\
    ,\n        5000000000000000: \"viviiivivi\",\n        10000000000000000: \"viviiivivi\"\
    ,\n        50000000000000000: \"vivivvivi\",\n        100000000000000000: \"vivivvivii\"\
    ,\n        500000000000000000: \"viviviviv\",\n        100000000000000000: \"\
    vivivivivi\",\n        50000000000000000: \"viviiviviv\",\n        100000000000000000:\
    \ \"viviivivivi\",\n        500000000000000000: \"viviiivivi\",\n        100000000000000000:\
    \ \"viviiivivi\",\n        5000000000000000000: \"vivivvivi\",\n        100000000000000000:\
    \ \"vivivvivii\",\n        50000000000000000000: \"viviviviv\",\n        100000000000000000:\
    \ \"vivivivivi\",\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjwsud_0v_test.go:67:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        100000: \"vi\",\n    }\n    mini_roman_numerals\
    \ := map[string]int{\n        \"i\": 1,\n        \"v\": 5,\n        \"vi\": 10,\n\
    \        \"vii\": 50,\n        \"viii\": 100,\n        \"viv\": 500,\n       \
    \ \"vivv\": 1000,\n        \"vivvi\": 10000,\n        \"vivvii\": 100000,\n  \
    \  }\n    if number < 1 || number > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    return roman_numerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzu2al8qp_test.go:31:5: mini_roman_numerals declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n    }\n    roman_number := \"\"\n    for roman_number,\
    \ number := range romans {\n        if number <= number {\n            break\n\
    \        }\n    }\n    return fmt.Sprintf(\"%s%v\", roman_number, number)\n}\n\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi8_7mxnl_test.go:31:9: roman_number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvii\",\n        100000: \"\
    vivviii\",\n        500000: \"viiviii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiiii\",\n        10000000: \"vivviii\",\n        50000000: \"\
    viviii\",\n        100000000: \"viviiii\",\n        500000000: \"viviiii\",\n\
    \        1000000000: \"viviv\",\n        5000000000: \"vivivi\",\n        10000000000:\
    \ \"vivivii\",\n        50000000000: \"viviviii\",\n        100000000000: \"viviviiii\"\
    ,\n        500000000000: \"viviviiii\",\n        1000000000000: \"viviviv\",\n\
    \        5000000000000: \"vivivivi\",\n        10000000000000: \"vivivivii\",\n\
    \        50000000000000: \"viviviviii\",\n        100000000000000: \"viviviviiii\"\
    ,\n        500000000000000: \"viviviviiii\",\n        1000000000000000: \"viviviviv\"\
    ,\n        5000000000000000: \"vivivivivi\",\n        10000000000000000: \"vivivivivii\"\
    ,\n        5000000000000000: \"viviviviviii\",\n        100000000000000000: \"\
    viviviviviiii\",\n        50000000000000000: \"viviviviviiii\",\n        1000000000000000000:\
    \ \"viviviviviv\",\n        500000000000000000: \"vivivivivivi\",\n        10000000000000000000:\
    \ \"vivivivivivii\",\n        5000000000000000000: \"viviviviviviii\",\n     \
    \   100000000000000000000: \"viviviviviviiii\",\n        50000000000000000000:\
    \ \"viviviviviviiii\",\n        1000000000000000000000: \"viviviviviviv\",\n \
    \       500000000000000000000: \"vivivivivivivi\",\n        10000000000000000000000:\
    \ \"vivivivivivivii\",\n        5000000000000000000000: \"vivivivivi\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphwgz8a_5_test.go:65:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"\
    I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100:\
    \ \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number :=\
    \ 0\n    for roman_number < number {\n        roman_number += roman_numerals[roman_number]\n\
    \    }\n    return string(roman_numerals[roman_number])\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1a7xqijj_test.go:33:9: invalid operation: roman_number += roman_numerals[roman_number]
    (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Println(\"Invalid input:\",\
    \ number)\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input: 19\nInvalid input: 152\nInvalid input: 251\nInvalid input:\
    \ 426\nInvalid input: 4\nInvalid input: 43\nInvalid input: 90\nInvalid input:\
    \ 94\nInvalid input: 532\nInvalid input: 900\nInvalid input: 994\n--- FAIL: TestInt_To_Mini_Roman\
    \ (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpksq7ma5m_test.go:62:\
    \ expected 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n\
    \        tmpksq7ma5m_test.go:62: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpksq7ma5m_test.go:62: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpksq7ma5m_test.go:62: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmpksq7ma5m_test.go:62: expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpksq7ma5m_test.go:62: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpksq7ma5m_test.go:62: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpksq7ma5m_test.go:62: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpksq7ma5m_test.go:62: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpksq7ma5m_test.go:62:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpksq7ma5m_test.go:62: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpksq7ma5m_test.go:62:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpksq7ma5m_test.go:62: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075672
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 50:\n        roman_number =\
    \ \"l\"\n    case 100:\n        roman_number = \"c\"\n    case 500:\n        roman_number\
    \ = \"d\"\n    case 1000:\n        roman_number = \"m\"\n    }\n    return roman_number\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp90p27_ny_test.go:65: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp90p27_ny_test.go:65: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp90p27_ny_test.go:65:\
    \ expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp90p27_ny_test.go:65: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp90p27_ny_test.go:65: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp90p27_ny_test.go:65: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp90p27_ny_test.go:65:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp90p27_ny_test.go:65: expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    result\
    \ := \"\"\n    for num, _ := range romans {\n        if number >= num {\n    \
    \        result += romans[num]\n            number -= num\n        }\n    }\n\
    \    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplrtp8tcm_test.go:36:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 2:\n        roman_num = \"ix\"\n    case 3:\n\
    \        roman_num = \"lb\"\n    case 4:\n        roman_num = \"cxl\"\n    case\
    \ 5:\n        roman_num = \"dx\"\n    case 6:\n        roman_num = \"ixl\"\n \
    \   case 7:\n        roman_num = \"xl\"\n    case 8:\n        roman_num = \"ixc\"\
    \n    case 9:\n        roman_num = \"xc\"\n    case 10:\n        roman_num = \"\
    ixix\"\n    case 11:\n        roman_num = \"xixl\"\n    case 12:\n        roman_num\
    \ = \"xlix\"\n    case 13:\n        roman_num = \"xixc\"\n    case 14:\n     \
    \   roman_num = \"xcix\"\n    case 15:\n        roman_num = \"xixix\"\n    case\
    \ 16:\n        roman_num = \"xvix\"\n    case 17:\n        roman_num = \"xixvi\"\
    \n    case 18:\n        roman_num = \"xvixc\"\n    case 19:\n        roman_num\
    \ = \"xixixl\"\n    case 20:\n        roman_num = \"xvixl\"\n    case 21:\n  \
    \      roman_num = \"xixvix\"\n    case 22:\n        roman_num = \"xvixix\"\n\
    \    case 23:\n        roman_num = \"xixvixl\"\n    case 24:\n        roman_num\
    \ = \"xvixlix\"\n    case 25:\n        roman_num = \"xixixl\"\n    case 26:\n\
    \        roman_num = \"xvixl\"\n    case 27:\n        roman_num = \"xixvix\"\n\
    \    case 28:\n        roman_num = \"xvixix\"\n    case 29:\n        roman_num\
    \ = \"xixvixl\"\n    case 30:\n        roman_num = \"xvixlix\"\n    case 31:\n\
    \        roman_num = \"xixixl\"\n    case 32:\n        roman_num = \"xvixl\"\n\
    \    case 33:\n        roman_num = \"xixvix\"\n    case 34:\n        roman_num\
    \ = \"xvixix\"\n    case 35:\n        roman_num = \"xixvixl\"\n    case 36:\n\
    \        roman_num = \"xvixlix\"\n    case 37:\n        roman_num = \"xixixl\"\
    \n    case 38\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp81fs2dq3_test.go:95:12: expected '':'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075671
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"m\"\n    }\n\
    \    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpecp52d3w_test.go:69: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpecp52d3w_test.go:69: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpecp52d3w_test.go:69:\
    \ expected 'd', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpecp52d3w_test.go:69: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpecp52d3w_test.go:69: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpecp52d3w_test.go:69: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpecp52d3w_test.go:69:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpecp52d3w_test.go:69:\
    \ expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\",\
    \ \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result\
    \ := \"\"\n    number -= 1 // Convert to 0-based index\n    for index, roman :=\
    \ range romans {\n        if number >= index {\n            result += roman\n\
    \            number -= index\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpt520i1x6_test.go:60: expected 'xix', got 'MCMDCDCXC'\n \
    \   --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpt520i1x6_test.go:60:\
    \ expected 'clii', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpt520i1x6_test.go:60: expected 'ccli', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpt520i1x6_test.go:60:\
    \ expected 'cdxxvi', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpt520i1x6_test.go:60: expected 'd', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpt520i1x6_test.go:60:\
    \ expected 'i', got 'M'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpt520i1x6_test.go:60: expected 'iv', got 'MCMD'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpt520i1x6_test.go:60: expected 'xliii', got 'MCMDCDCXCLXLX'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpt520i1x6_test.go:60:\
    \ expected 'xc', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpt520i1x6_test.go:60: expected 'xciv', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpt520i1x6_test.go:60:\
    \ expected 'dxxxii', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpt520i1x6_test.go:60: expected 'cm', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpt520i1x6_test.go:60:\
    \ expected 'cmxciv', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpt520i1x6_test.go:60: expected 'm', got 'MCMDCDCXCLXLXIXVIVI'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075672
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 5:\n        roman_num = \"v\"\n    case 10:\n\
    \        roman_num = \"i\"\n    case 50:\n        roman_num = \"l\"\n    case\
    \ 100:\n        roman_num = \"c\"\n    case 500:\n        roman_num = \"d\"\n\
    \    case 1000:\n        roman_num = \"m\"\n    }\n    return roman_num\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp0w7op89p_test.go:65: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp0w7op89p_test.go:65: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp0w7op89p_test.go:65: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp0w7op89p_test.go:65: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp0w7op89p_test.go:65:\
    \ expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp0w7op89p_test.go:65: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp0w7op89p_test.go:65: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp0w7op89p_test.go:65: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp0w7op89p_test.go:65: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp0w7op89p_test.go:65: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp0w7op89p_test.go:65:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp0w7op89p_test.go:65: expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075672
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number <= number\
    \ {\n            break\n        }\n    }\n\n    if romanNumeral == \"\" {\n  \
    \      fmt.Println(\"Error: no roman numeral for number\", number)\n    }\n\n\
    \    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1vmfseys_test.go:30:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viivi\",\n        100:\
    \ \"viiviii\",\n        500: \"viiviivi\",\n        1000: \"viiviiviii\",\n  \
    \  }\n    roman_numeral := roman_numerals[number]\n    mini_roman_numeral := \"\
    \"\n    for _, letter := range roman_numeral {\n        mini_roman_numeral +=\
    \ letter\n    }\n    return mini_roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfjqv3edc_test.go:31:9: invalid operation: mini_roman_numeral += letter
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"int_to_mini_roman: number out of range\"\
    )\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "int_to_mini_roman: number out of range\nint_to_mini_roman: number out of\
    \ range\nint_to_mini_roman: number out of range\nint_to_mini_roman: number out\
    \ of range\nint_to_mini_roman: number out of range\nint_to_mini_roman: number\
    \ out of range\nint_to_mini_roman: number out of range\nint_to_mini_roman: number\
    \ out of range\nint_to_mini_roman: number out of range\nint_to_mini_roman: number\
    \ out of range\nint_to_mini_roman: number out of range\n--- FAIL: TestInt_To_Mini_Roman\
    \ (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmplnk6vf4a_test.go:61:\
    \ expected 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n\
    \        tmplnk6vf4a_test.go:61: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmplnk6vf4a_test.go:61: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmplnk6vf4a_test.go:61: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmplnk6vf4a_test.go:61: expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmplnk6vf4a_test.go:61: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmplnk6vf4a_test.go:61: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmplnk6vf4a_test.go:61: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmplnk6vf4a_test.go:61: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmplnk6vf4a_test.go:61:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmplnk6vf4a_test.go:61: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmplnk6vf4a_test.go:61:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmplnk6vf4a_test.go:61: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075673
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXIII\",\n        \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\",\n        \"XXV\", \"XXVI\"\
    , \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\", \"XXV\",\n  \
    \      \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\"\
    , \"XXV\", \"XXVI\",\n        \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\",\n        \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\",\n        \"XXIX\"\
    , \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    ,\n        \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\",\n        \"XXIV\", \"XXV\", \"XXVI\"\
    , \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\",\n        \"XXV\"\
    , \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\", \"\
    XXV\",\n        \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\",\n        \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\",\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi6ucu308_test.go:35:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        50000: \"viv\",\n        100000: \"vi\",\n\
    \        500000: \"vii\",\n        1000000: \"viii\",\n        5000000: \"viv\"\
    ,\n        10000000: \"vi\",\n        50000000: \"vii\",\n        100000000: \"\
    viii\",\n        500000000: \"viv\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vii\",\n        10000000000: \"viii\",\n        50000000000: \"viv\",\n  \
    \      100000000000: \"vi\",\n        500000000000: \"vii\",\n        1000000000000:\
    \ \"viii\",\n        5000000000000: \"viv\",\n        10000000000000: \"vi\",\n\
    \        50000000000000: \"vii\",\n        100000000000000: \"viii\",\n      \
    \  500000000000000: \"viv\",\n        1000000000000000: \"vi\",\n        5000000000000000:\
    \ \"vii\",\n        1000000000000000000: \"viii\",\n    }\n\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number <= number {\n            break\n        }\n    }\n\n    if roman_numeral\
    \ == \"\" {\n        fmt.Println(\"Roman numeral not found\")\n    }\n\n    return\
    \ roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmyh3pfzx_test.go:56:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    romanIndex := 0\n\
    \    romanOutput := \"\"\n    romanOutput += romans[romanIndex]\n    for number\
    \ > 0 {\n        romanOutput += romans[romanIndex]\n        romanIndex++\n   \
    \     number -= romanIndex\n    }\n    return romanOutput\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: runtime error: index out\
    \ of range [13] with length 13 [recovered]\n\tpanic: runtime error: index out\
    \ of range [13] with length 13\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514640,\
    \ 0xc0000143a8})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514640, 0xc0000143a8})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.int_to_mini_roman(...)\n\t/tmp/tmpv63grovb_test.go:24\n\
    command-line-arguments_test.TestInt_To_Mini_Roman(0xc0001a01a0?)\n\t/tmp/tmpv63grovb_test.go:39\
    \ +0x2392\ntesting.tRunner(0xc0001a01a0, 0x529fa8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075673
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viivi\",\n        100:\
    \ \"viiii\",\n        500: \"viiivii\",\n        1000: \"viiiivi\",\n    }\n \
    \   roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk64mktl2_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"mi\"\n    case 7:\n        roman_number = \"f\"\n    case 8:\n        roman_number\
    \ = \"v\"\n    case 9:\n        roman_number = \"x\"\n    case 10:\n        roman_number\
    \ = \"c\"\n    case 11:\n        roman_number = \"d\"\n    case 12:\n        roman_number\
    \ = \"mi\"\n    case 13:\n        roman_number = \"f\"\n    case 14:\n       \
    \ roman_number = \"v\"\n    case 15:\n        roman_number = \"x\"\n    case 16:\n\
    \        roman_number = \"c\"\n    case 17:\n        roman_number = \"d\"\n  \
    \  case 18:\n        roman_number = \"mi\"\n    case 19:\n        roman_number\
    \ = \"f\"\n    case 20:\n        roman_number = \"v\"\n    case 21:\n        roman_number\
    \ = \"x\"\n    case 22:\n        roman_number = \"c\"\n    case 23:\n        roman_number\
    \ = \"d\"\n    case 24:\n        roman_number = \"mi\"\n    case 25:\n       \
    \ roman_number = \"f\"\n    case 26:\n        roman_number = \"v\"\n    case 27:\n\
    \        roman_number = \"x\"\n    case 28:\n        roman_number = \"c\"\n  \
    \  case 29:\n        roman_number = \"d\"\n    case 30:\n        roman_number\
    \ = \"mi\"\n    case 31:\n        roman_number = \"f\"\n    case 32:\n       \
    \ roman_number = \"v\"\n    case 33:\n        roman_number = \"x\"\n    case 34:\n\
    \        roman_number = \"c\"\n    case 35:\n        roman_number = \"d\"\n  \
    \  case 36:\n        roman_number = \"mi\"\n    case 37:\n        roman_number\
    \ = \"f\"\n    case 38:\n        roman_number = \"v\"\n    case 39:\n        roman_number\
    \ = \"x\"\n    case 40:\n        roman_number = \"c\"\n    case 41:\n        roman_number\
    \ = \"d\"\n    case 42:\n        roman_number = \"mi\"\n    case 43:\n       \
    \ roman_number = \"f\"\n    case 44:\n        roman_number = \"v\"\n    case 45:\n\
    \        roman_number = \"x\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnlviqury_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"IV\", \"V\"\
    , \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"\
    MM\",\n        \"MMM\",\n    }\n    roman_numeral_string := \"\"\n    for _, roman_numeral\
    \ := range roman_numerals {\n        if number >= roman_numeral {\n          \
    \  roman_numeral_string += roman_numeral\n            number -= roman_numeral\n\
    \        }\n    }\n    if number > 0 {\n        roman_numeral_string += fmt.Sprintf(\"\
    %v\", number)\n    }\n    return strings.ToLower(roman_numeral_string)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu7tpccnd_test.go:25:22: invalid operation: number >= roman_numeral (mismatched
    types int and string)

    /tmp/tmpu7tpccnd_test.go:27:13: invalid operation: number -= roman_numeral (mismatched
    types int and string)

    /tmp/tmpu7tpccnd_test.go:33:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := \"\"\n\
    \    for roman_numeral, number := range roman_numerals {\n        if number >=\
    \ number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\"\
    , roman_numeral, number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk7bkzrid_test.go:29:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp2pij8dq5_test.go:61: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp2pij8dq5_test.go:61: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp2pij8dq5_test.go:61: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp2pij8dq5_test.go:61: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp2pij8dq5_test.go:61: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    roman_number := \"\"\n    for\
    \ _, roman_number := range romans {\n        if number >= roman_number {\n   \
    \         break\n        }\n    }\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpraw3u613_test.go:30:22: invalid operation: number >= roman_number (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viiii\",\n        5000: \"viiiii\"\
    ,\n        10000: \"vivvi\",\n        50000: \"vivvii\",\n        100000: \"vivviii\"\
    ,\n        500000: \"vivviiii\",\n        1000000: \"vivviv\",\n        5000000:\
    \ \"vivvivi\",\n        10000000: \"vivvivii\",\n        50000000: \"vivviviii\"\
    ,\n        100000000: \"vivviviiii\",\n        500000000: \"vivviviiiii\",\n \
    \       1000000000: \"vivviviv\",\n        5000000000: \"vivvivivi\",\n      \
    \  10000000000: \"vivvivivii\",\n        50000000000: \"vivviviviii\",\n     \
    \   100000000000: \"vivviviviiii\",\n        500000000000: \"vivviviviiiii\",\n\
    \        1000000000000: \"vivviviviv\",\n        5000000000000: \"vivvivivivi\"\
    ,\n        10000000000000: \"vivvivivivii\",\n        50000000000000: \"vivviviviviii\"\
    ,\n        100000000000000: \"vivviviviviiii\",\n        500000000000000: \"vivviviviviiiii\"\
    ,\n        1000000000000000: \"vivviviviviv\",\n        5000000000000000: \"vivvivivivivi\"\
    ,\n        10000000000000000: \"vivvivivivivii\",\n        5000000000000000: \"\
    vivviviviviviii\",\n        10000000000000000: \"vivviviviviviiii\",\n       \
    \ 5000000000000000: \"vivviviviviviiiii\",\n        100000000000000000: \"vivviviviviviv\"\
    ,\n        50000000000000000: \"vivvivivivivivi\",\n        1000000000000000000:\
    \ \"vivvivivivivivii\",\n        500000000000000000: \"vivviviviviviviii\",\n\
    \        10000000000000000000: \"vivviviviviviviiii\",\n        5000000000000000000:\
    \ \"vivviviviviviviii\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2727vgpc_test.go:61:30: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    roman_number += int_to_roman(number)\n\
    \    return roman_number[0:len(roman_number)-1]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq3fvlzyh_test.go:20:21: undefined: int_to_roman

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"ix\"\n    case 7:\n        roman_number = \"lb\"\n    case 8:\n        roman_number\
    \ = \"c\"\n    case 9:\n        roman_number = \"d\"\n    case 10:\n        roman_number\
    \ = \"ix\"\n    case 11:\n        roman_number = \"lb\"\n    case 12:\n      \
    \  roman_number = \"c\"\n    case 13:\n        roman_number = \"d\"\n    case\
    \ 14:\n        roman_number = \"ix\"\n    case 15:\n        roman_number = \"\
    lb\"\n    case 16:\n        roman_number = \"c\"\n    case 17:\n        roman_number\
    \ = \"d\"\n    case 18:\n        roman_number = \"ix\"\n    case 19:\n       \
    \ roman_number = \"lb\"\n    case 20:\n        roman_number = \"c\"\n    case\
    \ 21:\n        roman_number = \"d\"\n    case 22:\n        roman_number = \"ix\"\
    \n    case 23:\n        roman_number = \"lb\"\n    case 24:\n        roman_number\
    \ = \"c\"\n    case 25:\n        roman_number = \"d\"\n    case 26:\n        roman_number\
    \ = \"ix\"\n    case 27:\n        roman_number = \"lb\"\n    case 28:\n      \
    \  roman_number = \"c\"\n    case 29:\n        roman_number = \"d\"\n    case\
    \ 30:\n        roman_number = \"ix\"\n    case 31:\n        roman_number = \"\
    lb\"\n    case 32:\n        roman_number = \"c\"\n    case 33:\n        roman_number\
    \ = \"d\"\n    case 34:\n        roman_number = \"ix\"\n    case 35:\n       \
    \ roman_number = \"lb\"\n    case 36:\n        roman_number = \"c\"\n    case\
    \ 37:\n        roman_number = \"d\"\n    case 38:\n        roman_number = \"ix\"\
    \n    case 39:\n        roman_number = \"lb\"\n    case 40:\n        roman_number\
    \ = \"c\"\n    case 41:\n        roman_number = \"d\"\n    case 42:\n        roman_number\
    \ = \"ix\"\n    case 43:\n        roman_number = \"lb\"\n    case 44:\n      \
    \  roman_number = \"c\"\n    case 45:\n        roman_\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmm1yp02d_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n    }\n    roman_numerals_lower := map[string]int{\n\
    \        \"i\": 1,\n        \"vi\": 5,\n        \"vii\": 10,\n        \"viii\"\
    : 50,\n        \"viv\": 100,\n        \"vi\": 500,\n        \"vii\": 1000,\n \
    \       \"viii\": 5000,\n        \"viv\": 10000,\n        \"vi\": 5000,\n    \
    \    \"vii\": 10000,\n        \"viii\": 5000,\n        \"viv\": 10000,\n     \
    \   \"vi\": 5000,\n        \"vii\": 10000,\n        \"viii\": 5000,\n        \"\
    viv\": 10000,\n        \"vi\": 5000,\n        \"vii\": 10000,\n        \"viii\"\
    : 5000,\n        \"viv\": 10000,\n        \"vi\": 5000,\n        \"vii\": 10000,\n\
    \        \"viii\": 5000,\n        \"viv\": 10000,\n        \"vi\": 5000,\n   \
    \     \"vii\": 10000,\n        \"viii\": 5000,\n        \"viv\": 10000,\n    \
    \    \"vi\": 5000,\n        \"vii\": 10000,\n        \"viii\": 5000,\n       \
    \ \"viv\": 10000,\n        \"vi\": 5000,\n        \"vii\": 10000,\n        \"\
    viii\": 5000,\n        \"viv\": 10000,\n        \"vi\": 5000,\n        \"vi\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdn5tjj77_test.go:93:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\",\n      \
    \  \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"\
    CIX\", \"CX\",\n        \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\"\
    , \"CXVII\", \"CXVIII\", \"CIX\",\n        \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\",\n        \"CIX\", \"CX\"\
    , \"CXI\", \"CXII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph3l0nko7_test.go:34:29: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075672
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number >= number\
    \ {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\", romanNumeral,\
    \ number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsau_j3cw_test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    roman_number\
    \ := \"\"\n    for roman_number == \"\" {\n        roman_number = romans[number]\n\
    \        number -= roman_number\n    }\n    return strings.ToLower(roman_number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmply9l1cel_test.go:32:9: invalid operation: number -= roman_number (mismatched
    types int and string)

    /tmp/tmply9l1cel_test.go:34:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    romans := []string{\"M\", \"CM\", \"D\", \"CD\",\
    \ \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    result\
    \ := \"\"\n    number -= 1 // We start at 1, not 0\n    for _, romanIndex := range\
    \ romans {\n        result += romanIndex\n        number /= 100\n    }\n    return\
    \ result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpd7r2f1ri_test.go:58: expected 'xix', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpd7r2f1ri_test.go:58:\
    \ expected 'clii', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpd7r2f1ri_test.go:58: expected 'ccli', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpd7r2f1ri_test.go:58:\
    \ expected 'cdxxvi', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpd7r2f1ri_test.go:58: expected 'd', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpd7r2f1ri_test.go:58:\
    \ expected 'i', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpd7r2f1ri_test.go:58: expected 'iv', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpd7r2f1ri_test.go:58:\
    \ expected 'xliii', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpd7r2f1ri_test.go:58: expected 'xc', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpd7r2f1ri_test.go:58:\
    \ expected 'xciv', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpd7r2f1ri_test.go:58: expected 'dxxxii', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpd7r2f1ri_test.go:58:\
    \ expected 'cm', got 'MCMDCDCXCLXLXIXVIVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpd7r2f1ri_test.go:58: expected 'cmxciv', got 'MCMDCDCXCLXLXIXVIVI'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpd7r2f1ri_test.go:58:\
    \ expected 'm', got 'MCMDCDCXCLXLXIXVIVI'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075673
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return strings.ToLower(roman)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1vuzfssu_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n        1000000: \"viv\"\
    ,\n        10000000: \"viv\",\n        100000000: \"viv\",\n        1000000000:\
    \ \"viv\",\n        10000000000: \"viv\",\n        100000000000: \"viv\",\n  \
    \      1000000000000: \"viv\",\n        10000000000000: \"viv\",\n        100000000000000:\
    \ \"viv\",\n        1000000000000000: \"viv\",\n        10000000000000000: \"\
    viv\",\n        100000000000000000: \"viv\",\n        1000000000000000000: \"\
    viv\",\n        10000000000000000000: \"viv\",\n        100000000000000000000:\
    \ \"viv\",\n        1000000000000000000000: \"viv\",\n        10000000000000000000000:\
    \ \"viv\",\n        100000000000000000000000: \"viv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        10000000000000000000000000: \"viv\",\n        100000000000000000000000000:\
    \ \"viv\",\n        1000000000000000000000000000: \"viv\",\n        10000000000000000000000000000:\
    \ \"viv\",\n        100000000000000000000000000000: \"viv\",\n        1000000000000000000000000000000:\
    \ \"viv\",\n        10000000000000000000000000000000: \"viv\",\n        100000000000000000000000000000000:\
    \ \"viv\",\n        1000000000000000000000000000000000: \"viv\",\n        10000000000000000000000000000000000:\
    \ \"viv\",\n        100000000000000000000000000000000000: \"viv\",\n        1000000000000000000000000000000000000:\
    \ \"viv\",\n        10000000000000000000000000000000000000: \"viv\",\n       \
    \ 100000000000000000000000000000000000000: \"viv\",\n        1000000000000000000000000000000000000000:\
    \ \"viv\",\n        10000000000000000000000000000000000000000: \"viv\",\n    \
    \    100000000000000000000000000000000000000000: \"viv\",\n        1000000000000000000000000000000000000000000:\
    \ \"viv\",\n        10000000000000000000000000000000000000000000: \"viv\",\n \
    \       100000000000000000000000000000000000000000000: \"viv\",\n        1000000000000000000000000000000000000000000000:\
    \ \"viv\",\n        10000000000000000000000000000000000000000000000: \"viv\",\n\
    \        100000000000000000000000000000000000000000000000: \"viv\",\n        1000000000000000000000000000000000000000000000000:\
    \ \"viv\",\n        10000000000000000000000000000000000000000000000000: \"viv\"\
    ,\n        100000000000000000000000000000000000000000000000000: \"viv\",\n   \
    \     1000000000000000000000000000000000000000000000000000\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph7bn0f4t_test.go:75:61: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n   \
    \     \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\",\n        \"CCVII\"\
    , \"CCV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp50v6obyd_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"mi\"\n    case 7:\n        roman_number = \"vi\"\n    case 8:\n        roman_number\
    \ = \"f\"\n    case 9:\n        roman_number = \"ff\"\n    case 10:\n        roman_number\
    \ = \"fff\"\n    case 11:\n        roman_number = \"ffff\"\n    case 12:\n   \
    \     roman_number = \"gg\"\n    case 13:\n        roman_number = \"ggg\"\n  \
    \  case 14:\n        roman_number = \"gggg\"\n    case 15:\n        roman_number\
    \ = \"aaaa\"\n    case 16:\n        roman_number = \"aaaaa\"\n    case 17:\n \
    \       roman_number = \"aaaaaa\"\n    case 18:\n        roman_number = \"aaaaaaa\"\
    \n    case 19:\n        roman_number = \"aaaaaaab\"\n    case 20:\n        roman_number\
    \ = \"aaaaaaace\"\n    case 21:\n        roman_number = \"aaaaaaacee\"\n    case\
    \ 22:\n        roman_number = \"aaaaaaaceee\"\n    case 23:\n        roman_number\
    \ = \"aaaaaaaceeee\"\n    case 24:\n        roman_number = \"aaaaaaaceeeef\"\n\
    \    case 25:\n        roman_number = \"aaaaaaaceeeeed\"\n    case 26:\n     \
    \   roman_number = \"aaaaaaaceeeeedd\"\n    case 27:\n        roman_number = \"\
    aaaaaaaceeeeedda\"\n    case 28:\n        roman_number = \"aaaaaaaceeeeeddab\"\
    \n    case 29:\n        roman_number = \"aaaaaaaceeeeeddabc\"\n    case 30:\n\
    \        roman_number = \"aaaaaaaceeeeeddabcd\"\n    case 31:\n        roman_number\
    \ = \"aaaaaaaceeeeeddabcde\"\n    case 32:\n        roman_number = \"aaaaaaaceeeeeddabcdea\"\
    \n    case 33:\n        roman_number = \"aaaaaaaceeeeeddabcdeab\"\n    case 34:\n\
    \        roman_number = \"aaaaaaaceeeeeddabcdeabc\"\n    case 35:\n        roman_number\
    \ = \"aaaaaaaceeeeeddabcdeabcd\"\n    case 36:\n        ro\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjwyfvxo0_test.go:93:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n        1000000: \"viv\"\
    ,\n        10000000: \"viii\",\n        100000000: \"viv\",\n        1000000000:\
    \ \"viv\",\n        10000000000: \"viii\",\n        100000000000: \"viv\",\n \
    \       1000000000000: \"viv\",\n        10000000000000: \"viii\",\n        100000000000000:\
    \ \"viv\",\n        1000000000000000: \"viv\",\n        10000000000000000: \"\
    viii\",\n        100000000000000000: \"viv\",\n        1000000000000000000: \"\
    vi\",\n    }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv9955ao2_test.go:45:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075669
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiii\"\
    ,\n        10000: \"vivvi\",\n        50000: \"vivii\",\n        100000: \"viviii\"\
    ,\n        500000: \"viviiii\",\n        1000000: \"vivviii\",\n        5000000:\
    \ \"viviiiii\",\n        10000000: \"vivviiii\",\n        50000000: \"viviiiiii\"\
    ,\n        100000000: \"vivviiiii\",\n        500000000: \"viviiiiiii\",\n   \
    \     1000000000: \"vivviiiiii\",\n        5000000000: \"viviiiiiiii\",\n    \
    \    10000000000: \"vivviiiiiii\",\n        50000000000: \"viviiiiiiiii\",\n \
    \       100000000000: \"vivviiiiiiii\",\n        500000000000: \"viviiiiiiiiii\"\
    ,\n        1000000000000: \"vivviiiiiiiii\",\n        5000000000000: \"viviiiiiiiiiii\"\
    ,\n        10000000000000: \"vivviiiiiiiiii\",\n        50000000000000: \"viviiiiiiiiiiii\"\
    ,\n        100000000000000: \"vivviiiiiiiiiii\",\n        500000000000000: \"\
    viviiiiiiiiiiiii\",\n        1000000000000000: \"vivviiiiiiiiiiii\",\n       \
    \ 5000000000000000: \"viviiiiiiiiiiiii\",\n        1000000000000000000: \"vivviiiiiiiiiiiiii\"\
    ,\n    }\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpim0ciey7_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n\
    \        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case\
    \ 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"VI\"\n   \
    \ case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\
    \n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num = \"\
    X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpko4pjie6_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viivi\",\n        1000: \"viiii\",\n        5000: \"viiiii\",\n\
    \    }\n    roman, ok := romans[number]\n    if !ok {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp21xa5vv0_test.go:62: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp21xa5vv0_test.go:62: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp21xa5vv0_test.go:62: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp21xa5vv0_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp21xa5vv0_test.go:62:\
    \ expected 'd', got 'viivi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp21xa5vv0_test.go:62: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp21xa5vv0_test.go:62: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp21xa5vv0_test.go:62: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp21xa5vv0_test.go:62: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp21xa5vv0_test.go:62: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp21xa5vv0_test.go:62:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp21xa5vv0_test.go:62: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp21xa5vv0_test.go:62: expected 'm', got 'viiii'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"M\", \"CM\", \"D\", \"CD\"\
    , \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\",\n    }\n\
    \    result := \"\"\n    number -= 1000\n    for _, roman := range romans {\n\
    \        result += roman\n        number -= 100\n    }\n    result += romans[len(romans)-1]\n\
    \    number -= 10\n    for number > 0 {\n        result += romans[number%10]\n\
    \        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpyu_sc5sc_test.go:63: expected 'xix', got 'MCMDCDCXCLXLXIXVIVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpyu_sc5sc_test.go:63:\
    \ expected 'clii', got 'MCMDCDCXCLXLXIXVIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpyu_sc5sc_test.go:63: expected 'ccli', got 'MCMDCDCXCLXLXIXVIVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpyu_sc5sc_test.go:63:\
    \ expected 'cdxxvi', got 'MCMDCDCXCLXLXIXVIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpyu_sc5sc_test.go:63: expected 'd', got 'MCMDCDCXCLXLXIXVIVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpyu_sc5sc_test.go:63:\
    \ expected 'i', got 'MCMDCDCXCLXLXIXVIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpyu_sc5sc_test.go:63: expected 'iv', got 'MCMDCDCXCLXLXIXVIVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpyu_sc5sc_test.go:63:\
    \ expected 'xliii', got 'MCMDCDCXCLXLXIXVIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpyu_sc5sc_test.go:63: expected 'xc', got 'MCMDCDCXCLXLXIXVIVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpyu_sc5sc_test.go:63:\
    \ expected 'xciv', got 'MCMDCDCXCLXLXIXVIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpyu_sc5sc_test.go:63: expected 'dxxxii', got 'MCMDCDCXCLXLXIXVIVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpyu_sc5sc_test.go:63:\
    \ expected 'cm', got 'MCMDCDCXCLXLXIXVIVII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpyu_sc5sc_test.go:63: expected 'cmxciv', got 'MCMDCDCXCLXLXIXVIVII'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpyu_sc5sc_test.go:63:\
    \ expected 'm', got 'MCMDCDCXCLXLXIXVIVII'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppsq4yepq_test.go:34:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n        \"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\",\n        \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\",\n    }\n    roman_number := 0\n    roman_number += romans[number%100]\n\
    \    number /= 100\n    roman_number += romans[number%10]\n    number /= 10\n\
    \    roman_number += romans[number]\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptaxhk6s7_test.go:26:5: invalid operation: roman_number += romans[number
    % 100] (mismatched types int and string)

    /tmp/tmptaxhk6s7_test.go:28:5: invalid operation: roman_number += romans[number
    % 10] (mismatched types int and string)

    /tmp/tmptaxhk6s7_test.go:30:5: invalid operation: roman_number += romans[number]
    (mismatched types int and string)

    /tmp/tmptaxhk6s7_test.go:31:12: cannot use roman_number (variable of type int)
    as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx08g12wb_test.go:34:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075670
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp47lawrce_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := \"\"\n\
    \    for roman_numeral, number := range roman_numerals {\n        if number >=\
    \ number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\"\
    , roman_numeral, number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk7bkzrid_test.go:29:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075673
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    result\
    \ := \"\"\n    for number > 0 {\n        number -= romans[number]\n        result\
    \ = romans[number] + result\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgy3sh7ys_test.go:31:9: invalid operation: number -= romans[number] (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n\
    \        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case\
    \ 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"VI\"\n   \
    \ case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\
    \n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num = \"\
    X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpko4pjie6_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuqg9dqn_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsh816rh3_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2xvceavd_test.go:56:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n    case 3:\n\
    \        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\n    case\
    \ 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"VI\"\n   \
    \ case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num = \"VIII\"\
    \n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num = \"\
    X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpko4pjie6_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075664
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n    }\n    romanNumeralsString\
    \ := \"\"\n    for romanNumeral, roman := range romanNumerals {\n        if number\
    \ >= romanNumeral {\n            romanNumeralsString += roman\n            number\
    \ -= romanNumeral\n        }\n    }\n    return romanNumeralsString\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpjadyo67__test.go:64: expected 'xix', got 'viiivi'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpjadyo67__test.go:64:\
    \ expected 'clii', got 'vivivivii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpjadyo67__test.go:64: expected 'ccli', got 'iviviiviiiviv'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpjadyo67__test.go:64:\
    \ expected 'cdxxvi', got 'viiviiivivivi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpjadyo67__test.go:64: expected 'd', got 'iviviiviiiviv'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpjadyo67__test.go:64:\
    \ expected 'iv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n\
    \        tmpjadyo67__test.go:64: expected 'xliii', got 'ivivii'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpjadyo67__test.go:64: expected\
    \ 'xc', got 'iviviiviii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n\
    \        tmpjadyo67__test.go:64: expected 'xciv', got 'iviviiviii'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpjadyo67__test.go:64:\
    \ expected 'dxxxii', got 'viiivivivivii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpjadyo67__test.go:64: expected 'cm', got 'viviiviiivivviivii'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpjadyo67__test.go:64:\
    \ expected 'cmxciv', got 'viiviiivivviiviivi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpjadyo67__test.go:64: expected 'm', got 'iviviiviiivivviivi'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075674
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n    }\n    roman_numeral_string\
    \ := \"\"\n    for roman_numeral, numeral_string := range roman_numerals {\n \
    \       if number >= roman_numeral {\n            roman_numeral_string += numeral_string\n\
    \            number -= roman_numeral\n        }\n    }\n    return strings.ToLower(roman_numeral_string)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeo9w79h5_test.go:38:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n        50000000000000000: \"vi\",\n\
    \        10000000000000000000: \"vi\",\n        5000000000000000000: \"vi\",\n\
    \        100000000000000000000: \"vi\",\n        50000000000000000000: \"vi\"\
    ,\n        1000000000000000000000: \"vi\",\n        500000000000000000000: \"\
    vi\",\n        10000000000000000000000: \"vi\",\n        5000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000: \"vi\",\n        50000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000: \"vi\",\n        500000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000: \"vi\",\n        5000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000: \"vi\",\n        50000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000: \"vi\",\n        500000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000: \"vi\",\n        5000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000: \"vi\",\n        50000000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000000: \"vi\",\n        500000000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000000: \"vi\",\n        5000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        50000000000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000000000: \"vi\",\n        500000000000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000000000\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpirwm5mri_test.go:84:44: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp47lawrce_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000:\
    \ \"c\",\n        50000: \"c\",\n        100000: \"x\",\n        500000: \"x\"\
    ,\n        1000000: \"ix\",\n        5000000: \"ix\",\n        10000000: \"xix\"\
    ,\n        50000000: \"xix\",\n        100000000: \"xxi\",\n        500000000:\
    \ \"xxi\",\n        1000000000: \"xxx\",\n        5000000000: \"xxx\",\n     \
    \   10000000000: \"xxxx\",\n        50000000000: \"xxxx\",\n        100000000000:\
    \ \"xxxxx\",\n        500000000000: \"xxxxx\",\n        1000000000000: \"xxxxxx\"\
    ,\n        5000000000000: \"xxxxxx\",\n        10000000000000: \"xxxxxxx\",\n\
    \        50000000000000: \"xxxxxxx\",\n        100000000000000: \"xxxxxxxx\",\n\
    \        500000000000000: \"xxxxxxxx\",\n        1000000000000000: \"xxxxxxxxx\"\
    ,\n        5000000000000000: \"xxxxxxxxx\",\n        1000000000000000000: \"xxxxxxxxxx\"\
    ,\n        50000000000000000: \"xxxxxxxxxx\",\n        10000000000000000000: \"\
    xxxxxxxxxxx\",\n        5000000000000000000: \"xxxxxxxxxxx\",\n        100000000000000000000:\
    \ \"xxxxxxxxxxxx\",\n        50000000000000000000: \"xxxxxxxxxxxx\",\n       \
    \ 1000000000000000000000: \"xxxxxxxxxxxxx\",\n        500000000000000000000: \"\
    xxxxxxxxxxxxx\",\n        10000000000000000000000: \"xxxxxxxxxxxxxx\",\n     \
    \   5000000000000000000000: \"xxxxxxxxxxxxxx\",\n        100000000000000000000000:\
    \ \"xxxxxxxxxxxxxxx\",\n        50000000000000000000000: \"xxxxxxxxxxxxxxx\",\n\
    \        1000000000000000000000000: \"xxxxxxxxxxxxxxxx\",\n        500000000000000000000000:\
    \ \"xxxxxxxxxxxxxxxx\",\n        10000000000000000000000000: \"xxxxxxxxxxxxxxxxx\"\
    ,\n        5000000000000000000000000: \"xxxxxxxxxxxxxxxxx\",\n        100000000000000000000000000:\
    \ \"xxxxxxxxxxxxxxxxxx\",\n        50000000000000000000000000: \"xxxxxxxxxxxxxxxxxx\"\
    ,\n        1000000000000000000000000000: \"xxxxxxxxxxxxxxxxxxx\",\n        500000000000000000000000000:\
    \ \"xxxxxxxxxxxxxxxxxxx\",\n        10000000000000000000000000000: \"xxxxxxxxxxxxxxxxxxxx\"\
    ,\n        5000000000000000000000000000: \"xxxxxxxxxxxxxxxxxxxx\",\n        100000000000000000000000000000:\
    \ \"xxxxxxxxxxxxxxxxxxxxx\",\n        50000000000000000000000000000\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsszt2d_m_test.go:75:38: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viivi\",\n        100:\
    \ \"viiviii\",\n        500: \"viiviivi\",\n        1000: \"viiviiviii\",\n  \
    \  }\n    romanNumerals[number] = \"\"\n    return romanNumerals[number]\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpi0i89prf_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpi0i89prf_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpi0i89prf_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpi0i89prf_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpi0i89prf_test.go:58:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpi0i89prf_test.go:58: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpi0i89prf_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpi0i89prf_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpi0i89prf_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpi0i89prf_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpi0i89prf_test.go:58:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpi0i89prf_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpi0i89prf_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpi0i89prf_test.go:58: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\"\
    , \"LIIII\", \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"XC\", \"XCI\", \"XCII\", \"XCII\", \"XCIII\", \"XCIV\", \"\
    XCV\", \"XCVI\", \"XCVII\", \"XCVIII\", \"XCIX\", \"CD\", \"CD\", \"CDA\", \"\
    CDAI\", \"CDAII\", \"CDAII\", \"CDAIV\", \"CDAV\", \"CDAVI\", \"CDAVII\", \"CDAVIII\"\
    , \"CDAIX\", \"CDI\", \"CDI\", \"CDII\", \"CDIII\", \"CDIIII\", \"CDIIV\", \"\
    CDIV\", \"CDIVI\", \"CDIVII\", \"CDIVIII\", \"CDIIX\", \"CM\", \"CM\", \"CMI\"\
    , \"CMII\", \"CMIII\", \"CMIV\", \"CMV\", \"CMVI\", \"CMVII\", \"CMVIII\", \"\
    CMIX\", \"CMM\", \"CMMI\", \"CMMII\", \"CMMIII\", \"CMMIV\", \"CMMV\", \"CMMVI\"\
    , \"CMMVII\", \"CMMVIII\", \"C\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzpa2sk0e_test.go:20:1125: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp47lawrce_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := []string{\"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\"\
    , \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"\
    CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CXC\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCL\"\
    , \"CCX\", \"CCXI\", \"CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"\
    CCXVII\", \"CCXVIII\", \"CCIX\", \"CCLX\", \"CCCX\", \"CCCC\", \"CCCCI\", \"CCCCII\"\
    , \"CCCCIII\", \"CCDL\", \"CCCX\", \"CCCCX\", \"CCCCXI\", \"CCCCXII\", \"CCCCXIII\"\
    , \"CCCCXIV\", \"CCCCXV\", \"CCCCXVI\", \"CCCCXVII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp11zy57wo_test.go:22:1098: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000:\
    \ \"c\",\n        50000: \"c\",\n        100000: \"x\",\n        500000: \"x\"\
    ,\n        1000000: \"ix\",\n        5000000: \"ix\",\n        10000000: \"iv\"\
    ,\n        50000000: \"iv\",\n        100000000: \"v\",\n        500000000: \"\
    v\",\n        1000000000: \"vi\",\n        5000000000: \"vi\",\n        10000000000:\
    \ \"vii\",\n        50000000000: \"vii\",\n        100000000000: \"viii\",\n \
    \       500000000000: \"viii\",\n        1000000000000: \"ix\",\n        5000000000000:\
    \ \"ix\",\n        10000000000000: \"ix\",\n        50000000000000: \"ix\",\n\
    \        100000000000000: \"ix\",\n        500000000000000: \"ix\",\n        1000000000000000:\
    \ \"ix\",\n        5000000000000000: \"ix\",\n        1000000000000000000: \"\
    i\",\n        50000000000000000: \"i\",\n        10000000000000000000: \"i\",\n\
    \        5000000000000000000: \"i\",\n        100000000000000000000: \"i\",\n\
    \        50000000000000000000: \"i\",\n        1000000000000000000000: \"i\",\n\
    \        500000000000000000000: \"i\",\n        10000000000000000000000: \"i\"\
    ,\n        5000000000000000000000: \"i\",\n        100000000000000000000000: \"\
    i\",\n        50000000000000000000000: \"i\",\n        1000000000000000000000000:\
    \ \"i\",\n        500000000000000000000000: \"i\",\n        10000000000000000000000000:\
    \ \"i\",\n        5000000000000000000000000: \"i\",\n        100000000000000000000000000:\
    \ \"i\",\n        50000000000000000000000000: \"i\",\n        1000000000000000000000000000:\
    \ \"i\",\n        500000000000000000000000000: \"i\",\n        10000000000000000000000000000:\
    \ \"i\",\n        5000000000000000000000000000: \"i\",\n        100000000000000000000000000000:\
    \ \"i\",\n        50000000000000000000000000000: \"i\",\n        1000000000000000000000000000000:\
    \ \"i\",\n        500000000000000000000000000000: \"i\",\n        10000000000000000000000000000000:\
    \ \"i\",\n        5000000000000000000000000000000: \"i\",\n        100000000000000000000000000000000:\
    \ \"i\",\n        50000000000000000000000000000000: \"i\",\n        1000000000000000000000000000000000:\
    \ \"i\",\n        500000000000000000000000000000000: \"i\",\n        10000000000000000000000000000000000:\
    \ \"i\",\n        5\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcvmsjf0x_test.go:85:10: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    roman_number\
    \ := \"\"\n    for roman_number, number := range romans {\n        if number >=\
    \ number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%s\"\
    , romans[number], number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu5i8_m2e_test.go:29:5: roman_number declared but not used

    /tmp/tmpu5i8_m2e_test.go:30:9: roman_number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n    romanNumerals[number]\
    \ = \"\"\n    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpu2jidllj_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpu2jidllj_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpu2jidllj_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpu2jidllj_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpu2jidllj_test.go:58:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpu2jidllj_test.go:58: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpu2jidllj_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpu2jidllj_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpu2jidllj_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpu2jidllj_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpu2jidllj_test.go:58:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpu2jidllj_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpu2jidllj_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpu2jidllj_test.go:58: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpfxmlpzw9_test.go:62: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpfxmlpzw9_test.go:62: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpfxmlpzw9_test.go:62: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpfxmlpzw9_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpfxmlpzw9_test.go:62:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpfxmlpzw9_test.go:62: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpfxmlpzw9_test.go:62: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpfxmlpzw9_test.go:62: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpfxmlpzw9_test.go:62: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpfxmlpzw9_test.go:62: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpfxmlpzw9_test.go:62:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpfxmlpzw9_test.go:62: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpfxmlpzw9_test.go:62: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    roman_number := \"\"\n    for\
    \ roman_number, number < 1000, number += 1000 {\n        roman_number += romans[number]\n\
    \    }\n    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4imh7dsm_test.go:29:9: expected boolean or range expression, found assignment
    (missing parentheses around composite literal?)

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number := roman_numerals[number]\n\
    \    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiomvmrcm_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"c\"\n    default:\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    return roman_number\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpyt9x8dhj_test.go:71: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpyt9x8dhj_test.go:71: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpyt9x8dhj_test.go:71:\
    \ expected 'd', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpyt9x8dhj_test.go:71: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpyt9x8dhj_test.go:71: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpyt9x8dhj_test.go:71: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpyt9x8dhj_test.go:71:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpyt9x8dhj_test.go:71:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpyt9x8dhj_test.go:71: expected 'm', got 'c'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075666
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number >= number\
    \ {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\", romanNumeral,\
    \ number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsau_j3cw_test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viiv\",\n        50000: \"viiv\",\n        100000: \"viiv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viiv\",\n        5000000: \"\
    viiv\",\n        10000000: \"viiv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viiv\",\n        500000000: \"viiv\",\n        1000000000: \"viiv\",\n   \
    \     5000000000: \"viiv\",\n        10000000000: \"viiv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viiv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viiv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viiv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viiv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viiv\",\n \
    \       5000000000000000: \"viiv\",\n        1000000000000000000: \"viiv\",\n\
    \    }\n    roman_numeral := \"\"\n    for roman_numeral, number := range roman_numerals\
    \ {\n        if number <= number {\n            break\n        }\n    }\n    return\
    \ fmt.Sprintf(\"%s%v\", roman_numeral, number)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0wl0fyqe_test.go:55:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n    romanNumerals[number] =\
    \ \"\"\n    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpwzpm3nk7_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpwzpm3nk7_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpwzpm3nk7_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpwzpm3nk7_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpwzpm3nk7_test.go:58:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpwzpm3nk7_test.go:58: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpwzpm3nk7_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpwzpm3nk7_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpwzpm3nk7_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpwzpm3nk7_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpwzpm3nk7_test.go:58:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpwzpm3nk7_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpwzpm3nk7_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpwzpm3nk7_test.go:58: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075675
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90kp2m64_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    int_to_mini_roman: invalid input\")\n        return \"\"\n    }\n\n    romans\
    \ := []string{\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"\
    XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\",\n    }\n\n    result := \"\"\n    for\
    \ _, romanIndex := range romans {\n        result += \"M\"\n        if number\
    \ >= romanIndex {\n            number -= romanIndex\n            result += romans[romanIndex]\n\
    \        }\n    }\n\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp75ywos62_test.go:31:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmp75ywos62_test.go:32:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmp75ywos62_test.go:33:30: invalid argument: index romanIndex (variable of
    type string) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n       \
    \ 10000: \"vi\",\n        100000: \"vi\",\n        1000000: \"vi\",\n        10000000:\
    \ \"vi\",\n        100000000: \"vi\",\n        1000000000: \"vi\",\n        10000000000:\
    \ \"vi\",\n        100000000000: \"vi\",\n        1000000000000: \"vi\",\n   \
    \     10000000000000: \"vi\",\n        100000000000000: \"vi\",\n        1000000000000000:\
    \ \"vi\",\n        10000000000000000: \"vi\",\n        1000000000000000000: \"\
    vi\",\n        10000000000000000000: \"vi\",\n        100000000000000000000: \"\
    vi\",\n        1000000000000000000000: \"vi\",\n        10000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000: \"vi\",\n        1000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000: \"vi\",\n        100000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000: \"vi\",\n        10000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000:\
    \ \"vi\",\n        10000000000000000000000000000000: \"vi\",\n        100000000000000000000000000000000:\
    \ \"vi\",\n        1000000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\",\n        100000000000000000000000000000000: \"vi\",\n        1000000000000000000000000000000000:\
    \ \"vi\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps0wk9im2_test.go:81:45: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiiiix\",\n        1000: \"viiiiiix\",\n      \
    \  5000: \"viiiiiix\",\n        10000: \"viiiiiix\",\n        50000: \"viiiiiix\"\
    ,\n        100000: \"viiiiiix\",\n        500000: \"viiiiiix\",\n        1000000:\
    \ \"viiiiiix\",\n        5000000: \"viiiiiix\",\n        10000000: \"viiiiiix\"\
    ,\n        50000000: \"viiiiiix\",\n        100000000: \"viiiiiix\",\n       \
    \ 500000000: \"viiiiiix\",\n        1000000000: \"viiiiiix\",\n        5000000000:\
    \ \"viiiiiix\",\n        10000000000: \"viiiiiix\",\n        50000000000: \"viiiiiix\"\
    ,\n        100000000000: \"viiiiiix\",\n        500000000000: \"viiiiiix\",\n\
    \        1000000000000: \"viiiiiix\",\n        5000000000000: \"viiiiiix\",\n\
    \        10000000000000: \"viiiiiix\",\n        50000000000000: \"viiiiiix\",\n\
    \        100000000000000: \"viiiiiix\",\n        500000000000000: \"viiiiiix\"\
    ,\n        1000000000000000: \"viiiiiix\",\n        5000000000000000: \"viiiiiix\"\
    ,\n        10000000000000000: \"viiiiiix\",\n        5000000000000000: \"viiiiiix\"\
    ,\n        100000000000000000: \"viiiiiix\",\n        50000000000000000: \"viiiiiix\"\
    ,\n        1000000000000000000: \"viiiiiix\",\n        500000000000000000: \"\
    viiiiiix\",\n        10000000000000000000: \"viiiiiix\",\n        5000000000000000000:\
    \ \"viiiiiix\",\n        100000000000000000000: \"viiiiiix\",\n        50000000000000000000:\
    \ \"viiiiiix\",\n        1000000000000000000000: \"viiiiiix\",\n        500000000000000000000:\
    \ \"viiiiiix\",\n        10000000000000000000000: \"viiiiiix\",\n        5000000000000000000000:\
    \ \"viiiiiix\",\n        100000000000000000000000: \"viiiiiix\",\n        50000000000000000000000:\
    \ \"viiiiiix\",\n        1000000000000000000000000: \"viiiiiix\",\n        500000000000000000000000:\
    \ \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4omg55ey_test.go:69:35: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075674
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n    romanNumeralsString :=\
    \ \"\"\n    for romanNumeral, roman := range romanNumerals {\n        if number\
    \ >= romanNumeral {\n            romanNumeralsString += roman\n            number\
    \ -= romanNumeral\n        }\n    }\n    return strings.ToLower(romanNumeralsString)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpab79pw7i_test.go:35:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075674
