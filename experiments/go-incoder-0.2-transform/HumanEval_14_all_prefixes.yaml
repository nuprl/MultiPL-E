name: HumanEval_14_all_prefixes
language: go_test.go
prompt: "package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Return list of all prefixes from shortest to longest of the input string\n//\
  \ >>> all_prefixes(\"abc\")\n// []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString\
  \ string) []string {\n"
tests: "func TestAll_Prefixes(t *testing.T) {\n  candidate := all_prefixes\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual:\
  \ candidate(\"asdfgh\"), expected: []string{\"a\", \"as\", \"asd\", \"asdf\", \"\
  asdfg\", \"asdfgh\"} },\n     { actual: candidate(\"WWW\"), expected: []string{\"\
  W\", \"WW\", \"WWW\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    result := []string{}\n    prefix := myString\n    for len(prefix)\
    \ > 0 {\n        result = append(result, prefix)\n        prefix = prefix[:len(prefix)-1]\n\
    \    }\n    return result\n}\n", "    result := []string{}\n    prefix := myString\n\
    \    for len(prefix) > 0 {\n        result = append(result, prefix)\n        prefix\
    \ = prefix[:len(prefix)-1]\n    }\n    return result\n}\n", "    result := []string{}\n\
    \    prefix := myString\n    for len(prefix) > 0 {\n        result = append(result,\
    \ prefix)\n        prefix = prefix[:len(prefix)-1]\n    }\n    return result\n\
    }\n", "    result := []string{}\n    prefix := \"\"\n    for _, char := range\
    \ myString {\n        if char == prefix {\n            continue\n        }\n \
    \       prefix = char\n        result = append(result, prefix)\n    }\n    return\
    \ result\n}\n", "    var prefixes []string\n    var i int\n    for i = 0; i <\
    \ len(myString); i++ {\n        prefixes = append(prefixes, myString[0:i])\n \
    \   }\n    return prefixes\n}\n", "    result := []string{}\n    prefix := myString\n\
    \    for len(prefix) > 0 {\n        result = append(result, prefix)\n        prefix\
    \ = prefix[:len(prefix)-1]\n    }\n    return result\n}\n", "    prefixes := []string{}\n\
    \    prefix := myString\n    for len(prefix) > 0 {\n        prefixes = append(prefixes,\
    \ prefix)\n        prefix = prefix[:len(prefix)-1]\n    }\n    return prefixes\n\
    }\n", "    prefixes := []string{}\n    for i := 0; i < len(myString); i++ {\n\
    \        prefixes = append(prefixes, myString[:i])\n    }\n    return prefixes\n\
    }\n", "    prefixes := make([]string, 0)\n    prefix := myString\n    for len(prefix)\
    \ > 0 {\n        prefixes = append(prefixes, prefix)\n        prefix = prefix[:len(prefix)-1]\n\
    \    }\n    return prefixes\n}\n", "    prefixes := []string{}\n    prefix :=\
    \ myString\n    for len(prefix) > 0 {\n        prefixes = append(prefixes, prefix)\n\
    \        prefix = prefix[:len(prefix)-1]\n    }\n    return prefixes\n}\n", " \
    \   result := make([]string, 0)\n    prefix := myString\n    for len(prefix) >\
    \ 0 {\n        result = append(result, prefix)\n        prefix = prefix[:len(prefix)-1]\n\
    \    }\n    return result\n}\n", "    result := []string{}\n    for i := 0; i\
    \ < len(myString); i++ {\n        result := append(result, myString[:i])\n   \
    \ }\n    return result\n}\n", "    result := []string{}\n    prefix := myString\n\
    \    for len(prefix) > 0 {\n        result = append(result, prefix)\n        prefix\
    \ = prefix[:len(prefix)-1]\n    }\n    return result\n}\n", "    prefixes := make([]string,\
    \ 0)\n    prefix := myString\n    for len(prefix) > 0 {\n        prefixes = append(prefixes,\
    \ prefix)\n        prefix = prefix[:len(prefix)-1]\n    }\n    return prefixes\n\
    }\n", "    result := []string{}\n    for _, prefix := range all_prefixes_test.prefixes\
    \ {\n        if strings.HasPrefix(myString, prefix) {\n            result = append(result,\
    \ prefix)\n        }\n    }\n    return result\n}\n", "    result := make([]string,\
    \ 0)\n    prefix := myString\n    for len(prefix) > 0 {\n        result = append(result,\
    \ prefix)\n        prefix = prefix[:len(prefix)-1]\n    }\n    return result\n\
    }\n", "    result := []string{}\n    prefix := myString\n    for len(prefix) >\
    \ 0 {\n        result = append(result, prefix)\n        prefix = prefix[:len(prefix)-1]\n\
    \    }\n    return result\n}\n", "    result := []string{}\n    prefix := myString\n\
    \    for len(prefix) > 0 {\n        result = append(result, prefix)\n        prefix\
    \ = prefix[:len(prefix)-1]\n    }\n    return result\n}\n", "    prefixes := []string{}\n\
    \    prefix := \"\"\n    for _, char := range myString {\n        if char == prefix\
    \ {\n            prefixes = append(prefixes, prefix)\n        } else {\n     \
    \       prefix = char\n            prefixes = append(prefixes, prefix)\n     \
    \   }\n    }\n    return prefixes\n}\n", "    result := make([]string, 0)\n  \
    \  prefix := myString\n    for len(prefix) > 0 {\n        result = append(result,\
    \ prefix)\n        prefix = prefix[:len(prefix)-1]\n    }\n    return result\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
