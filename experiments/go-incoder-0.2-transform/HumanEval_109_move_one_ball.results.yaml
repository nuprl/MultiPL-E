language: go_test.go
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170390\
    \ stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 20 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpo3fahzok_test.go:29 +0x72 fp=0xc0201703a0 sp=0xc020170398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703c8 sp=0xc0201703a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703f0 sp=0xc0201703c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170418 sp=0xc0201703f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170440 sp=0xc020170418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170468 sp=0xc020170440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170490 sp=0xc020170468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704b8 sp=0xc020170490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704e0 sp=0xc0201704b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170508 sp=0xc0201704e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)/2]\n    \n    i := len(arr) - 1\n    j\
    \ := 0\n    \n    for {\n        if arr[i] > arr[j] {\n            arr[i], arr[j]\
    \ = arr[j], arr[i]\n            i++\n            j++\n        } else {\n     \
    \       break\n        }\n    }\n    \n    arr[i], arr[j] = arr[j], arr[i]\n \
    \   \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxhb7zhnh_test.go:34:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift :=\
    \ len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <\
    \ arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if shift >\
    \ 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n    \n  \
    \  for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n       \
    \     shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] < arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift :=\
    \ len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] >\
    \ arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if shift >\
    \ 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n    \n  \
    \  for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n       \
    \     shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift :=\
    \ len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <\
    \ arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if shift >\
    \ 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n    \n  \
    \  for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n       \
    \     shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] < arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4itfm_jw_test.go:155:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074396
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We are going to perform right shift operation N times. \n\
    \    // For each right shift operation we shift the array by one position\n  \
    \  // and move the last element to the 0th position in the array.\n    // We will\
    \ keep track of the number of right shift operations.\n    var shiftCount int\
    \ = 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    var arrCount int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount2 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount3 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount4 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount5 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount6 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount7 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount8 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount9 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount10 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount11 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount12 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount13 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount14 int = len(arr)\n\
    \    \n    // We will keep track of the number of elements in the array after\
    \ \n    // performing right shift operations.\n    var arrCount15 int = len(arr)\n\
    \    \n    // We will keep track of the number of element\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6t9i6iwr_test.go:101:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074396
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)]\n    \n    for i := len(arr) - 1; i >\
    \ 0; i-- {\n        arr[i] = arr[i-1]\n    }\n    \n    arr[0] = arr[len(arr)\
    \ - 1]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiyy4gaqf_test.go:34:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] =\
    \ arr[i]>>shift\n        arr[i] = arr[i]<<shift\n        shift -= 1\n    }\n \
    \   \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp5h_z2qjm_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp5h_z2qjm_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n  \
    \  \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp1esltnky_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0] = arr[shift]\n    \n    return move_one_ball(arr[1:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpk0d5w63q_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpk0d5w63q_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            i++\n            j--\n        }\n\
    \        if i == j {\n            break\n        }\n    }\n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpf2g25zt0_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpf2g25zt0_test.go:62\
    \ +0x525\ntesting.tRunner(0xc00019b040, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmbdfg7_t_test.go:159:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074396
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            break\n        }\n    }\n    \n\
    \    return i == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmptc74iwxj_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmptc74iwxj_test.go:59\
    \ +0x505\ntesting.tRunner(0xc0001991e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa1c19d44_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n\
    \        return move_one_ball(arr[:shift])\n    }\n    \n    return false\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f9128?,\
    \ 0x4b3193?})\n\t/tmp/tmp8k42qhb3_test.go:37 +0xa8\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmp8k42qhb3_test.go:57 +0xa8\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n\
    \        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n \
    \           i, j = j, i\n        } else {\n            break\n        }\n    }\n\
    \    \n    return arr[0] == arr[j]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpv04769ur_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpv04769ur_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n  \
    \  \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp1esltnky_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift :=\
    \ len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <\
    \ arr[shift] {\n            shift += 1\n        }\n    }\n    \n    if shift <\
    \ len(arr) {\n        return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp48vbfo8r_test.go:46:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            i++\n            j--\n        }\n\
    \        if i == j {\n            break\n        }\n    }\n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpf2g25zt0_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpf2g25zt0_test.go:62\
    \ +0x525\ntesting.tRunner(0xc00019b040, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa1c19d44_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n\
    \    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpr_du_3x8_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpr_du_3x8_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            break\n        }\n    }\n    \n\
    \    return arr[i] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpc1498t42_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpc1498t42_test.go:59\
    \ +0x505\ntesting.tRunner(0xc0001924e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        for j := 0; j < len(arr)-i-1; j++ {\n            if arr[j] >\
    \ arr[j+1] {\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n          \
    \  }\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqhouia9t_test.go:34:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170390\
    \ stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 20 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpo3fahzok_test.go:29 +0x72 fp=0xc0201703a0 sp=0xc020170398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703c8 sp=0xc0201703a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703f0 sp=0xc0201703c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170418 sp=0xc0201703f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170440 sp=0xc020170418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170468 sp=0xc020170440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170490 sp=0xc020170468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704b8 sp=0xc020170490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704e0 sp=0xc0201704b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170508 sp=0xc0201704e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074398
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift :=\
    \ len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <\
    \ arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if shift >\
    \ 0 {\n        return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5au9zbzg_test.go:46:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmperfqv1dp_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmperfqv1dp_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else if i == j {\n            break\n        } else\
    \ {\n            i++\n            j--\n        }\n    }\n    \n    return len(arr)\
    \ == i\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp886xlrju_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp886xlrju_test.go:62\
    \ +0x55f\ntesting.tRunner(0xc000192680, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n     \
    \   if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n      \
    \      i++\n            j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpep7690tm_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpep7690tm_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    return arr[0] ==\
    \ 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpnq7fduc9_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpnq7fduc9_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170390\
    \ stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 20 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpo3fahzok_test.go:29 +0x72 fp=0xc0201703a0 sp=0xc020170398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703c8 sp=0xc0201703a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703f0 sp=0xc0201703c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170418 sp=0xc0201703f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170440 sp=0xc020170418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170468 sp=0xc020170440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170490 sp=0xc020170468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704b8 sp=0xc020170490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704e0 sp=0xc0201704b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170508 sp=0xc0201704e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    n := len(arr)\n    \n    // We are going to perform right shift\
    \ operation 'k' times. \n    // If k is even, then we perform right shift operation\
    \ 'k/2' times.\n    // If k is odd, then we perform right shift operation 'k/2'\
    \ times and then\n    // perform one more right shift operation 'k/2' times.\n\
    \    // We will keep doing this until we reach the 'k' times. \n    // We will\
    \ keep doing this until we reach the 'k' times. \n    // We will keep doing this\
    \ until we reach the 'k' times. \n    // We will keep doing this until we reach\
    \ the 'k' times. \n    // We will keep doing this until we reach the 'k' times.\
    \ \n    // We will keep doing this until we reach the 'k' times. \n    // We will\
    \ keep doing this until we reach the 'k' times. \n    // We will keep doing this\
    \ until we reach the 'k' times. \n    // We will keep doing this until we reach\
    \ the 'k' times. \n    // We will keep doing this until we reach the 'k' times.\
    \ \n    // We will keep doing this until we reach the 'k' times. \n    // We will\
    \ keep doing this until we reach the 'k' times. \n    // We will keep doing this\
    \ until we reach the 'k' times. \n    // We will keep doing this until we reach\
    \ the 'k' times. \n    // We will keep doing this until we reach the 'k' times.\
    \ \n    // We will keep doing this until we reach the 'k' times. \n    // We will\
    \ keep doing this until we reach the 'k' times. \n    // We will keep doing this\
    \ until we reach the 'k' times. \n    // We will keep doing this until we reach\
    \ the 'k' times. \n    // We will keep doing this until we reach the 'k' times.\
    \ \n    // We will keep doing this until we reach the 'k' times. \n    // We will\
    \ keep doing this until we reach the 'k' times. \n    // We will keep doing this\
    \ until we reach the 'k' times. \n    // We will keep doing this until we reach\
    \ the 'k' times. \n    // We will keep doing this until we reach the 'k' times.\
    \ \n    // We will keep doing this until we reach the 'k' times. \n    // We will\
    \ keep doing this until we reach the 'k\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmx8jivbz_test.go:67:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We are going to perform right shift operation on the given\
    \ array\n    // and we will store the result in a new array 'sorted_arr'.\n  \
    \  // We will start from the last element of the given array and will\n    //\
    \ perform right shift operation until we reach the 0th element.\n    // We will\
    \ store the result in 'sorted_arr' and will compare the \n    // 'sorted_arr'\
    \ with the original array 'arr'.\n    // If they are equal then return true else\
    \ return false.\n    sorted_arr := make([]int, len(arr))\n    for i := len(arr)\
    \ - 1; i > 0; i-- {\n        sorted_arr[i] = arr[i]\n    }\n    sorted_arr[0]\
    \ = arr[0]\n    \n    // We will start from the 0th element of the given array\
    \ and will\n    // perform right shift operation until we reach the 0th element.\n\
    \    // We will store the result in 'sorted_arr' and will compare the \n    //\
    \ 'sorted_arr' with the original array 'arr'.\n    // If they are equal then return\
    \ true else return false.\n    for i := 1; i < len(arr); i++ {\n        sorted_arr[i]\
    \ = arr[i-1]\n    }\n    sorted_arr[0] = arr[0]\n    \n    // We will start from\
    \ the last element of the given array and will\n    // perform right shift operation\
    \ until we reach the 0th element.\n    // We will store the result in 'sorted_arr'\
    \ and will compare the \n    // 'sorted_arr' with the original array 'arr'.\n\
    \    // If they are equal then return true else return false.\n    for i := len(arr)\
    \ - 1; i > 0; i-- {\n        sorted_arr[i] = arr[i]\n    }\n    sorted_arr[0]\
    \ = arr[0]\n    \n    // We will start from the 0th element of the given array\
    \ and will\n    // perform right shift operation until we reach the 0th element.\n\
    \    // We will store the result in 'sorted_arr' and will compare the \n    //\
    \ 'sorted_arr' with the original array 'arr'.\n    // If they are equal then return\
    \ true else return false.\n    for i := 1; i < len(arr); i++ {\n        sorted_arr[i]\
    \ = arr[i-1]\n    }\n    sorted_arr[0] = arr[0]\n    \n    // We will start from\
    \ the last element of the given array and will\n    // perform right shift operation\
    \ until we reach the 0th element.\n    // We will store the result in 'sorted_arr'\
    \ and will compare the \n    // 'sorted_arr' with the original array 'arr'.\n\
    \    // If they are equal then return true else return false.\n    for i := len(arr)\
    \ - 1; i > 0; i-- {\n        sorted_arr[i] = arr[i]\n    }\n    sorted_arr[0]\
    \ = arr[0]\n    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplutr91sj_test.go:87:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // Initialize a boolean array 'result' to store whether we can\
    \ perform \n    // the right shift operation on the given array.\n    var result\
    \ [100]bool\n    \n    // Initialize a boolean array 'temp' to store whether we\
    \ can perform \n    // the right shift operation on the given array.\n    var\
    \ temp []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp2 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp3 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp4 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp5 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp6 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp7 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp8 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp9 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp10 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp11 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp12 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp13 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp14 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given array.\n    var\
    \ temp15 []bool\n    \n    // Initialize a boolean array 'temp' to store whether\
    \ we can perform \n    // the right shift operation on the given \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpajjafs03_test.go:100:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n     \
    \   if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n      \
    \      i++\n            j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpep7690tm_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpep7690tm_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i] >> shift\n        shift -= 1\n    }\n    \n    return\
    \ arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpj2puy29t_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpj2puy29t_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074399
- exit_code: null
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n\
    \        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n \
    \           i = j\n        } else {\n            j = i\n        }\n        if\
    \ i == 0 {\n            return true\n        }\n    }\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074412
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n  \
    \  \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp1esltnky_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n     \
    \   if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n      \
    \      i++\n            j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpep7690tm_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpep7690tm_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift :=\
    \ len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <\
    \ arr[shift] {\n            shift += 1\n        }\n    }\n    \n    if shift >\
    \ 0 {\n        return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprqzwecsr_test.go:46:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074399
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpw9ojbba5_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] =\
    \ arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i]\
    \ = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n      \
    \  arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptfqy5co9_test.go:98:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shift operations\
    \ performed on\n    // the given array.\n    shift := 0\n    \n    // We will\
    \ keep track of the number of elements in the given array which we\n    // are\
    \ currently considering.\n    current := 0\n    \n    // We will keep track of\
    \ the number of elements in the given array which we\n    // are currently considering.\n\
    \    max := len(arr) - 1\n    \n    // We will keep track of the number of elements\
    \ in the given array which we\n    // are currently considering.\n    min := 0\n\
    \    \n    // We will keep track of the number of elements in the given array\
    \ which we\n    // are currently considering.\n    \n    // We will keep track\
    \ of the number of elements in the given array which we\n    // are currently\
    \ considering.\n    \n    // We will keep track of the number of elements in the\
    \ given array which we\n    // are currently considering.\n    \n    // We will\
    \ keep track of the number of elements in the given array which we\n    // are\
    \ currently considering.\n    \n    // We will keep track of the number of elements\
    \ in the given array which we\n    // are currently considering.\n    \n    //\
    \ We will keep track of the number of elements in the given array which we\n \
    \   // are currently considering.\n    \n    // We will keep track of the number\
    \ of elements in the given array which we\n    // are currently considering.\n\
    \    \n    // We will keep track of the number of elements in the given array\
    \ which we\n    // are currently considering.\n    \n    // We will keep track\
    \ of the number of elements in the given array which we\n    // are currently\
    \ considering.\n    \n    // We will keep track of the number of elements in the\
    \ given array which we\n    // are currently considering.\n    \n    // We will\
    \ keep track of the number of elements in the given array which we\n    // are\
    \ currently considering.\n    \n    // We will keep track of the number of elements\
    \ in the given array which we\n    // are currently considering.\n    \n    //\
    \ We will keep track of the number of elements in the given array which we\n \
    \   // are currently considering.\n    \n    // We will keep track of the number\
    \ of elements in the given array which we\n    // are currently considering.\n\
    \    \n    // We will keep track of the number of elements in the given array\
    \ which we\n    // are currently considering.\n    \n    // We will keep track\
    \ of the number of elements in the given array which we\n    // are currently\
    \ considering.\n    \n    // We will keep track of the number of elements in the\
    \ given array which we\n    // are currently considering.\n    \n    // We will\
    \ keep track of the number of elements in the given array which we\n    // are\
    \ currently consider\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprfe3w91t_test.go:103:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n        shift -= 1\n   \
    \ }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpf8vsj58h_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpf8vsj58h_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shifts performed\
    \ so far.\n    // We will start by performing the first right shift operation\
    \ and then\n    // we will perform the remaining right shift operations.\n   \
    \ shifts := 1\n    \n    // We will keep track of the last element of the array\
    \ which we will\n    // move to the starting position in the array i.e. 0th index.\n\
    \    lastElement := arr[len(arr)-1]\n    \n    // We will keep track of the number\
    \ of elements in the array which we\n    // will move to the starting position\
    \ in the array i.e. 0th index.\n    elements := 0\n    \n    // We will keep track\
    \ of the number of elements in the array which we\n    // will move to the starting\
    \ position in the array i.e. 0th index.\n    elements := 0\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // will move\
    \ to the starting position in the array i.e. 0th index.\n    elements := 0\n \
    \   \n    // We will keep track of the number of elements in the array which we\n\
    \    // will move to the starting position in the array i.e. 0th index.\n    elements\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // will move to the starting position in the array i.e. 0th index.\n\
    \    elements := 0\n    \n    // We will keep track of the number of elements\
    \ in the array which we\n    // will move to the starting position in the array\
    \ i.e. 0th index.\n    elements := 0\n    \n    // We will keep track of the number\
    \ of elements in the array which we\n    // will move to the starting position\
    \ in the array i.e. 0th index.\n    elements := 0\n    \n    // We will keep track\
    \ of the number of elements in the array which we\n    // will move to the starting\
    \ position in the array i.e. 0th index.\n    elements := 0\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // will move\
    \ to the starting position in the array i.e. 0th index.\n    elements := 0\n \
    \   \n    // We will keep track of the number of elements in the array which we\n\
    \    // will move to the starting position in the array i.e. 0th index.\n    elements\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // will move to the starting position in the array i.e. 0th index.\n\
    \    elements := 0\n    \n    // We will keep track of the number of elements\
    \ in the array which we\n    // will move to the starting position in the array\
    \ i.e. 0th index.\n    elements := 0\n    \n    // We will keep track of the number\
    \ of elements in the array which we\n    // will move to the starting position\
    \ in the array \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn0kenzx9_test.go:93:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n        shift -= 1\n   \
    \ }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpf8vsj58h_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpf8vsj58h_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n        shift -= 1\n   \
    \ }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpf8vsj58h_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpf8vsj58h_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)]\n    \n    shift := len(arr) - 1\n   \
    \ \n    for i := 0; i < len(arr); i++ {\n        arr[i] = arr[i]>>1\n        \n\
    \        if arr[i] > arr[i-1] {\n            arr[i] = arr[i-1]\n            arr[i-1]\
    \ = arr[i]>>1\n            arr[i] = arr[i]<<1\n            arr[i-1] = arr[i-1]<<1\n\
    \            arr[i] = arr[i]>>1\n            arr[i-1] = arr[i-1]>>1\n        \
    \    arr[i] = arr[i]<<1\n            arr[i-1] = arr[i-1]<<1\n            arr[i]\
    \ = arr[i]>>1\n            arr[i-1] = arr[i-1]>>1\n            arr[i] = arr[i]<<1\n\
    \            arr[i-1] = arr[i-1]<<1\n            arr[i] = arr[i]>>1\n        \
    \    arr[i-1] = arr[i-1]>>1\n            arr[i] = arr[i]<<1\n            arr[i-1]\
    \ = arr[i-1]<<1\n            arr[i] = arr[i]>>1\n            arr[i-1] = arr[i-1]>>1\n\
    \            arr[i] = arr[i]<<1\n            arr[i-1] = arr[i-1]<<1\n        \
    \    arr[i] = arr[i]>>1\n            arr[i-1] = arr[i-1]>>1\n            arr[i]\
    \ = arr[i]<<1\n            arr[i-1] = arr[i-1]<<1\n            arr[i] = arr[i]>>1\n\
    \            arr[i-1] = arr[i-1]>>1\n            arr[i] = arr[i]<<1\n        \
    \    arr[i-1] = arr[i-1]<<1\n            arr[i] = arr[i]>>1\n            arr[i-1]\
    \ = arr[i-1]>>1\n            arr[i] = arr[i]<<1\n            arr[i-1] = arr[i-1]<<1\n\
    \            arr[i] = arr[i]>>1\n            arr[i-1] = arr[i-1]>>1\n        \
    \    arr[i] = arr[i]<<1\n            arr[i-1] = arr[i-1]<<1\n            arr[i]\
    \ = arr[i]>>1\n            arr[i-1] = arr[i-1]>>1\n            arr[i] = arr[i]<<1\n\
    \            arr[i-1] = arr[i-1]<<1\n            arr[i] = arr[i]>>1\n        \
    \    arr[i-1] = arr[i-1]>>1\n            arr[i] = arr[i]<<1\n            arr[i-1]\
    \ = arr[i-1]<<1\n            arr[i] = arr[i]>>1\n            arr[i-1] = arr[i-1]>>1\n\
    \            arr[i] = arr[i]<<1\n            arr[i-1] = arr[i-1]<<1\n        \
    \    arr[i] = arr[i]>>1\n            arr[i-1] = arr[i-1]>>1\n            arr[i]\
    \ = arr[i]<<1\n            arr[i-1] = arr[i-1]<<1\n            arr[i] = arr[i]>>1\n\
    \            arr\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk84pus6q_test.go:96:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa1c19d44_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa1c19d44_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := len(arr) - 1\n    j := 0\n    \n    for {\n        if j\
    \ == i {\n            break\n        }\n        \n        if arr[i] > arr[j] {\n\
    \            arr[i], arr[j] = arr[j], arr[i]\n            i++\n            j++\n\
    \        } else {\n            j++\n        }\n    }\n    \n    return i == len(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpvjifnf16_test.go:42\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpvjifnf16_test.go:61\
    \ +0x573\ntesting.tRunner(0xc000103380, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift :=\
    \ len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <\
    \ arr[shift] {\n            shift += 1\n        }\n    }\n    \n    if shift <\
    \ len(arr) {\n        return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp48vbfo8r_test.go:46:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    return len(arr)\
    \ == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvs402d3l_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvs402d3l_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    return arr[0] ==\
    \ 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpnq7fduc9_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpnq7fduc9_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    return arr[0] ==\
    \ 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpnq7fduc9_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpnq7fduc9_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shift operations\
    \ performed so far.\n    // We will increment the count every time we perform\
    \ a right shift operation.\n    // We will decrement the count every time we perform\
    \ a left shift operation.\n    // We will keep track of the number of right shift\
    \ operations performed so far.\n    var count int\n    \n    // We will keep track\
    \ of the number of left shift operations performed so far.\n    // We will increment\
    \ the count every time we perform a left shift operation.\n    // We will decrement\
    \ the count every time we perform a right shift operation.\n    // We will keep\
    \ track of the number of left shift operations performed so far.\n    var countLeft\
    \ int\n    \n    // We will keep track of the number of right shift operations\
    \ performed so far.\n    // We will increment the count every time we perform\
    \ a right shift operation.\n    // We will decrement the count every time we perform\
    \ a left shift operation.\n    // We will keep track of the number of right shift\
    \ operations performed so far.\n    var countRight int\n    \n    // We will keep\
    \ track of the number of left shift operations performed so far.\n    // We will\
    \ increment the count every time we perform a left shift operation.\n    // We\
    \ will decrement the count every time we perform a right shift operation.\n  \
    \  // We will keep track of the number of left shift operations performed so far.\n\
    \    var countLeftRight int\n    \n    // We will keep track of the number of\
    \ right shift operations performed so far.\n    // We will increment the count\
    \ every time we perform a right shift operation.\n    // We will decrement the\
    \ count every time we perform a left shift operation.\n    // We will keep track\
    \ of the number of right shift operations performed so far.\n    var countRightLeft\
    \ int\n    \n    // We will keep track of the number of left shift operations\
    \ performed so far.\n    // We will increment the count every time we perform\
    \ a left shift operation.\n    // We will decrement the count every time we perform\
    \ a right shift operation.\n    // We will keep track of the number of left shift\
    \ operations performed so far.\n    var countLeftLeftRight int\n    \n    // We\
    \ will keep track of the number of right shift operations performed so far.\n\
    \    // We will increment the count every time we perform a right shift operation.\n\
    \    // We will decrement the count every time we perform a left shift operation.\n\
    \    // We will keep track of the number of right shift operations performed so\
    \ far.\n    var countRightRightLeft int\n    \n    // We will keep track of the\
    \ number of left shift operations performed so far.\n    // We will increment\
    \ the count every time we perform a left shift operation.\n    // We will decrement\
    \ the count every time we perform a right shift operation.\n    // We will keep\
    \ \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxd0iscpm_test.go:80:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            break\n        }\n    }\n    \n\
    \    return i == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmptc74iwxj_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmptc74iwxj_test.go:59\
    \ +0x505\ntesting.tRunner(0xc0001991e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \     \n        if i == shift {\n            arr[i] = 0\n            shift -=\
    \ 1\n        }\n    }\n    \n    return len(arr) == shift\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvp2x1peh_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvp2x1peh_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n  \
    \  \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp1esltnky_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n        shift -= 1\n   \
    \ }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpf8vsj58h_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpf8vsj58h_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    return len(arr)\
    \ == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvs402d3l_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvs402d3l_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            i++\n            j--\n        }\n\
    \        if i >= j {\n            break\n        }\n    }\n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp7um7glyz_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp7um7glyz_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170390\
    \ stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 20 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpo3fahzok_test.go:29 +0x72 fp=0xc0201703a0 sp=0xc020170398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703c8 sp=0xc0201703a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703f0 sp=0xc0201703c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170418 sp=0xc0201703f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170440 sp=0xc020170418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170468 sp=0xc020170440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170490 sp=0xc020170468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704b8 sp=0xc020170490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704e0 sp=0xc0201704b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170508 sp=0xc0201704e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] =\
    \ arr[i]<<1\n    }\n    \n    for i := 0; i < shift; i++ {\n        arr[i] = arr[i]>>1\n\
    \    }\n    \n    return arr[0] == 0\n}\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpjbooxif5_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpjbooxif5_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i] >> shift\n        shift -= 1\n    }\n    \n    return\
    \ len(arr) == 0 && arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0n9_9rb8_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0n9_9rb8_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    return len(arr)\
    \ == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvs402d3l_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvs402d3l_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpobowdhky_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpobowdhky_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n        shift -= 1\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpn_v4qiha_test.go:29 +0xbf fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef71f\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpn_v4qiha_test.go:43 +0x7f fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170390\
    \ stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 20 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpo3fahzok_test.go:29 +0x72 fp=0xc0201703a0 sp=0xc020170398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703c8 sp=0xc0201703a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703f0 sp=0xc0201703c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170418 sp=0xc0201703f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170440 sp=0xc020170418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170468 sp=0xc020170440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170490 sp=0xc020170468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704b8 sp=0xc020170490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704e0 sp=0xc0201704b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170508 sp=0xc0201704e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n\
    \        return move_one_ball(arr[:shift])\n    }\n    \n    return false\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f9128?,\
    \ 0x4b3193?})\n\t/tmp/tmp8k42qhb3_test.go:37 +0xa8\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmp8k42qhb3_test.go:57 +0xa8\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170390\
    \ stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 20 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpo3fahzok_test.go:29 +0x72 fp=0xc0201703a0 sp=0xc020170398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703c8 sp=0xc0201703a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703f0 sp=0xc0201703c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170418 sp=0xc0201703f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170440 sp=0xc020170418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170468 sp=0xc020170440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170490 sp=0xc020170468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704b8 sp=0xc020170490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704e0 sp=0xc0201704b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170508 sp=0xc0201704e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074398
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)]\n    \n    i := len(arr) - 1\n    \n \
    \   for j := 0; j < len(arr); j++ {\n        arr[i] = arr[j]\n        i -= 1\n\
    \    }\n    \n    arr[len(arr)-1] = 0\n    \n    return move_one_ball(arr)\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszw0_vho_test.go:34:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    for i :=\
    \ 0; i < len(arr); i++ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n  \
    \  }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpo1o5h7gf_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpo1o5h7gf_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n\
    \        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n \
    \           i, j = j, i\n        } else {\n            break\n        }\n    }\n\
    \    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvymjaiku_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvymjaiku_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074401
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)-1]\n    \n    i := 0\n    j := len(arr)\
    \ - 1\n    \n    for {\n        if arr[i] > arr[j] {\n            arr[i], arr[j]\
    \ = arr[j], arr[i]\n            i++\n            j--\n        } else {\n     \
    \       break\n        }\n    }\n    \n    return arr == arr[:len(arr)-1]\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc2_pjrgc_test.go:34:9: no new variables on left side of :=

    /tmp/tmpc2_pjrgc_test.go:49:12: invalid operation: arr == arr[:len(arr) - 1] (slice
    can only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074400
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)]\n    \n    for i := len(arr) - 1; i >\
    \ 0; i-- {\n        arr[i] = arr[i-1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfdhg46gw_test.go:34:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n     \
    \   if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n      \
    \      i++\n            j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpep7690tm_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpep7690tm_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We have two pointers left and right which point to two consecutive\
    \ \n    // elements in the given array. \n    // left points to the first element\
    \ in the given array and right points to\n    // the last element in the given\
    \ array.\n    left := 0\n    right := len(arr) - 1\n    \n    // We have two variables\
    \ left and right which point to two consecutive \n    // elements in the given\
    \ array. \n    // left points to the first element in the given array and right\
    \ points to\n    // the last element in the given array.\n    \n    // We have\
    \ two variables left and right which point to two consecutive \n    // elements\
    \ in the given array. \n    // left points to the first element in the given array\
    \ and right points to\n    // the last element in the given array.\n    \n   \
    \ // We have two variables left and right which point to two consecutive \n  \
    \  // elements in the given array. \n    // left points to the first element in\
    \ the given array and right points to\n    // the last element in the given array.\n\
    \    \n    // We have two variables left and right which point to two consecutive\
    \ \n    // elements in the given array. \n    // left points to the first element\
    \ in the given array and right points to\n    // the last element in the given\
    \ array.\n    \n    // We have two variables left and right which point to two\
    \ consecutive \n    // elements in the given array. \n    // left points to the\
    \ first element in the given array and right points to\n    // the last element\
    \ in the given array.\n    \n    // We have two variables left and right which\
    \ point to two consecutive \n    // elements in the given array. \n    // left\
    \ points to the first element in the given array and right points to\n    // the\
    \ last element in the given array.\n    \n    // We have two variables left and\
    \ right which point to two consecutive \n    // elements in the given array. \n\
    \    // left points to the first element in the given array and right points to\n\
    \    // the last element in the given array.\n    \n    // We have two variables\
    \ left and right which point to two consecutive \n    // elements in the given\
    \ array. \n    // left points to the first element in the given array and right\
    \ points to\n    // the last element in the given array.\n    \n    // We have\
    \ two variables left and right which point to two consecutive \n    // elements\
    \ in the given array. \n    // left points to the first element in the given array\
    \ and right points to\n    // the last element in the given array.\n    \n   \
    \ // We have two variables left and right which point to two consecutive \n  \
    \  // elements in the given array. \n    // left points to the first element in\
    \ the given array and right points to\n    // \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpch4wufkt_test.go:90:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := len(arr) - 1\n    j := 0\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            i++\n            j--\n        }\n        if i == 0 {\n          \
    \  return true\n        }\n    }\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpn8r62px4_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpn8r62px4_test.go:60\
    \ +0x599\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpw9ojbba5_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            break\n        }\n    }\n    \n\
    \    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpl9jgikn0_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpl9jgikn0_test.go:59\
    \ +0x53f\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n\
    \        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n \
    \           i++\n            j--\n        } else {\n            break\n      \
    \  }\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppsx0pdxg_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppsx0pdxg_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074401
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    shift += 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   shift += 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] >\
    \ arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    shift += 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr == arr[:shift]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmhi67x2q_test.go:66:12: invalid operation: arr == arr[:shift] (slice can
    only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>(shift - i)\n      \
    \  shift -= i\n    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: negative shift\
    \ amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp8lljqcwv_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp8lljqcwv_test.go:52\
    \ +0x53b\ntesting.tRunner(0xc0001924e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0] = arr[shift]\n    \n    return move_one_ball(arr[1:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpk0d5w63q_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpk0d5w63q_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa1c19d44_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \     \n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ arr == move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpggn7i8mz_test.go:44:19: invalid operation: arr == move_one_ball(arr) (mismatched
    types []int and bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa1c19d44_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and will keep track of the last element in the array which\
    \ will be\n    // moved to the starting position in the array i.e. 0th index.\n\
    \    right_shift_count := 0\n    \n    // We will keep track of the last element\
    \ in the array which will be\n    // moved to the starting position in the array\
    \ i.e. 0th index.\n    last_element := arr[0]\n    \n    // We will keep track\
    \ of the number of right shift operations performed\n    // and will keep track\
    \ of the last element in the array which will be\n    // moved to the starting\
    \ position in the array i.e. 0th index.\n    right_shift_count := 0\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // and will keep track of the last element in the array which will be\n  \
    \  // moved to the starting position in the array i.e. 0th index.\n    last_element\
    \ := arr[0]\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and will keep track of the last element in the array which\
    \ will be\n    // moved to the starting position in the array i.e. 0th index.\n\
    \    right_shift_count := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed\n    // and will keep track of the last element\
    \ in the array which will be\n    // moved to the starting position in the array\
    \ i.e. 0th index.\n    last_element := arr[0]\n    \n    // We will keep track\
    \ of the number of right shift operations performed\n    // and will keep track\
    \ of the last element in the array which will be\n    // moved to the starting\
    \ position in the array i.e. 0th index.\n    right_shift_count := 0\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // and will keep track of the last element in the array which will be\n  \
    \  // moved to the starting position in the array i.e. 0th index.\n    last_element\
    \ := arr[0]\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and will keep track of the last element in the array which\
    \ will be\n    // moved to the starting position in the array i.e. 0th index.\n\
    \    right_shift_count := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed\n    // and will keep track of the last element\
    \ in the array which will be\n    // moved to the starting position in the array\
    \ i.e. 0th index.\n    last_element := arr[0]\n    \n    // We will keep track\
    \ of the number of right shift operations performed\n    // and will keep track\
    \ of the last element in the array which will be\n    // moved to the starting\
    \ position in the array i.e. 0th index.\n    right_shift_count := 0\n    \n  \
    \  // \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2ox8vjdx_test.go:89:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpbs4o7y61_test.go:29 +0x85 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift--\n        }\n    }\n    \n    return arr[0] == 0\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpzxunvn31_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpzxunvn31_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // to achieve non-decreasing order\n    var shiftCount int =\
    \ 0\n    \n    // Keep track of the last element of the array \n    var lastElement\
    \ int = 0\n    \n    // Keep track of the last element of the array \n    var\
    \ firstElement int = 0\n    \n    // Keep track of the first element of the array\
    \ \n    var secondElement int = 0\n    \n    // Keep track of the first element\
    \ of the array \n    var thirdElement int = 0\n    \n    // Keep track of the\
    \ first element of the array \n    var fourthElement int = 0\n    \n    // Keep\
    \ track of the first element of the array \n    var fifthElement int = 0\n   \
    \ \n    // Keep track of the first element of the array \n    var sixthElement\
    \ int = 0\n    \n    // Keep track of the first element of the array \n    var\
    \ seventhElement int = 0\n    \n    // Keep track of the first element of the\
    \ array \n    var eighthElement int = 0\n    \n    // Keep track of the first\
    \ element of the array \n    var ninthElement int = 0\n    \n    // Keep track\
    \ of the first element of the array \n    var tenthElement int = 0\n    \n   \
    \ // Keep track of the first element of the array \n    var eleventhElement int\
    \ = 0\n    \n    // Keep track of the first element of the array \n    var twelfthElement\
    \ int = 0\n    \n    // Keep track of the first element of the array \n    var\
    \ thirteenthElement int = 0\n    \n    // Keep track of the first element of the\
    \ array \n    var fourteenthElement int = 0\n    \n    // Keep track of the first\
    \ element of the array \n    var fifteenthElement int = 0\n    \n    // Keep track\
    \ of the first element of the array \n    var sixteenthElement int = 0\n    \n\
    \    // Keep track of the first element of the array \n    var seventeenthElement\
    \ int = 0\n    \n    // Keep track of the first element of the array \n    var\
    \ eighteenthElement int = 0\n    \n    // Keep track of the first element of the\
    \ array \n    var nineteenthElement int = 0\n    \n    // Keep track of the first\
    \ element of the array \n    var twentiethElement int = 0\n    \n    // Keep track\
    \ of the first element of the array \n    var twentyFirstElement int = 0\n   \
    \ \n    // Keep track of the first element of the array \n    var twentySecondElement\
    \ int = 0\n    \n    // Keep track of the first element of the array \n    var\
    \ twentyThirdElement int = 0\n    \n    // Keep track of the first element of\
    \ the array \n    var twentyFourthElement int = 0\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd3w64sbx_test.go:113:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    return arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp6ydb2kic_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp6ydb2kic_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i] >> shift\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpaq7zu2n6_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpaq7zu2n6_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpw9ojbba5_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            break\n        }\n    }\n    \n\
    \    return len(arr) == j\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpt62mxfa3_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpt62mxfa3_test.go:59\
    \ +0x512\ntesting.tRunner(0xc000192680, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n     \
    \   if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n      \
    \      i++\n            j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpep7690tm_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpep7690tm_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074398
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        arr[i], arr[len(arr)-i-1] = arr[len(arr)-i-1], arr[i]\n    }\n\
    \    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppvuvqkcd_test.go:34:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170390\
    \ stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 20 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpo3fahzok_test.go:29 +0x72 fp=0xc0201703a0 sp=0xc020170398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703c8 sp=0xc0201703a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201703f0 sp=0xc0201703c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170418 sp=0xc0201703f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170440 sp=0xc020170418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170468 sp=0xc020170440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170490 sp=0xc020170468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704b8 sp=0xc020170490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc0201704e0 sp=0xc0201704b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpo3fahzok_test.go:40 +0x54 fp=0xc020170508 sp=0xc0201704e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04016fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074398
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift :=\
    \ len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] >\
    \ arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if shift >\
    \ 0 {\n        return false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpytw2zurs_test.go:46:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0],\
    \ arr[0] = arr[0], arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmppzlvvk7n_test.go:29 +0x72 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] =\
    \ arr[i]>>shift\n        arr[i] = arr[i]<<shift\n    }\n    \n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpnijuit1w_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpnijuit1w_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0] = arr[shift]\n    \n    return move_one_ball(arr[1:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpk0d5w63q_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpk0d5w63q_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)-1]\n    arr[len(arr)-1] = arr[0]\n    arr[0]\
    \ = arr[len(arr)-1]\n    \n    for i := 0; i < len(arr)-1; i++ {\n        for\
    \ j := 0; j < len(arr)-i-1; j++ {\n            if arr[j] > arr[j+1] {\n      \
    \          arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n   \
    \ }\n    \n    return arr == arr[:len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpllbprcn9_test.go:34:9: no new variables on left side of :=

    /tmp/tmpllbprcn9_test.go:46:12: invalid operation: arr == arr[:len(arr) - 1] (slice
    can only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0],\
    \ arr[0] = arr[0], arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmppzlvvk7n_test.go:29 +0x72 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmppzlvvk7n_test.go:42 +0x54 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i] >> shift\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpaq7zu2n6_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpaq7zu2n6_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp7dpetctc_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp7dpetctc_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] =\
    \ arr[i]>>shift\n        arr[i] = arr[i]<<shift\n        shift -= 1\n    }\n \
    \   \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp5h_z2qjm_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp5h_z2qjm_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[i+1] {\n            shift -= 1\n        }\n     \
    \   arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return len(arr)\
    \ == 0 && move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f8d18?,\
    \ 0x4b3193?})\n\t/tmp/tmp578a3s3n_test.go:37 +0x89\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmp578a3s3n_test.go:53 +0xa8\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and compare it to the number of elements in the given array\n\
    \    var shiftCount int = 0\n    \n    // We will keep track of the number of\
    \ elements in the given array\n    var arrCount int = len(arr)\n    \n    // We\
    \ will keep track of the number of elements in the sorted array\n    var sortedCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the sorted\
    \ array\n    var sortedArr []int\n    \n    // We will keep track of the number\
    \ of elements in the sorted array\n    var sortedArrCount int = 0\n    \n    //\
    \ We will keep track of the number of elements in the sorted array\n    var sortedArrArr\
    \ []int\n    \n    // We will keep track of the number of elements in the sorted\
    \ array\n    var sortedArrArrCount int = 0\n    \n    // We will keep track of\
    \ the number of elements in the sorted array\n    var sortedArrArrArr []int\n\
    \    \n    // We will keep track of the number of elements in the sorted array\n\
    \    var sortedArrArrArrCount int = 0\n    \n    // We will keep track of the\
    \ number of elements in the sorted array\n    var sortedArrArrArrArrCount int\
    \ = 0\n    \n    // We will keep track of the number of elements in the sorted\
    \ array\n    var sortedArrArrArrArrArrCount int = 0\n    \n    // We will keep\
    \ track of the number of elements in the sorted array\n    var sortedArrArrArrArrArrArrCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the sorted\
    \ array\n    var sortedArrArrArrArrArrArrArrCount int = 0\n    \n    // We will\
    \ keep track of the number of elements in the sorted array\n    var sortedArrArrArrArrArrArrArrArrCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the sorted\
    \ array\n    var sortedArrArrArrArrArrArrArrArrArrCount int = 0\n    \n    //\
    \ We will keep track of the number of elements in the sorted array\n    var sortedArrArrArrArrArrArrArrArrArrArrCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the sorted\
    \ array\n    var sortedArrArrArrArrArrArrArrArrArrArrArrCount int = 0\n    \n\
    \    // We will keep track of the number of elements in the sorted array\n   \
    \ var sortedArrArrArrArrArrArrArrArrArrArrArrArrCount int = 0\n    \n    // We\
    \ will keep track of the number of elements in the sorted array\n    var sortedArrArrArrArrArrArrArrArrArrArrArrArrArrCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the sorted\
    \ array\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo1am5l9e_test.go:93:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]<<1\n        arr[i] |= arr[i]>>(shift-1)\n       \
    \ arr[i] = arr[i]>>1\n    }\n    \n    return arr[0] == 0\n}\n</code>\n<|/ a tags=algorithm,sorting,arrays\
    \ |>\n<| a tags=algorithm,sorting,arrays |>\n<code>\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <time.h>\n\n#define N 5\n\nint main(void) {\n    int i,\
    \ j, temp;\n    int arr[N];\n    srand(time(NULL));\n    for (i = 0; i < N; i++)\
    \ {\n        arr[i] = rand() % N;\n    }\n    for (i = 0; i < N; i++) {\n    \
    \    for (j = i + 1; j < N; j++) {\n            if (arr[i] > arr[j]) {\n     \
    \           temp = arr[i];\n                arr[i] = arr[j];\n               \
    \ arr[j] = temp;\n            }\n        }\n    }\n    for (i = 0; i < N; i++)\
    \ {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return\
    \ 0;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <time.h>\n\n#define N 5\n\nint main(void) {\n    int i,\
    \ j, temp;\n    int arr[N];\n    srand(time(NULL));\n    for (i = 0; i < N; i++)\
    \ {\n        arr[i] = rand() % N;\n    }\n    for (i = 0; i < N; i++) {\n    \
    \    for (j = i + 1; j < N; j++) {\n            if (arr[i] > arr[j]) {\n     \
    \           temp = arr[i];\n                arr[i] = arr[j];\n               \
    \ arr[j] = temp;\n            }\n        }\n    }\n    for (i = 0; i < N; i++)\
    \ {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return\
    \ 0;\n}\n</code>\n<|/ a tags=algorithm,sorting,arrays dscore=0 |>\n<| c |>\nPlease\
    \ add some explanation to your answer such that others can learn from it\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include\
    \ <time.h>\n\n#define N 5\n\nint main(void) {\n    int i, j, temp;\n    int arr[N];\n\
    \    srand(time(NULL));\n    for (i = 0; i < N; i++) {\n        arr[i] = rand()\
    \ % N;\n    }\n    for (i = 0; i < N; i++) {\n        for (j = i + 1; j < N; j++)\
    \ {\n            if (arr[i] > arr[j]) {\n                temp = arr[i];\n    \
    \            arr[i] = arr[j];\n                arr[j] = temp;\n            }\n\
    \        }\n    }\n    for (i = 0; i < \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcq3x4920_test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr := arr[:len(arr)-1]\n    arr[len(arr)-1] = arr[0]\n    arr[0]\
    \ = arr[len(arr)-1]\n    \n    for i := 0; i < len(arr)-1; i++ {\n        for\
    \ j := 0; j < len(arr)-i-1; j++ {\n            if arr[j] > arr[j+1] {\n      \
    \          arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n   \
    \ }\n    \n    return arr == arr[:len(arr)-1]\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=arrays,algorithm,sorting |>\n<code>\npublic boolean moveOneBall(int[]\
    \ arr) {\n    int n = arr.length;\n    int temp;\n    boolean flag = true;\n \
    \   for(int i = 1; i < n; i++) {\n        for(int j = 0; j < i; j++) {\n     \
    \       if(arr[j] > arr[j+1]) {\n                temp = arr[j];\n            \
    \    arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                flag\
    \ = false;\n            }\n        }\n    }\n    return flag;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic boolean moveOneBall(int[] arr)\
    \ {\n    int n = arr.length;\n    int temp;\n    boolean flag = true;\n    for(int\
    \ i = 1; i < n; i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j]\
    \ > arr[j+1]) {\n                temp = arr[j];\n                arr[j] = arr[j+1];\n\
    \                arr[j+1] = temp;\n                flag = false;\n           \
    \ }\n        }\n    }\n    return flag;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting\
    \ |>\n<| a dscore=1 |>\n<code>\npublic boolean moveOneBall(int[] arr) {\n    int\
    \ n = arr.length;\n    int temp;\n    boolean flag = true;\n    for(int i = 1;\
    \ i < n; i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j] >\
    \ arr[j+1]) {\n                temp = arr[j];\n                arr[j] = arr[j+1];\n\
    \                arr[j+1] = temp;\n                flag = false;\n           \
    \ }\n        }\n    }\n    return flag;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting\
    \ |>\n<| a tags=arrays,algorithm,sorting |>\n<code>\npublic boolean moveOneBall(int[]\
    \ arr) {\n    int n = arr.length;\n    int temp;\n    boolean flag = true;\n \
    \   for(int i = 1; i < n; i++) {\n        for(int j = 0; j < i; j++) {\n     \
    \       if(arr[j] > arr[j+1]) {\n                temp = arr[j];\n            \
    \    arr[j] = \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpje38hyxk_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpw9ojbba5_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We are going to perform right shift operation on the given\
    \ array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going to perform right\
    \ shift operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    // We are going to perform right shift operation\
    \ on the given array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going\
    \ to perform right shift operation on the given array\n    // arr[1], arr[2],\
    \ ..., arr[N]\n    // We are going to perform right shift operation on the given\
    \ array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going to perform right\
    \ shift operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    // We are going to perform right shift operation\
    \ on the given array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going\
    \ to perform right shift operation on the given array\n    // arr[1], arr[2],\
    \ ..., arr[N]\n    // We are going to perform right shift operation on the given\
    \ array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going to perform right\
    \ shift operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    // We are going to perform right shift operation\
    \ on the given array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going\
    \ to perform right shift operation on the given array\n    // arr[1], arr[2],\
    \ ..., arr[N]\n    // We are going to perform right shift operation on the given\
    \ array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going to perform right\
    \ shift operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr[2], ..., arr[N]\n    // We are going to perform right shift operation\
    \ on the given array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going\
    \ to perform right shift operation on the given array\n    // arr[1], arr[2],\
    \ ..., arr[N]\n    // We are going to perform right shift operation on the given\
    \ array\n    // arr[1], arr[2], ..., arr[N]\n    // We are going to perform right\
    \ shift operation on the given array\n    // arr[1], arr[2], ..., arr[N]\n   \
    \ // We are going to perform right shift operation on the given array\n    //\
    \ arr[1], arr\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg7wzst7m_test.go:80:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpw9ojbba5_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpw9ojbba5_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < shift; i++ {\n\
    \        arr[i] = arr[i]<<1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i] = arr[i]>>1\n    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmphckn18h1_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmphckn18h1_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpbs4o7y61_test.go:29 +0x85 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift--\n        }\n    }\n    \n    return arr[0] == 0\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpzxunvn31_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpzxunvn31_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if arr[0] == arr[shift] {\n        return true\n    }\n    \n \
    \   return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp252se7fr_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp252se7fr_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            break\n        }\n    }\n    \n\
    \    return i == len(arr) || j == -1\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpiuhjdrnv_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpiuhjdrnv_test.go:59\
    \ +0x512\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shift operations\
    \ performed.\n    // If after performing the right shift operation we still have\
    \ no\n    // non-decreasing elements then we know that we can obtain the sorted\n\
    \    // array by performing right shift operations.\n    var shift int = 0\n \
    \   \n    // We will keep track of the number of non-decreasing elements we have\n\
    \    // encountered so far.\n    var non_decreasing int = 0\n    \n    // We will\
    \ keep track of the number of elements in the given array that we\n    // have\
    \ already encountered in the given array.\n    var encountered map[int]bool =\
    \ make(map[int]bool)\n    \n    // We will keep track of the number of elements\
    \ in the given array that we\n    // have already encountered in the given array.\n\
    \    var encountered2 map[int]bool = make(map[int]bool)\n    \n    // We will\
    \ keep track of the number of elements in the given array that we\n    // have\
    \ already encountered in the given array.\n    var encountered3 map[int]bool =\
    \ make(map[int]bool)\n    \n    // We will keep track of the number of elements\
    \ in the given array that we\n    // have already encountered in the given array.\n\
    \    var encountered4 map[int]bool = make(map[int]bool)\n    \n    // We will\
    \ keep track of the number of elements in the given array that we\n    // have\
    \ already encountered in the given array.\n    var encountered5 map[int]bool =\
    \ make(map[int]bool)\n    \n    // We will keep track of the number of elements\
    \ in the given array that we\n    // have already encountered in the given array.\n\
    \    var encountered6 map[int]bool = make(map[int]bool)\n    \n    // We will\
    \ keep track of the number of elements in the given array that we\n    // have\
    \ already encountered in the given array.\n    var encountered7 map[int]bool =\
    \ make(map[int]bool)\n    \n    // We will keep track of the number of elements\
    \ in the given array that we\n    // have already encountered in the given array.\n\
    \    var encountered8 map[int]bool = make(map[int]bool)\n    \n    // We will\
    \ keep track of the number of elements in the given array that we\n    // have\
    \ already encountered in the given array.\n    var encountered9 map[int]bool =\
    \ make(map[int]bool)\n    \n    // We will keep track of the number of elements\
    \ in the given array that we\n    // have already encountered in the given array.\n\
    \    var encountered10 map[int]bool = make(map[int]bool)\n    \n    // We will\
    \ keep track of the number of elements in the given array that we\n    // have\
    \ already encountered in the given array.\n    var encoun\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2zd01v8u_test.go:86:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n  \
    \  \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp1esltnky_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n  \
    \  \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp1esltnky_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            i++\n            j--\n        }\n\
    \        if i == j {\n            break\n        }\n    }\n    return false\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpx8i8a40r_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpx8i8a40r_test.go:62\
    \ +0x532\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We are going to perform right shift operation on arr[0],\
    \ arr[1], ...\n    // arr[N-1].\n    // We will keep track of how many times we\
    \ perform right shift operation\n    // on arr[0], arr[1], ... arr[N-1].\n   \
    \ var count int = 0\n    for i := 0; i < len(arr); i++ {\n        // We are going\
    \ to perform right shift operation on arr[0], arr[1], ...\n        // arr[N-1].\n\
    \        // We will keep track of how many times we perform right shift operation\n\
    \        // on arr[0], arr[1], ... arr[N-1].\n        if arr[i] > arr[i-1] {\n\
    \            count++\n        }\n    }\n    \n    // We are going to perform right\
    \ shift operation on arr[0], arr[1], ...\n    // arr[N-1].\n    // We will keep\
    \ track of how many times we perform right shift operation\n    // on arr[0],\
    \ arr[1], ... arr[N-1].\n    if count > 1 {\n        return false\n    }\n   \
    \ \n    // We are going to perform right shift operation on arr[0], arr[1], ...\n\
    \    // arr[N-1].\n    // We will keep track of how many times we perform right\
    \ shift operation\n    // on arr[0], arr[1], ... arr[N-1].\n    if count == 1\
    \ {\n        arr[0] = 0\n    }\n    \n    // We are going to perform right shift\
    \ operation on arr[0], arr[1], ...\n    // arr[N-1].\n    // We will keep track\
    \ of how many times we perform right shift operation\n    // on arr[0], arr[1],\
    \ ... arr[N-1].\n    if count == 2 {\n        arr[0] = 1\n        arr[1] = 0\n\
    \    }\n    \n    // We are going to perform right shift operation on arr[0],\
    \ arr[1], ...\n    // arr[N-1].\n    // We will keep track of how many times we\
    \ perform right shift operation\n    // on arr[0], arr[1], ... arr[N-1].\n   \
    \ if count == 3 {\n        arr[0] = 1\n        arr[1] = 1\n        arr[2] = 0\n\
    \    }\n    \n    // We are going to perform right shift operation on arr[0],\
    \ arr[1], ...\n    // arr[N-1].\n    // We will keep track of how many times we\
    \ perform right shift operation\n    // on arr[0], arr[1], ... arr[N-1].\n   \
    \ if count == 4 {\n        arr[0] = 1\n        arr[1] = 1\n        arr[2] = 2\n\
    \        arr[3] = 0\n    }\n    \n    // We are going to perform right shift operation\
    \ on arr[0], arr[1], ...\n    // arr[N-1].\n    // We will keep track of how many\
    \ times we perform right shift operation\n    // on arr[0], arr[1], ... arr[N-1].\n\
    \    if count == 5 {\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkkn0zt1_test.go:100:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa1c19d44_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shift operations\
    \ performed on\n    // the given array\n    var shift int\n    \n    // We will\
    \ keep track of the number of elements in the given array\n    var size int\n\
    \    \n    // We will keep track of the last element in the given array\n    var\
    \ last int\n    \n    // We will keep track of the last element in the given array\n\
    \    var first int\n    \n    // We will keep track of the number of elements\
    \ in the given array\n    var size int\n    \n    // We will keep track of the\
    \ number of elements in the given array\n    var size int\n    \n    // We will\
    \ keep track of the number of elements in the given array\n    var size int\n\
    \    \n    // We will keep track of the number of elements in the given array\n\
    \    var size int\n    \n    // We will keep track of the number of elements in\
    \ the given array\n    var size int\n    \n    // We will keep track of the number\
    \ of elements in the given array\n    var size int\n    \n    // We will keep\
    \ track of the number of elements in the given array\n    var size int\n    \n\
    \    // We will keep track of the number of elements in the given array\n    var\
    \ size int\n    \n    // We will keep track of the number of elements in the given\
    \ array\n    var size int\n    \n    // We will keep track of the number of elements\
    \ in the given array\n    var size int\n    \n    // We will keep track of the\
    \ number of elements in the given array\n    var size int\n    \n    // We will\
    \ keep track of the number of elements in the given array\n    var size int\n\
    \    \n    // We will keep track of the number of elements in the given array\n\
    \    var size int\n    \n    // We will keep track of the number of elements in\
    \ the given array\n    var size int\n    \n    // We will keep track of the number\
    \ of elements in the given array\n    var size int\n    \n    // We will keep\
    \ track of the number of elements in the given array\n    var size int\n    \n\
    \    // We will keep track of the number of elements in the given array\n    var\
    \ size int\n    \n    // We will keep track of the number of elements in the given\
    \ array\n    var size int\n    \n    // We will keep track of the number of elements\
    \ in the given array\n    var size int\n    \n    // We will keep track of the\
    \ number of elements in the given array\n    var size int\n    \n    // We will\
    \ keep track of the number of elements in the given array\n    var size int\n\
    \    \n    // We will keep track of the number of elements in the given array\n\
    \    var size int\n    \n    // We will keep track of the number of elements in\
    \ the given array\n    var size int\n    \n    // We will keep track of the number\
    \ of element\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqkl92b9x_test.go:117:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // Find the first element in the array that is greater than\
    \ the last element\n    // of the array\n    i := len(arr) - 1\n    for arr[i]\
    \ > arr[i+1] {\n        i--\n    }\n    \n    // Perform right shift operation\
    \ on the array starting from i\n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ >>= 1\n    }\n    \n    // Move the last element to the first position\n   \
    \ arr[0] = arr[i]\n    \n    // Perform right shift operation on the array starting\
    \ from 0\n    for i := 0; i < len(arr); i++ {\n        arr[i] >>= 1\n    }\n \
    \   \n    // Check if the array is non-decreasing\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] < arr[i-1] {\n            return false\n        }\n\
    \    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0001d2640?, 0xc000190eb8?,\
    \ 0x4b3193?})\n\t/tmp/tmpmayrzd2x_test.go:37 +0xe5\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpmayrzd2x_test.go:71 +0xa8\ntesting.tRunner(0xc000198ea0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0] = arr[shift]\n    \n    return move_one_ball(arr[1:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpk0d5w63q_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpk0d5w63q_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // The array is sorted in non-decreasing order if and only if\
    \ all the\n    // elements are in increasing order.\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[i+1] {\n            return false\n        }\n\
    \    }\n    \n    // The array is sorted in non-decreasing order if and only if\
    \ all the\n    // elements are in increasing order.\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] < arr[i+1] {\n            return false\n        }\n\
    \    }\n    \n    // The array is sorted in non-decreasing order if and only if\
    \ all the\n    // elements are in increasing order.\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[i+1] {\n            return false\n        }\n\
    \    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpxo64cy04_test.go:78: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpxo64cy04_test.go:78:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We are going to perform right shift operation N times. \n\
    \    // For each right shift operation we move the element at 0th index to the\n\
    \    // starting position in the array i.e. 0th index.\n    // For example if\
    \ we have arr = [1, 2, 3, 4, 5] then after performing\n    // right shift operation\
    \ on arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing the right\
    \ shift operation on arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing\
    \ the right shift operation on arr we will have arr = [1, 2, 0, 4, 5]\n    //\
    \ After performing the right shift operation on arr we will have arr = [1, 2,\
    \ 0, 4, 5]\n    // After performing the right shift operation on arr we will have\
    \ arr = [1, 2, 0, 4, 5]\n    // After performing the right shift operation on\
    \ arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing the right shift\
    \ operation on arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing\
    \ the right shift operation on arr we will have arr = [1, 2, 0, 4, 5]\n    //\
    \ After performing the right shift operation on arr we will have arr = [1, 2,\
    \ 0, 4, 5]\n    // After performing the right shift operation on arr we will have\
    \ arr = [1, 2, 0, 4, 5]\n    // After performing the right shift operation on\
    \ arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing the right shift\
    \ operation on arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing\
    \ the right shift operation on arr we will have arr = [1, 2, 0, 4, 5]\n    //\
    \ After performing the right shift operation on arr we will have arr = [1, 2,\
    \ 0, 4, 5]\n    // After performing the right shift operation on arr we will have\
    \ arr = [1, 2, 0, 4, 5]\n    // After performing the right shift operation on\
    \ arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing the right shift\
    \ operation on arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing\
    \ the right shift operation on arr we will have arr = [1, 2, 0, 4, 5]\n    //\
    \ After performing the right shift operation on arr we will have arr = [1, 2,\
    \ 0, 4, 5]\n    // After performing the right shift operation on arr we will have\
    \ arr = [1, 2, 0, 4, 5]\n    // After performing the right shift operation on\
    \ arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing the right shift\
    \ operation on arr we will have arr = [1, 2, 0, 4, 5]\n    // After performing\
    \ the right shift operation on arr we will have arr = [1, 2, 0, 4, 5]\n    //\
    \ After performing the right shift operation on arr we will \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph9ucsb42_test.go:62:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n        shift -= 1\n   \
    \ }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpqvbfzrby_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpqvbfzrby_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    shift += 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   return arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmppjq88rjy_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmppjq88rjy_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] =\
    \ arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i]\
    \ = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n      \
    \  arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptfqy5co9_test.go:98:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            i++\n            j--\n        }\n\
    \        if i == j {\n            break\n        }\n    }\n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpf2g25zt0_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpf2g25zt0_test.go:62\
    \ +0x525\ntesting.tRunner(0xc00019b040, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpbs4o7y61_test.go:29 +0x85 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    return len(arr)\
    \ == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvs402d3l_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvs402d3l_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0] = arr[shift]\n    \n    return move_one_ball(arr[1:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpk0d5w63q_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpk0d5w63q_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            break\n        }\n    }\n    \n\
    \    return i == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmptc74iwxj_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmptc74iwxj_test.go:59\
    \ +0x505\ntesting.tRunner(0xc0001991e0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    return len(arr)\
    \ == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvs402d3l_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvs402d3l_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074400
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] =\
    \ arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i]\
    \ = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n      \
    \  arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptfqy5co9_test.go:98:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    shift += 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   return arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmppjq88rjy_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmppjq88rjy_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpw9ojbba5_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpw9ojbba5_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074401
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0], arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpa1c19d44_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpa1c19d44_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    shift += 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   return arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmppjq88rjy_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmppjq88rjy_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpbs4o7y61_test.go:29 +0x85 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpbs4o7y61_test.go:42 +0x65 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    arr[0] = arr[shift]\n    \n    return move_one_ball(arr[1:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpk0d5w63q_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpk0d5w63q_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    return arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp6ydb2kic_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp6ydb2kic_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074402
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // so far.\n    shift := 0\n    \n    // We will keep track of\
    \ the last element of the array i.e. arr[N-1].\n    // We will compare this with\
    \ the current element of the array i.e. arr[i].\n    // If they are equal then\
    \ we will increment the shift by 1.\n    // If shift is greater than or equal\
    \ to N, then we will return false.\n    // If shift is less than N, then we will\
    \ return true.\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[len(arr)-1]\
    \ {\n            shift += 1\n        }\n        if shift >= len(arr) {\n     \
    \       return false\n        }\n    }\n    return true\n}\n</code>\n<|/ a tags=algorithm,sorting,arrays\
    \ |>\n<| a tags=algorithm,sorting,arrays |>\n<code>\ndef move_one_ball(arr):\n\
    \    if len(arr) == 0:\n        return True\n    \n    shift = 0\n    \n    for\
    \ i in range(len(arr)):\n        if arr[i] > arr[len(arr)-1]:\n            shift\
    \ += 1\n        if shift >= len(arr):\n            return False\n    \n    return\
    \ True\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your\
    \ answer such that others can learn from it\n<|/ c |>\n<| a |>\n<code>\ndef move_one_ball(arr):\n\
    \    if len(arr) == 0:\n        return True\n    \n    shift = 0\n    \n    for\
    \ i in range(len(arr)):\n        if arr[i] > arr[len(arr)-1]:\n            shift\
    \ += 1\n        if shift >= len(arr):\n            return False\n    \n    return\
    \ True\n</code>\n<|/ a tags=algorithm,sorting,arrays dscore=0 |>\n<| a tags=algorithm,sorting,arrays\
    \ |>\n<code>\ndef move_one_ball(arr):\n    if len(arr) == 0:\n        return True\n\
    \    \n    shift = 0\n    \n    for i in range(len(arr)):\n        if arr[i] >\
    \ arr[len(arr)-1]:\n            shift += 1\n        if shift >= len(arr):\n  \
    \          return False\n    \n    return True\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>\ndef move_one_ball(arr):\n    if len(arr) == 0:\n    \
    \    return True\n    \n    shift = 0\n    \n    for i in range(len(arr)):\n \
    \       if arr[i] > arr[len(arr)-1]:\n            shift += 1\n        if shift\
    \ >= len(arr):\n            return False\n    \n    return True\n</code>\n<|/\
    \ a tags=algorithm,sorting,arrays |>\n<| a dscore=0 |>\n<code>\ndef move_one_ball(arr):\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdgso3adm_test.go:53:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpkbipuorz_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpkbipuorz_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074397
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i] = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n  \
    \  \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp1esltnky_test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp1esltnky_test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074398
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[i+1] {\n            shift -= 1\n            arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        }\n    }\n    \n    return arr[0] ==\
    \ 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpzi7fhchd_test.go:37\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpzi7fhchd_test.go:53\
    \ +0x5d3\ntesting.tRunner(0xc0001031e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \     \n        if i == shift {\n            arr[i], arr[shift] = arr[shift],\
    \ arr[i]\n        }\n    }\n    \n    return len(arr) == 0 && move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmprb_pk2xm_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmprb_pk2xm_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074404
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++\
    \ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n    }\n    \n    return\
    \ move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmpzxg303j1_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmpzxg303j1_test.go:40 +0xb7 fp="
  timestamp: 1660074398
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    arr2 := make([]int, len(arr))\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        arr2[i] = arr[i]\n    }\n    \n    arr2 := append(arr2, arr[len(arr)])\n\
    \    \n    for i := len(arr) - 2; i >= 0; i-- {\n        arr2 := append(arr2,\
    \ arr[i])\n    }\n    \n    arr2 := append(arr2, arr[0])\n    \n    for i := 0;\
    \ i < len(arr); i++ {\n        if arr[i] > arr[i+1] {\n            return false\n\
    \        }\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7yktmxly_test.go:40:10: no new variables on left side of :=

    /tmp/tmp7yktmxly_test.go:43:9: arr2 declared but not used

    /tmp/tmp7yktmxly_test.go:46:10: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074403
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4,\
    \ 5, 1, 2})\n// true\n// Explanation: By performin 2 right shift operations, non-decreasing\
    \ order can\n// be achieved for the given array.\n// >>> move_one_ball([]int{3,\
    \ 5, 4, 1, 2})\n// false\n// Explanation:It is not possible to get non-decreasing\
    \ order for the given\n// array by performing any number of right shift operations.\n\
    func move_one_ball(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n\
    \    }\n    \n    n := len(arr)\n    \n    // We need to perform right shift operation\
    \ n times to get non-decreasing order.\n    // We need to perform right shift\
    \ operation n times to get non-decreasing order.\n    // We need to perform right\
    \ shift operation n times to get non-decreasing order.\n    // We need to perform\
    \ right shift operation n times to get non-decreasing order.\n    // We need to\
    \ perform right shift operation n times to get non-decreasing order.\n    // We\
    \ need to perform right shift operation n times to get non-decreasing order.\n\
    \    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-decreasing\
    \ order.\n    // We need to perform right shift operation n times to get non-\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpke8yee1j_test.go:67:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074403
