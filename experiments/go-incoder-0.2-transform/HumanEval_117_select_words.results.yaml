language: go_test.go
name: HumanEval_117_select_words
results:
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    words := append(words, s)\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdufubr7d_test.go:26:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075341
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnlate1en_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    \n    \n    return []string{}\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7dwjdc2r_test.go:51: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7dwjdc2r_test.go:51:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7dwjdc2r_test.go:51: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7dwjdc2r_test.go:51:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7dwjdc2r_test.go:51: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp4e6rls44_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp4e6rls44_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp4e6rls44_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp4e6rls44_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp4e6rls44_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            words\
    \ = append(words, letter)\n        }\n    }\n    \n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rn91egp_test.go:33:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    words := append(words, select_words_test.select_words(s,\
    \ n)...)\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0gv864az_test.go:26:11: no new variables on left side of :=

    /tmp/tmp0gv864az_test.go:26:28: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp98dfh4u3_test.go:280:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075425
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // TODO: Write your solution here\n    \n    return nil\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp34vp1_aa_test.go:50: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp34vp1_aa_test.go:50:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp34vp1_aa_test.go:50: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp34vp1_aa_test.go:50:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp34vp1_aa_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075341
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpts0cb44v_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpts0cb44v_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpts0cb44v_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpts0cb44v_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpts0cb44v_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyuq5zohf_test.go:282:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075336
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    words := make([]string, 0)\n    \n    if len(s) == 0 {\n      \
    \  return words\n    }\n    \n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n\
    \    \n    for _, letter := range s {\n        if !contains(vowels, letter) {\n\
    \            words = append(words, letter)\n        }\n    }\n    \n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4qadc4tb_test.go:35:13: undefined: contains

    /tmp/tmp4qadc4tb_test.go:36:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := []string{}\n    for _, word := range\
    \ strings.Split(s, \" \") {\n        if strings.ContainsAny(word, []rune(\"bcdfghjklmnpqrstvwxyz\"\
    )) {\n            words = append(words, word)\n        }\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo6peqfip_test.go:27:26: undefined: strings

    /tmp/tmpo6peqfip_test.go:28:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpsui424rq_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpsui424rq_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpsui424rq_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpsui424rq_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpsui424rq_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n \
    \           continue\n        }\n        \n        if strings.Contains(strings.ToLower(letter),\
    \ strings.ToLower(strings.Repeat(\"bcdfghjklmnpqrstvwxyz\", n))) == true {\n \
    \           words = append(words, letter)\n        }\n    }\n    \n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwm869ij_test.go:32:22: invalid operation: letter == " " (mismatched types
    rune and untyped string)

    /tmp/tmpnwm869ij_test.go:36:12: undefined: strings

    /tmp/tmpnwm869ij_test.go:37:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // Write your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpecyqt93z_test.go:50: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpecyqt93z_test.go:50:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpecyqt93z_test.go:50: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpecyqt93z_test.go:50:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpecyqt93z_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyuq5zohf_test.go:282:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075336
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    \n    return []string{}\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpsju9rvhw_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpsju9rvhw_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpsju9rvhw_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpsju9rvhw_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpsju9rvhw_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    if len(s) == 0 {\n        return words\n   \
    \ }\n    words := select_words_helper(s, n, words)\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3kxmqjvp_test.go:29:11: no new variables on left side of :=

    /tmp/tmp3kxmqjvp_test.go:29:14: undefined: select_words_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075341
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, word := range strings.Split(s, \" \") {\n        if strings.Contains(word,\
    \ strings.ToUpper(word)) {\n            words = append(words, word)\n        }\n\
    \    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n \
    \ candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm3y53d1g_test.go:31:26: undefined: strings

    /tmp/tmpm3y53d1g_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    \n    return []string{}\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp3ko2j_eg_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp3ko2j_eg_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp3ko2j_eg_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp3ko2j_eg_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp3ko2j_eg_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n \
    \           continue\n        }\n        \n        if n == 0 {\n            words\
    \ = append(words, letter)\n            continue\n        }\n        \n       \
    \ if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\"\
    \ || letter == \"u\" {\n            n -= 1\n            continue\n        }\n\
    \        \n        if letter == \"y\" || letter == \"u\" || letter == \"i\" ||\
    \ letter == \"o\" {\n            n -= 1\n            continue\n        }\n   \
    \     \n        if letter == \"o\" || letter == \"u\" || letter == \"i\" || letter\
    \ == \"a\" {\n            n -= 1\n            continue\n        }\n        \n\
    \        if letter == \"e\" || letter == \"i\" || letter == \"a\" || letter ==\
    \ \"o\" {\n            n -= 1\n            continue\n        }\n        \n   \
    \     if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"\
    o\" {\n            n -= 1\n            continue\n        }\n        \n       \
    \ if letter == \"y\" || letter == \"u\" || letter == \"i\" || letter == \"a\"\
    \ {\n            n -= 1\n            continue\n        }\n        \n        if\
    \ letter == \"u\" || letter == \"i\" || letter == \"a\" || letter == \"o\" {\n\
    \            n -= 1\n            continue\n        }\n        \n        if letter\
    \ == \"i\" || letter == \"a\" || letter == \"o\" || letter == \"u\" {\n      \
    \      n -= 1\n            continue\n        }\n        \n        if letter ==\
    \ \"y\" || letter == \"u\" || letter == \"i\" || letter == \"a\" {\n         \
    \   n -= 1\n            continue\n        }\n        \n        if letter == \"\
    a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" {\n            n\
    \ -= 1\n            continue\n        }\n        \n        if letter == \"y\"\
    \ || letter == \"u\" || letter == \"i\" || letter == \"a\" {\n            n -=\
    \ 1\n            continue\n        }\n        \n        if letter == \"u\" ||\
    \ letter == \"i\" || letter == \"a\" || letter == \"o\" {\n            n -= 1\n\
    \            continue\n        }\n        \n        if letter == \"i\" || letter\
    \ == \"a\" || letter == \"o\" || letter == \"u\" {\n            n -= 1\n     \
    \       continue\n        }\n        \n        if letter == \"y\" || letter ==\
    \ \"u\" || letter == \"i\" || letter == \"a\" {\n            n -= 1\n        \
    \    continue\n        }\n        \n        if letter == \"a\" || letter == \"\
    e\" || letter == \"i\" || letter == \"o\" {\n            n -= 1\n            continue\n\
    \        }\n        \n        if letter == \"y\" || letter == \"u\" || letter\
    \ == \"i\" || letter == \"a\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbpg7txc0_test.go:116:73: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075425
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnlate1en_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            words\
    \ = append(words, letter)\n        }\n    }\n    \n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoullnlde_test.go:33:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // TODO: Write your code here\n    \n    return nil\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpvfogmwkm_test.go:50: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpvfogmwkm_test.go:50:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpvfogmwkm_test.go:50: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpvfogmwkm_test.go:50:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpvfogmwkm_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    words := select_words_test.select_words(s, n,\
    \ words)\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyz2nm1c__test.go:26:11: no new variables on left side of :=

    /tmp/tmpyz2nm1c__test.go:26:14: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := []string{}\n    for _, word := range\
    \ strings.Split(s, \" \") {\n        if strings.ContainsAny(word, []rune(\"bcdfghjklmnpqrstvwxyz\"\
    )) {\n            words = append(words, word)\n        }\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo6peqfip_test.go:27:26: undefined: strings

    /tmp/tmpo6peqfip_test.go:28:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpsui424rq_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpsui424rq_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpsui424rq_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpsui424rq_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpsui424rq_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            words\
    \ = append(words, letter)\n        }\n    }\n    \n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rn91egp_test.go:33:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n \
    \           words = append(words, \"\")\n        } else {\n            count :=\
    \ 0\n            for _, letter := range s {\n                if letter == letter\
    \ {\n                    count++\n                }\n            }\n         \
    \   if count == n {\n                words = append(words, s)\n            }\n\
    \        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4_w3p62n_test.go:32:22: invalid operation: letter == " " (mismatched types
    rune and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := []string{}\n    for _, word := range\
    \ strings.Split(s, \" \") {\n        if strings.ContainsAny(word, []rune(\"bcdfghjklmnpqrstvwxyz\"\
    )) {\n            words = append(words, word)\n        }\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo6peqfip_test.go:27:26: undefined: strings

    /tmp/tmpo6peqfip_test.go:28:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n \
    \           continue\n        }\n        \n        for _, word := range select_words_test.select_words(s,\
    \ n) {\n            if word == letter {\n                words = append(words,\
    \ word)\n            }\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaeokji9l_test.go:32:22: invalid operation: letter == " " (mismatched types
    rune and untyped string)

    /tmp/tmpaeokji9l_test.go:36:30: undefined: select_words_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n  \
    \          continue\n        }\n        \n        if s[i] == 'a' || s[i] == 'e'\
    \ || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n            continue\n     \
    \   }\n        \n        if s[i] == 'y' {\n            if i+1 < len(s) && s[i+1]\
    \ == 'e' {\n                continue\n            }\n        }\n        \n   \
    \     if s[i] == 's' {\n            if i+1 < len(s) && s[i+1] == 'a' {\n     \
    \           continue\n            }\n        }\n        \n        if s[i] == 't'\
    \ {\n            if i+1 < len(s) && s[i+1] == 'a' {\n                continue\n\
    \            }\n        }\n        \n        if s[i] == 'h' || s[i] == 'o' ||\
    \ s[i] == 'w' {\n            if i+1 < len(s) && s[i+1] == 'l' {\n            \
    \    continue\n            }\n        }\n        \n        if s[i] == 'l' || s[i]\
    \ == 'l' || s[i] == 'e' {\n            if i+1 < len(s) && s[i+1] == 'l' {\n  \
    \              continue\n            }\n        }\n        \n        if s[i] ==\
    \ 'd' || s[i] == 'o' || s[i] == 'm' {\n            if i+1 < len(s) && s[i+1] ==\
    \ 'a' {\n                continue\n            }\n        }\n        \n      \
    \  if s[i] == 'c' || s[i] == 'a' || s[i] == 's' {\n            if i+1 < len(s)\
    \ && s[i+1] == 'a' {\n                continue\n            }\n        }\n   \
    \     \n        if s[i] == 'm' || s[i] == 'a' || s[i] == 'm' {\n            if\
    \ i+1 < len(s) && s[i+1] == 'a' {\n                continue\n            }\n \
    \       }\n        \n        if s[i] == 'p' || s[i] == 'a' || s[i] == 'p' {\n\
    \            if i+1 < len(s) && s[i+1] == 'a' {\n                continue\n  \
    \          }\n        }\n        \n        if s[i] == 'f' || s[i] == 'a' || s[i]\
    \ == 'f' {\n            if i+1 < len(s) && s[i+1] == 'a' {\n                continue\n\
    \            }\n        }\n        \n        if s[i] == 'b' || s[i] == 'e' ||\
    \ s[i] == 'b' {\n            if i+1 < len(s) && s[i+1] == 'e' {\n            \
    \    continue\n            }\n        }\n        \n        if s[i] == 'r' || s[i]\
    \ == 'e' || s[i] == 'r' {\n            if i+1 < len(s) && s[i+1] == 'e' {\n  \
    \              continue\n            }\n        }\n        \n        if s[i] ==\
    \ 'k' || s[i] == 'e' || s[i] == 'k' {\n            if i+1 < len(s) && s[i+1] ==\
    \ 'e' {\n                continue\n            }\n        }\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpejzdkl_9_test.go:117:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075425
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    words := strings.Split(s, \" \")\n    for _,\
    \ word := range words {\n        if strings.Contains(word, \"a\") {\n        \
    \    fmt.Println(\"a\")\n        }\n    }\n    return words\n}\n</code>\n<|/ q\
    \ tags=go |>\n<| c |>\nWhat is the question?\n<|/ c |>\n<| c |>\nThe question\
    \ is how do I get the program to return a list of words that contain the letter\
    \ \"a\" in the string\n<|/ c |>\n<| c |>\nThe question is not clear. Do you want\
    \ to find all words that contain \"a\" in the string? Or do you want to find all\
    \ words that contain \"a\" in the first n characters of the string? Or do you\
    \ want to find all words that contain \"a\" in the first n characters of the first\
    \ n characters of the string? Or do you want to find all words that contain \"\
    a\" in the first n characters of the first n characters of the first n characters\
    \ of the string? Or do you want to find all words that contain \"a\" in the first\
    \ n characters of the first n characters of the first n characters of the first\
    \ n characters of the string? Or do you want to find all words that contain \"\
    a\" in the first n characters of the first n characters of the first n characters\
    \ of the first n characters of the first n characters of the first n characters\
    \ of the string?\n<|/ c |>\n<| c |>\nI want to find all words that contain \"\
    a\" in the first n characters of the string\n<|/ c |>\n<| c |>\nI edited the question\
    \ to make it clearer\n<|/ c |>\n<| a tags=go |>\nThe question is not clear. Do\
    \ you want to find all words that contain \"a\" in the string? Or do you want\
    \ to find all words that contain \"a\" in the first n characters of the string?\
    \ Or do you want to find all words that contain \"a\" in the first n characters\
    \ of the first n characters of the string? Or do you want to find all words that\
    \ contain \"a\" in the first n characters of the first n characters of the first\
    \ n characters of the string? Or do you want to find all words that contain \"\
    a\" in the first n characters of the first n characters of the first n characters\
    \ of the first n characters of the string? Or do you want to find all words that\
    \ contain \"a\" in the first n characters of the first n characters of the first\
    \ n characters of the first n characters of the first n characters of the string?\n\
    I assume you want to find all words that contain \"a\" in the first n characters\
    \ of the string. \nThe function select_words returns a slice of strings. A slice\
    \ is a view of a slice of elements. A slice is like a pointer to a pointer to\
    \ a pointer to a pointer to a pointer to a pointer to a pointer to a pointer to\
    \ a pointer to a \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxe2ecm8o_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075425
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyuq5zohf_test.go:282:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075336
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            words\
    \ = append(words, letter)\n        }\n    }\n    \n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rn91egp_test.go:33:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnlate1en_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnlate1en_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n\
    \    }\n    words := select_words_helper(s, n, words)\n    return words\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf21pghur_test.go:29:11: no new variables on left side of :=

    /tmp/tmpf21pghur_test.go:29:14: undefined: select_words_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n \
    \           continue\n        }\n        \n        if strings.Contains(strings.ToLower(letter),\
    \ strings.ToLower(fmt.Sprintf(\"%c\", letter))) {\n            words = append(words,\
    \ letter)\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3_r482h3_test.go:32:22: invalid operation: letter == " " (mismatched types
    rune and untyped string)

    /tmp/tmp3_r482h3_test.go:36:12: undefined: strings

    /tmp/tmp3_r482h3_test.go:37:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n \
    \           continue\n        }\n        \n        if letter == \"a\" || letter\
    \ == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n      \
    \      continue\n        }\n        \n        if letter == \"y\" {\n         \
    \   if n == 1 {\n                continue\n            }\n            \n     \
    \       if n == 2 {\n                continue\n            }\n            \n \
    \           if n == 3 {\n                continue\n            }\n           \
    \ \n            if n == 4 {\n                continue\n            }\n       \
    \     \n            if n == 5 {\n                continue\n            }\n   \
    \         \n            if n == 6 {\n                continue\n            }\n\
    \            \n            if n == 7 {\n                continue\n           \
    \ }\n            \n            if n == 8 {\n                continue\n       \
    \     }\n            \n            if n == 9 {\n                continue\n   \
    \         }\n            \n            if n == 10 {\n                continue\n\
    \            }\n            \n            if n == 11 {\n                continue\n\
    \            }\n            \n            if n == 12 {\n                continue\n\
    \            }\n            \n            if n == 13 {\n                continue\n\
    \            }\n            \n            if n == 14 {\n                continue\n\
    \            }\n            \n            if n == 15 {\n                continue\n\
    \            }\n            \n            if n == 16 {\n                continue\n\
    \            }\n            \n            if n == 17 {\n                continue\n\
    \            }\n            \n            if n == 18 {\n                continue\n\
    \            }\n            \n            if n == 19 {\n                continue\n\
    \            }\n            \n            if n == 20 {\n                continue\n\
    \            }\n            \n            if n == 21 {\n                continue\n\
    \            }\n            \n            if n == 22 {\n                continue\n\
    \            }\n            \n            if n == 23 {\n                continue\n\
    \            }\n            \n            if n == 24 {\n                continue\n\
    \            }\n            \n            if n == 25 {\n                continue\n\
    \            }\n            \n            if n == 26 {\n                continue\n\
    \            }\n            \n            if n == 27 {\n                continue\n\
    \            }\n            \n            if n == 28 {\n                continue\n\
    \            }\n            \n            if n == 29 {\n                continue\n\
    \            }\n            \n            if n == 30 {\n                continue\n\
    \            }\n            \n            if n == 31 {\n                continue\n\
    \            }\n            \n            if n == 32 {\n                continue\n\
    \            }\n            \n            if n == 33 {\n                continue\n\
    \            }\n            \n            if n == 34 {\n                continue\n\
    \            }\n            \n            if n == 35 {\n                continue\n\
    \            }\n            \n            if n == 36 {\n                continue\n\
    \            }\n            \n            if n == 37 {\n                continue\n\
    \            }\n            \n            if n == 38 {\n                continue\n\
    \            }\n            \n            if n == 39 {\n                continue\n\
    \            }\n            \n            if n == 40 {\n                continue\n\
    \            }\n            \n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe6j3ntpx_test.go:202:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075425
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    \n    return []string{}\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpsju9rvhw_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpsju9rvhw_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpsju9rvhw_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpsju9rvhw_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpsju9rvhw_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    \n    for _,\
    \ letter := range s {\n        if !contains(vowels, letter) {\n            words\
    \ = append(words, letter)\n        }\n    }\n    \n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0vuhwczy_test.go:34:13: undefined: contains

    /tmp/tmp0vuhwczy_test.go:35:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpes1gb995_test.go:50: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpes1gb995_test.go:50:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpes1gb995_test.go:50: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpes1gb995_test.go:50:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpes1gb995_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyuq5zohf_test.go:282:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075336
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        letters := strings.Split(word, \"\")\n        if len(letters) ==\
    \ n {\n            words = append(words, word)\n        }\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyiw1ffiv_test.go:26:26: undefined: strings

    /tmp/tmpyiw1ffiv_test.go:27:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := make([]string, 0)\n    for _, word :=\
    \ range strings.Split(s, \" \") {\n        if strings.ContainsAny(word, []rune(\"\
    bcdfghjklmnpqrstvwxyz\")) {\n            words = append(words, word)\n       \
    \ }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx0kkdro1_test.go:27:26: undefined: strings

    /tmp/tmpx0kkdro1_test.go:28:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnlate1en_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    words := append(words, s)\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdufubr7d_test.go:26:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075341
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    \n    return []string{}\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpgmpzcfmb_test.go:50: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpgmpzcfmb_test.go:50:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpgmpzcfmb_test.go:50: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpgmpzcfmb_test.go:50:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpgmpzcfmb_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    if len(s) == 0 {\n        return words\n   \
    \ }\n    for _, word := range strings.Split(s, \" \") {\n        if strings.ContainsAny(word,\
    \ vowels) {\n            words = append(words, word)\n        }\n    }\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpizev1tjp_test.go:29:26: undefined: strings

    /tmp/tmpizev1tjp_test.go:30:12: undefined: strings

    /tmp/tmpizev1tjp_test.go:30:38: undefined: vowels

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := []string{}\n    \n    if len(s) == 0\
    \ {\n        return words\n    }\n    \n    vowels := []rune{'a', 'e', 'i', 'o',\
    \ 'u'}\n    \n    for _, letter := range s {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            continue\n\
    \        }\n        \n        for _, vowel := range vowels {\n            if letter\
    \ == vowel {\n                continue \n            }\n        }\n        \n\
    \        words = append(words, letter)\n    }\n    \n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprynq0y2s_test.go:45:31: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n \
    \           continue\n        }\n        \n        if strings.Contains(strings.ToLower(letter),\
    \ strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+strings.ToLower(letter)+\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp35bzoj5g_test.go:37:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075425
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    words := append(words, s)\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcd80sb1w_test.go:26:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n  \
    \          continue\n        }\n        \n        for j := 0; j < len(s); j++\
    \ {\n            if s[i] == s[j] {\n                continue \n            }\n\
    \        }\n        \n        words = append(words, s[i])\n    }\n    \n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3w3m272b_test.go:42:31: cannot use s[i] (value of type byte) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp4e6rls44_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp4e6rls44_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp4e6rls44_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp4e6rls44_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp4e6rls44_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := make([]string, 0)\n    if len(s) == 0\
    \ {\n        return words\n    }\n    vowels := []rune(\"aeiou\")\n    for _,\
    \ letter := range s {\n        if !contains(vowels, letter) {\n            words\
    \ = append(words, letter)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqo3jbg7k_test.go:32:13: undefined: contains

    /tmp/tmpqo3jbg7k_test.go:33:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpsui424rq_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpsui424rq_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpsui424rq_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpsui424rq_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpsui424rq_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := []string{}\n    vowels := []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    for _, letter := range s {\n        if strings.Contains(vowels,\
    \ letter) {\n            continue\n        }\n        if strings.Contains(consonants,\
    \ letter) {\n            words = append(words, letter)\n        }\n    }\n   \
    \ return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i7sjb0k_test.go:29:12: undefined: strings

    /tmp/tmp2i7sjb0k_test.go:32:12: undefined: strings

    /tmp/tmp2i7sjb0k_test.go:32:29: undefined: consonants

    /tmp/tmp2i7sjb0k_test.go:33:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    words := []string{}\n    \n    if len(s) == 0 {\n        return\
    \ words\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n      \
    \      continue\n        }\n        \n        if strings.Contains(vowels, letter)\
    \ {\n            continue\n        }\n        \n        if strings.Contains(consonants,\
    \ letter) {\n            words = append(words, letter)\n        }\n    }\n   \
    \ \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpasn0gqyr_test.go:35:22: invalid operation: letter == " " (mismatched types
    rune and untyped string)

    /tmp/tmpasn0gqyr_test.go:39:12: undefined: strings

    /tmp/tmpasn0gqyr_test.go:43:12: undefined: strings

    /tmp/tmpasn0gqyr_test.go:43:29: undefined: consonants

    /tmp/tmpasn0gqyr_test.go:44:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    if len(s) == 0 {\n        return words\n   \
    \ }\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    for _, r := range s {\n\
    \        if !contains(vowels, r) {\n            words = append(words, string(r))\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp919ywutw_test.go:31:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnlate1en_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp4e6rls44_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp4e6rls44_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp4e6rls44_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp4e6rls44_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp4e6rls44_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n  \
    \          continue\n        }\n        \n        for j := 0; j < len(s); j++\
    \ {\n            if s[i] == s[j] {\n                continue \n            }\n\
    \        }\n        \n        words = append(words, s[:i])\n    }\n    \n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpu0dvh64y_test.go:67: expected '[little]', got '[ M Ma Mar\
    \ Mary  Mary h Mary ha Mary had  Mary had a  Mary had a l Mary had a li Mary had\
    \ a lit Mary had a litt Mary had a littl Mary had a little  Mary had a little\
    \ l Mary had a little la Mary had a little lam]'\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpu0dvh64y_test.go:67: expected '[Mary lamb]', got '[ M Ma\
    \ Mar Mary  Mary h Mary ha Mary had  Mary had a  Mary had a l Mary had a li Mary\
    \ had a lit Mary had a litt Mary had a littl Mary had a little  Mary had a little\
    \ l Mary had a little la Mary had a little lam]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmpu0dvh64y_test.go:67: expected '[]', got '[ s si sim simp\
    \ simpl simple  simple w simple wh simple whi simple whit simple white  simple\
    \ white s simple white sp simple white spa simple white spac]'\n    --- FAIL:\
    \ TestSelect_Words/test_num__3 (0.00s)\n        tmpu0dvh64y_test.go:67: expected\
    \ '[world]', got '[ H He Hel Hell Hello  Hello w Hello wo Hello wor Hello worl]'\n\
    \    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpu0dvh64y_test.go:67:\
    \ expected '[Uncle]', got '[ U Un Unc Uncl Uncle  Uncle s Uncle sa]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpu0dvh64y_test.go:67:\
    \ expected '[b c d f]', got '[ a  a b  a b c  a b c d  a b c d e ]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    // TODO: Write your solution here\n  \
    \  \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmps1p1el5m_test.go:51: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmps1p1el5m_test.go:51:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmps1p1el5m_test.go:51: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmps1p1el5m_test.go:51:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmps1p1el5m_test.go:51: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyuq5zohf_test.go:282:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075336
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // Write your code here\n    \n    return []string{}\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpfut6j222_test.go:50: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpfut6j222_test.go:50:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpfut6j222_test.go:50: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpfut6j222_test.go:50:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpfut6j222_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n  \
    \          words = append(words, s[:i])\n            s = s[i+1:]\n        }\n\
    \    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' || s[i]\
    \ == ' ' {\n            words = append(words, s[:i])\n            s = s[i+1:]\n\
    \        }\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] ==\
    \ ' ' || s[i] == ' ' {\n            words = append(words, s[:i])\n           \
    \ s = s[i+1:]\n        }\n    }\n    \n    for i := 0; i < len(s); i++ {\n   \
    \     if s[i] == ' ' || s[i] == ' ' {\n            words = append(words, s[:i])\n\
    \            s = s[i+1:]\n        }\n    }\n    \n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] == ' ' || s[i] == ' ' {\n            words = append(words,\
    \ s[:i])\n            s = s[i+1:]\n        }\n    }\n    \n    for i := 0; i <\
    \ len(s); i++ {\n        if s[i] == ' ' || s[i] == ' ' {\n            words =\
    \ append(words, s[:i])\n            s = s[i+1:]\n        }\n    }\n    \n    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] == ' ' || s[i] == ' ' {\n       \
    \     words = append(words, s[:i])\n            s = s[i+1:]\n        }\n    }\n\
    \    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' || s[i] == '\
    \ ' {\n            words = append(words, s[:i])\n            s = s[i+1:]\n   \
    \     }\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == '\
    \ ' || s[i] == ' ' {\n            words = append(words, s[:i])\n            s\
    \ = s[i+1:]\n        }\n    }\n    \n    for i := 0; i < len(s); i++ {\n     \
    \   if s[i] == ' ' || s[i] == ' ' {\n            words = append(words, s[:i])\n\
    \            s = s[i+1:]\n        }\n    }\n    \n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] == ' ' || s[i] == ' ' {\n            words = append(words,\
    \ s[:i])\n            s = s[i+1:]\n        }\n    }\n    \n    for i := 0; i <\
    \ len(s); i++ {\n        if s[i] == ' ' || s[i] == ' ' {\n            words =\
    \ append(words, s[:i])\n            s = s[i+1:]\n        }\n    }\n    \n    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] == ' ' || \nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr2vq07kg_test.go:117:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n  \
    \          continue\n        }\n        \n        for j := 0; j < len(s); j++\
    \ {\n            if s[i] == s[j] {\n                words = []string{s[i:j+1]}\n\
    \                break\n            }\n        }\n    }\n    \n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [6:2] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [6:2]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.select_words(...)\n\t/tmp/tmpfxljsnbm_test.go:38\n\
    command-line-arguments_test.TestSelect_Words(0x0?)\n\t/tmp/tmpfxljsnbm_test.go:54\
    \ +0xb14\ntesting.tRunner(0xc000192680, 0x529088)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075427
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    words := append(words, s)\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdufubr7d_test.go:26:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075341
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    \n    return []string{}\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp3ko2j_eg_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp3ko2j_eg_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp3ko2j_eg_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp3ko2j_eg_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp3ko2j_eg_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp8hgi9y0m_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8hgi9y0m_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp8hgi9y0m_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp8hgi9y0m_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp8hgi9y0m_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := make([]string, 0)\n    words := append(words,\
    \ s)\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphf5i27ie_test.go:27:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpes1gb995_test.go:50: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpes1gb995_test.go:50:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpes1gb995_test.go:50: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpes1gb995_test.go:50:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpes1gb995_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnlate1en_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyuq5zohf_test.go:282:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075336
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp8hgi9y0m_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8hgi9y0m_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp8hgi9y0m_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp8hgi9y0m_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp8hgi9y0m_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            words\
    \ = append(words, letter)\n        }\n    }\n    \n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rn91egp_test.go:33:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n    \n    for _, letter := range s {\n        if letter == \" \" {\n \
    \           continue\n        }\n        \n        if strings.Contains(strings.ToLower(letter),\
    \ strings.ToLower(letter[:len(letter)-n])) {\n            words = append(words,\
    \ letter)\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4289hk_z_test.go:32:22: invalid operation: letter == " " (mismatched types
    rune and untyped string)

    /tmp/tmp4289hk_z_test.go:36:12: undefined: strings

    /tmp/tmp4289hk_z_test.go:36:70: invalid operation: cannot slice letter (variable
    of type rune)

    /tmp/tmp4289hk_z_test.go:37:35: cannot use letter (variable of type rune) as type
    string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, char := range s {\n        if char == ' ' || char ==\
    \ '\\t' || char == '\\n' || char == '\\r' || char == '\\v' || char == '\\f' ||\
    \ char == '\\a' {\n            continue\n        }\n        \n        if char\
    \ == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n     \
    \       words = append(words, char)\n            continue\n        }\n       \
    \ \n        if char == 'y' || char == 'a' || char == 'e' || char == 'i' || char\
    \ == 'o' || char == 'u' {\n            words = append(words, char)\n         \
    \   continue\n        }\n        \n        if char == 'h' || char == 'e' || char\
    \ == 'l' || char == 'l' || char == 'o' || char == 'r' || char == 's' || char ==\
    \ 't' || char == 'w' || char == 'y' {\n            words = append(words, char)\n\
    \            continue\n        }\n        \n        if char == 'd' || char ==\
    \ 'o' || char == 'm' || char == 'p' || char == 'r' || char == 't' || char == 'w'\
    \ || char == 'y' {\n            words = append(words, char)\n            continue\n\
    \        }\n        \n        if char == 'b' || char == 'a' || char == 'l' ||\
    \ char == 'l' || char == 'o' || char == 'r' || char == 's' || char == 't' || char\
    \ == 'w' || char == 'y' {\n            words = append(words, char)\n         \
    \   continue\n        }\n        \n        if char == 'c' || char == 'h' || char\
    \ == 'e' || char == 'l' || char == 'l' || char == 'o' || char == 'r' || char ==\
    \ 's' || char == 't' || char == 'w' || char == 'y' {\n            words = append(words,\
    \ char)\n            continue\n        }\n        \n        if char == 'f' ||\
    \ char == 'i' || char == 'l' || char == 'l' || char == 'o' || char == 'r' || char\
    \ == 's' || char == 't' || char == 'w' || char == 'y' {\n            words = append(words,\
    \ char)\n            continue\n        }\n        \n        if char == 'g' ||\
    \ char == 'l' || char == 'l' || char == 'o' || char == 'r' || char == 's' || char\
    \ == 't' || char == 'w' || char == 'y' {\n            words = append(words, char)\n\
    \            continue\n        }\n        \n        if char == 'k' || char ==\
    \ 'l' || char == 'l' || char == 'o' || char == 'r' || char == 's' || char == 't'\
    \ || char == 'w' || char == 'y' {\n            words = append(words, char)\n \
    \           continue\n        }\n        \nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxzkbw7he_test.go:81:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your code here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2jn1g8ld_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2jn1g8ld_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp2jn1g8ld_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    for _, word := range strings.Split(s, \" \") {\n        if strings.ContainsAny(word,\
    \ consonants) {\n            words = append(words, word)\n        }\n    }\n \
    \   \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxwim5yfb_test.go:31:26: undefined: strings

    /tmp/tmpxwim5yfb_test.go:32:12: undefined: strings

    /tmp/tmpxwim5yfb_test.go:32:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n\
    \    }\n    \n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    \n    for _,\
    \ letter := range s {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            words = append(words, letter)\n\
    \        }\n    }\n    \n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            words = append(words, letter)\n        }\n    }\n    \n    for _,\
    \ letter := range s {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            words = append(words, letter)\n\
    \        }\n    }\n    \n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            words = append(words, letter)\n        }\n    }\n    \n    for _,\
    \ letter := range s {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            words = append(words, letter)\n\
    \        }\n    }\n    \n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            words = append(words, letter)\n        }\n    }\n    \n    for _,\
    \ letter := range s {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            words = append(words, letter)\n\
    \        }\n    }\n    \n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            words = append(words, letter)\n        }\n    }\n    \n    for _,\
    \ letter := range s {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            words = append(words, letter)\n\
    \        }\n    }\n    \n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            words = append(words, letter)\n        }\n    }\n    \n    for _,\
    \ letter := range s {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            words = append(words, letter)\n\
    \        }\n    }\n    \n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkxaonbc__test.go:100:6: expected ''('', found TestSelect_Words

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075336
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpnlate1en_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpnlate1en_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpnlate1en_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    words := make([]string, 0)\n    for _, v := range\
    \ s {\n        if v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n\
    \            words = append(words, v)\n        }\n    }\n    return words\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0a32_0u3_test.go:29:35: cannot use v (variable of type rune) as type string
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075427
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Write your solution here\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp7oqfolpy_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7oqfolpy_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp7oqfolpy_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        count := 0\n        for _, letter := range word {\n            if\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' {\n                count++\n            }\n        }\n        if count ==\
    \ n {\n            words = append(words, word)\n        }\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpreftrnvs_test.go:26:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpujp3ajln_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    \n    // TODO: Write your code here\n    \n    return nil\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpvfogmwkm_test.go:50: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpvfogmwkm_test.go:50:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpvfogmwkm_test.go:50: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpvfogmwkm_test.go:50:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpvfogmwkm_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpsui424rq_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpsui424rq_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpsui424rq_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpsui424rq_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpsui424rq_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Your code here\n    \n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptdwxcj3p_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptdwxcj3p_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmptdwxcj3p_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if strings.ContainsAny(word, consonants) {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzz30cw3g_test.go:26:26: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:12: undefined: strings

    /tmp/tmpzz30cw3g_test.go:27:38: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    \n    if s == \"\" {\n        return words\n\
    \    }\n    \n    for _, char := range s {\n        if char == 'a' || char ==\
    \ 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'y' {\n        \
    \    words = append(words, char)\n        }\n    }\n    \n    for _, char := range\
    \ s {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' ||\
    \ char == 'u' || char == 'y' {\n            words = append(words, char)\n    \
    \    }\n    }\n    \n    for _, char := range s {\n        if char == 'a' || char\
    \ == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'y' {\n     \
    \       words = append(words, char)\n        }\n    }\n    \n    for _, char :=\
    \ range s {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o'\
    \ || char == 'u' || char == 'y' {\n            words = append(words, char)\n \
    \       }\n    }\n    \n    for _, char := range s {\n        if char == 'a' ||\
    \ char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'y' {\n\
    \            words = append(words, char)\n        }\n    }\n    \n    for _, char\
    \ := range s {\n        if char == 'a' || char == 'e' || char == 'i' || char ==\
    \ 'o' || char == 'u' || char == 'y' {\n            words = append(words, char)\n\
    \        }\n    }\n    \n    for _, char := range s {\n        if char == 'a'\
    \ || char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'y' {\n\
    \            words = append(words, char)\n        }\n    }\n    \n    for _, char\
    \ := range s {\n        if char == 'a' || char == 'e' || char == 'i' || char ==\
    \ 'o' || char == 'u' || char == 'y' {\n            words = append(words, char)\n\
    \        }\n    }\n    \n    for _, char := range s {\n        if char == 'a'\
    \ || char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'y' {\n\
    \            words = append(words, char)\n        }\n    }\n    \n    for _, char\
    \ := range s {\n        if char == 'a' || char == 'e' || char == 'i' || char ==\
    \ 'o' || char == 'u' || char == 'y' {\n            words = append(words, char)\n\
    \        }\n    }\n    \n    for _, char := range s {\n        if char == 'a'\
    \ || char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'y\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp62j91q8s_test.go:92:95: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075427
